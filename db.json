{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/js/bootstrap.scrollspy.js","path":"js/bootstrap.scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/fancy-box.js","path":"js/fancy-box.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/helpers.js","path":"js/helpers.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/hook-duoshuo.js","path":"js/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/lazyload.js","path":"js/lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/motion_fallback.js","path":"js/motion_fallback.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/motion_global.js","path":"js/motion_global.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/search-toggle.js","path":"js/search-toggle.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/ua-parser.min.js","path":"js/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/images/bkdefault_avatar.jpg","path":"images/bkdefault_avatar.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/fonts/icon-default/icomoon.eot","path":"fonts/icon-default/icomoon.eot","modified":1,"renderable":1},{"_id":"themes/next/source/fonts/icon-default/icomoon.svg","path":"fonts/icon-default/icomoon.svg","modified":1,"renderable":1},{"_id":"themes/next/source/fonts/icon-default/icomoon.ttf","path":"fonts/icon-default/icomoon.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/fonts/icon-default/icomoon.woff","path":"fonts/icon-default/icomoon.woff","modified":1,"renderable":1},{"_id":"themes/next/source/fonts/icon-feather/icomoon.eot","path":"fonts/icon-feather/icomoon.eot","modified":1,"renderable":1},{"_id":"themes/next/source/fonts/icon-feather/icomoon.svg","path":"fonts/icon-feather/icomoon.svg","modified":1,"renderable":1},{"_id":"themes/next/source/fonts/icon-feather/icomoon.ttf","path":"fonts/icon-feather/icomoon.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/fonts/icon-feather/icomoon.woff","path":"fonts/icon-feather/icomoon.woff","modified":1,"renderable":1},{"_id":"themes/next/source/fonts/icon-icomoon/icomoon.eot","path":"fonts/icon-icomoon/icomoon.eot","modified":1,"renderable":1},{"_id":"themes/next/source/fonts/icon-icomoon/icomoon.svg","path":"fonts/icon-icomoon/icomoon.svg","modified":1,"renderable":1},{"_id":"themes/next/source/fonts/icon-icomoon/icomoon.ttf","path":"fonts/icon-icomoon/icomoon.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/fonts/icon-icomoon/icomoon.woff","path":"fonts/icon-icomoon/icomoon.woff","modified":1,"renderable":1},{"_id":"themes/next/source/fonts/icon-fifty-shades/icomoon.eot","path":"fonts/icon-fifty-shades/icomoon.eot","modified":1,"renderable":1},{"_id":"themes/next/source/fonts/icon-fifty-shades/icomoon.svg","path":"fonts/icon-fifty-shades/icomoon.svg","modified":1,"renderable":1},{"_id":"themes/next/source/fonts/icon-fifty-shades/icomoon.ttf","path":"fonts/icon-fifty-shades/icomoon.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/fonts/icon-fifty-shades/icomoon.woff","path":"fonts/icon-fifty-shades/icomoon.woff","modified":1,"renderable":1},{"_id":"themes/next/source/fonts/icon-linecons/icomoon.eot","path":"fonts/icon-linecons/icomoon.eot","modified":1,"renderable":1},{"_id":"themes/next/source/fonts/icon-linecons/icomoon.ttf","path":"fonts/icon-linecons/icomoon.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/fonts/icon-linecons/icomoon.woff","path":"fonts/icon-linecons/icomoon.woff","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/velocity/bower.json","path":"vendors/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","path":"vendors/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","path":"vendors/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","path":"vendors/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/fonts/icon-linecons/icomoon.svg","path":"fonts/icon-linecons/icomoon.svg","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/jquery/index.js","path":"vendors/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","path":"vendors/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","path":"vendors/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","path":"vendors/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","path":"vendors/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","path":"vendors/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","path":"vendors/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","path":"vendors/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","path":"vendors/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","path":"vendors/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","path":"vendors/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.js","path":"vendors/velocity/velocity.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"fcbc9f594a15f10b1db6805bcb352a15337c4a22","modified":1599209361331},{"_id":"themes/next/.bowerrc","hash":"80e096fdc1cf912ee85dd9f7e6e77fd40cf60f10","modified":1437008878000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1437008878000},{"_id":"themes/next/.gitignore","hash":"8919d7f39d611f548e96fd914a78cede24016390","modified":1437008878000},{"_id":"themes/next/.jshintrc","hash":"12c5e37da3432bee2219ed1c667076d54f1639c0","modified":1437008878000},{"_id":"themes/next/README.en.md","hash":"565ba52b3825b85a9f05b41183caca7f18b741d4","modified":1437008878000},{"_id":"themes/next/README.md","hash":"aa16555d1aa1d80666ab9085042e118cdb7f5ef2","modified":1437008878000},{"_id":"themes/next/_config.yml","hash":"ab48d468fb26f036fd7ac3ffa01b9815d0b644d3","modified":1599278104646},{"_id":"themes/next/bower.json","hash":"1a681eeb5bff68be34e4e5226678c6cd3a7a12cc","modified":1437008878000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1599211483950},{"_id":"source/_posts/git项目中用工具直观的对比文件（windows）.md","hash":"32a387ca41fcf82ae3bd4da90984ad0ea2257468","modified":1599188218994},{"_id":"source/_posts/package.json部分知识.md","hash":"f60fcba8da55f00f535f52adac14eeeb09d55585","modified":1599211898216},{"_id":"source/_posts/http-head.md","hash":"ed876762e3252e5af7b72c9f87697fb690f6cdad","modified":1599188218995},{"_id":"source/_posts/promise.md","hash":"f0a65e16fd6d9acfafdf55103ff0993bff90860b","modified":1599188218995},{"_id":"source/_posts/vdom.md","hash":"8995b30a0aa3b145342c97234d203ff7186076db","modified":1599188218995},{"_id":"source/_posts/windows下的git-bash中添加tree.md","hash":"93ed3d6176d3be9f3254bfa50a9b7e6ab6802bcd","modified":1599188218996},{"_id":"source/_posts/windows自定义bash的alias.md","hash":"a5688d147d26f824e525971a066d1866761b5b5f","modified":1599205349334},{"_id":"source/_posts/一个canvas画的可自定义颜色和起止位置的动画百分比.md","hash":"c37436b505af04fd02558151efec23ace96d9968","modified":1599205349334},{"_id":"source/_posts/修改Git默认编辑器.md","hash":"775582f6802ed0d1444b218f3454104b15029bb8","modified":1526024923000},{"_id":"source/_posts/利用Expres-jade-stylus-nodemon构建前端项目.md","hash":"5f8ec49c86eda1f778916faed8740e172017f527","modified":1526024923000},{"_id":"source/_posts/打开hexo的next主题下的tags.md","hash":"08a4a3daaafc68418d0bc958dfc4b916d7e2a7eb","modified":1599276572973},{"_id":"source/tags/index.md","hash":"15d9d64dd5c5046490d97a98708030123168e2bf","modified":1599279203493},{"_id":"themes/next/languages/de.yml","hash":"784bea46de28a3113d7c91621740f521dae09dce","modified":1437008878000},{"_id":"themes/next/languages/default.yml","hash":"d0cad2843283dd2a62cb8d1a2ed182a368210aca","modified":1437008878000},{"_id":"themes/next/languages/en.yml","hash":"d0cad2843283dd2a62cb8d1a2ed182a368210aca","modified":1437008878000},{"_id":"themes/next/languages/fr-FR.yml","hash":"9ee1011db6307df957684c83f39ac7499391924c","modified":1437008878000},{"_id":"themes/next/languages/ru.yml","hash":"60cc1fb273adfd84137a207dd9d0d00f08605ccd","modified":1437008878000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"282620a222ea32c062610f4ed6af016f862ccdfa","modified":1437008878000},{"_id":"themes/next/languages/zh-hk.yml","hash":"e58766e0af5abf0705ccca4a5fc86d1be03db198","modified":1437008878000},{"_id":"themes/next/languages/zh-tw.yml","hash":"d34c5781a231978e66852784ad00c9895a7de022","modified":1437008878000},{"_id":"themes/next/layout/_layout.swig","hash":"417cc254ba47a77b43f6f45e398756a0a9a424e9","modified":1437008878000},{"_id":"themes/next/layout/archive.swig","hash":"ed242c832d27743375a5fb524dc5a116a6a723a7","modified":1437008878000},{"_id":"themes/next/layout/category.swig","hash":"ca5b5b4c091e575487a398e5f1c0947fe3a13bfc","modified":1437008878000},{"_id":"themes/next/layout/index.swig","hash":"9fcae9769998e5f4182b363ccf3ae5a026728d50","modified":1437008878000},{"_id":"themes/next/layout/page.swig","hash":"0b0924774a562ff45ed98e40c4e913df9a77fe08","modified":1437008878000},{"_id":"themes/next/layout/post.swig","hash":"3f3a183543cbb0d396484242952b02992366afef","modified":1437008878000},{"_id":"themes/next/layout/tag.swig","hash":"f1dcfbc0eef76f1f6be29f31a343338d5bbfe814","modified":1437008878000},{"_id":"themes/next/tests/.jshintrc","hash":"16d54197dd83677442c0373b8c71825a84f177b7","modified":1437008878000},{"_id":"themes/next/tests/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1437008878000},{"_id":"themes/next/tests/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1437008878000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"e0e16ca56917b51728a13453d0a2f932da7ecdcb","modified":1437008878000},{"_id":"themes/next/layout/_macro/post.swig","hash":"9f3819f348a8a3af97c0fc520ea3944da5c3e4a9","modified":1437008878000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"939dbfc3de22706702da59e67293e1f243cbcf9f","modified":1437008878000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"b4b39dd010307ab61008a70a8ae9199ceeee89b5","modified":1437008878000},{"_id":"themes/next/layout/_partials/head.swig","hash":"f2b7a6d43249622745a7d58daa11030f433d3c96","modified":1437008878000},{"_id":"themes/next/layout/_partials/header.swig","hash":"c18888bd0a26f9bda3c6f7d17e22774a56f7378b","modified":1437008878000},{"_id":"themes/next/layout/_partials/old-browsers.swig","hash":"dbbfea810bf3a2ed9c83b9a6683037175aacfc67","modified":1437008878000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"d6c7f04eee4388d8f133eb5526b7c0875c321a30","modified":1437008878000},{"_id":"themes/next/layout/_partials/search.swig","hash":"8a18d32e2a257dafaaba75353692db901e1dddc5","modified":1437008878000},{"_id":"themes/next/layout/_scripts/analytics.swig","hash":"0ebbf76c2317faa8ba31365adba59331c2e0262c","modified":1437008878000},{"_id":"themes/next/layout/_scripts/baidushare.swig","hash":"d726361945437cf6e48067b3dd041b7e36e98d85","modified":1437008878000},{"_id":"themes/next/layout/_scripts/bootstrap.scrollspy.swig","hash":"85295f126836b95f0837d03e58228bb3cf8c4490","modified":1437008878000},{"_id":"themes/next/layout/_scripts/fancy-box.swig","hash":"41b4ff1446060c88c33bf666a32277dcf12129f0","modified":1437008878000},{"_id":"themes/next/layout/_scripts/helpers.swig","hash":"4d2cbfca0aaf546a2b5813288073e824c1498fdf","modified":1437008878000},{"_id":"themes/next/layout/_scripts/mathjax.swig","hash":"abc52fefb276c52cbb19de5c214521dfcf2a10fd","modified":1437008878000},{"_id":"themes/next/layout/_scripts/motion.swig","hash":"817705bfd1a1282cb6bf59094afe507e11455aa0","modified":1437008878000},{"_id":"themes/next/source/css/main.styl","hash":"b05c342e94ded24a5f2b203cedf77d3faa817fd5","modified":1437008878000},{"_id":"themes/next/source/js/bootstrap.scrollspy.js","hash":"ae7bdce88b515aade4eea8bf7407eec458bcd625","modified":1437008878000},{"_id":"themes/next/source/js/fancy-box.js","hash":"116cafc741e048497287121a508d7a54c050c70c","modified":1437008878000},{"_id":"themes/next/source/js/helpers.js","hash":"c2117b0ec653df4c45dd9d9575b190cbe1035335","modified":1437008878000},{"_id":"themes/next/source/js/hook-duoshuo.js","hash":"a7a618126d6853d52f4e32be116d3985325ad17d","modified":1437008878000},{"_id":"themes/next/source/js/lazyload.js","hash":"b92e9acdc7afc15468314c03f4a643b0c93944cf","modified":1437008878000},{"_id":"themes/next/source/js/motion_fallback.js","hash":"a767d522c65a8b2fbad49135c9332135c6785c3e","modified":1437008878000},{"_id":"themes/next/source/js/motion_global.js","hash":"e6df9e7e61109667df0e22c4f7cc25c85015440b","modified":1437008878000},{"_id":"themes/next/source/js/search-toggle.js","hash":"0bf617514cd86307f0678a226761341100dd86d4","modified":1437008878000},{"_id":"themes/next/source/js/ua-parser.min.js","hash":"acf0ee6a47ffb7231472b56e43996e3f947c258a","modified":1437008878000},{"_id":"themes/next/source/images/bkdefault_avatar.jpg","hash":"b687bb4bfbe35a32b592c24d652ba80cfdc770fc","modified":1437008878000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1437008878000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1437008878000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1437008878000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1437008878000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1437008878000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1437008878000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1437008878000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1437008878000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1437008878000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1437008878000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1437008878000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1437008878000},{"_id":"themes/next/source/css/_mixins/default.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1437008878000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1437008878000},{"_id":"themes/next/source/css/_variables/default.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1437008878000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"ee0c2540e8178f390051af7d365a42ae68375afa","modified":1437008878000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"94beb0764ccbbba0c9f5c9886cc656bf879bcfd5","modified":1437008878000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1437008878000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1437008878000},{"_id":"themes/next/layout/_scripts/analytics/baidu-analytics.swig","hash":"7c43d66da93cde65b473a7d6db2a86f9a42647d6","modified":1437008878000},{"_id":"themes/next/layout/_scripts/analytics/google-analytics.swig","hash":"30a23fa7e816496fdec0e932aa42e2d13098a9c2","modified":1437008878000},{"_id":"themes/next/layout/_scripts/comments/disqus.swig","hash":"3491d3cebabc8a28857200db28a1be65aad6adc2","modified":1437008878000},{"_id":"themes/next/layout/_scripts/comments/duoshuo.swig","hash":"3351ea62225933f8045d036a79654e19e84d19a7","modified":1437008878000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"f0f34a08d99802c526486af58e11a6a9d1461fb1","modified":1437008878000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"68b6859fb48fe8358e567fc324f218cecfc3a533","modified":1437008878000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"66985fe77bd323f7f8f634908e17166f51e96e95","modified":1437008878000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"f5dda1ca48c1b73a0bd34e08413de57699f24083","modified":1437008878000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"59acc8bf6e6b55f576b001e520e048cd0ca801fb","modified":1437008878000},{"_id":"themes/next/source/fonts/icon-default/icomoon.eot","hash":"a58d5e893c6faefc90d5c2589cc314dff8ffca7a","modified":1437008878000},{"_id":"themes/next/source/fonts/icon-default/icomoon.svg","hash":"4f18f0bb815b1aeba57739069c3416106240b7c1","modified":1437008878000},{"_id":"themes/next/source/fonts/icon-default/icomoon.ttf","hash":"e6452f07b050ee0ff265b3b99a1e7ef82eb561b2","modified":1437008878000},{"_id":"themes/next/source/fonts/icon-default/icomoon.woff","hash":"4d0adc55240f331c6de225e23afd76ea5318da9c","modified":1437008878000},{"_id":"themes/next/source/fonts/icon-feather/icomoon.eot","hash":"6d0eb1a5bfef4f2bf77089bd090e88c5b2f7944d","modified":1437008878000},{"_id":"themes/next/source/fonts/icon-feather/icomoon.svg","hash":"690836f81c0feb1a49e2253d4f984ad543414986","modified":1437008878000},{"_id":"themes/next/source/fonts/icon-feather/icomoon.ttf","hash":"8c865cffa3845be32406737fcc0466cf9cd965b3","modified":1437008878000},{"_id":"themes/next/source/fonts/icon-feather/icomoon.woff","hash":"9159eea8641b840e0f7aa6e087dae414044ecdd3","modified":1437008878000},{"_id":"themes/next/source/fonts/icon-icomoon/icomoon.eot","hash":"301fcf00c24750dddf1c529f944ca62c7f1a217d","modified":1437008878000},{"_id":"themes/next/source/fonts/icon-icomoon/icomoon.svg","hash":"e316347805eb93425faa678611c5e42a7152da8f","modified":1437008878000},{"_id":"themes/next/source/fonts/icon-icomoon/icomoon.ttf","hash":"f399713d1c9400d4d3373e38991a7e362a754a94","modified":1437008878000},{"_id":"themes/next/source/fonts/icon-icomoon/icomoon.woff","hash":"05f1ec0bd307da5e731a86eb4961589a6042aebb","modified":1437008878000},{"_id":"themes/next/source/fonts/icon-fifty-shades/icomoon.eot","hash":"f27c3643af6ed6f3d29a0be0c8dbea9b157857db","modified":1437008878000},{"_id":"themes/next/source/fonts/icon-fifty-shades/icomoon.svg","hash":"f0790da03008b6cb3ae4215cbb656cb4b4599633","modified":1437008878000},{"_id":"themes/next/source/fonts/icon-fifty-shades/icomoon.ttf","hash":"e0b5e4a23a949bac499908bcef2fae56430e230e","modified":1437008878000},{"_id":"themes/next/source/fonts/icon-fifty-shades/icomoon.woff","hash":"088a16303b0700e1c9e2c6962240b4c2f0fc3aa4","modified":1437008878000},{"_id":"themes/next/source/fonts/icon-linecons/icomoon.eot","hash":"176695cc0dc12daba049b2bb889397a7bf2e553c","modified":1437008878000},{"_id":"themes/next/source/fonts/icon-linecons/icomoon.ttf","hash":"c8ec218adabc788b17f976f60dd1c5fa872d9fc4","modified":1437008878000},{"_id":"themes/next/source/fonts/icon-linecons/icomoon.woff","hash":"d1ed08a17670fa259df02c1d52dc9ce754343775","modified":1437008878000},{"_id":"themes/next/source/vendors/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1437008878000},{"_id":"themes/next/source/vendors/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1437008878000},{"_id":"themes/next/source/vendors/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1437008878000},{"_id":"themes/next/source/vendors/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1437008878000},{"_id":"themes/next/source/vendors/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1437008878000},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1437008878000},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1437008878000},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1437008878000},{"_id":"themes/next/source/css/_common/_page/home.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1437008878000},{"_id":"themes/next/source/fonts/icon-linecons/icomoon.svg","hash":"888a285a4a7329210b2210742c673611c27425eb","modified":1437008878000},{"_id":"themes/next/source/vendors/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1437008878000},{"_id":"themes/next/source/css/_common/_component/back-to-top.styl","hash":"88cd66910260006aa8e9e795df4948d4b67bfa11","modified":1437008878000},{"_id":"themes/next/source/css/_common/_component/buttons.styl","hash":"81063e0979f04a0f9af37f321d7321dda9abf593","modified":1437008878000},{"_id":"themes/next/source/css/_common/_component/comments.styl","hash":"54e73681ba6f57ef961138f94d2ee8ac845990c3","modified":1437008878000},{"_id":"themes/next/source/css/_common/_component/duoshuo.styl","hash":"c307f1e4827d7cb82816a5f9de109ae14ed4199c","modified":1437008878000},{"_id":"themes/next/source/css/_common/_component/gallery.styl","hash":"fa6e23ebddb6f235803b51974f36be2a43b2c9c4","modified":1437008878000},{"_id":"themes/next/source/css/_common/_component/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1437008878000},{"_id":"themes/next/source/css/_common/_component/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1437008878000},{"_id":"themes/next/source/css/_common/_component/posts-collapse.styl","hash":"8f9e8f5f65956ccf1d52ff8526392803dff579d3","modified":1437008878000},{"_id":"themes/next/source/css/_common/_component/posts-expand.styl","hash":"4b82dbbb6e536e6e8ee3cec6e62c2fd4bea60a09","modified":1437008878000},{"_id":"themes/next/source/css/_common/_component/posts-type.styl","hash":"40b593134bf96d1d6095b3439d47820659d7f10b","modified":1437008878000},{"_id":"themes/next/source/css/_common/_component/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1437008878000},{"_id":"themes/next/source/css/_common/_core/base.styl","hash":"e79a08484b191dca14ccfc005053eb95786dafae","modified":1437008878000},{"_id":"themes/next/source/css/_common/_core/helpers.styl","hash":"41a31d651b60b4f458fc56a1d191dfbbdcb6d794","modified":1437008878000},{"_id":"themes/next/source/css/_common/_core/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1437008878000},{"_id":"themes/next/source/css/_common/_core/scaffolding.styl","hash":"d776e241cf650b00ee1dd21b9ff377c250d9eeaa","modified":1437008878000},{"_id":"themes/next/source/css/_common/_core/tables.styl","hash":"be6c1a04595cf38673511366a3d89fcdb046f533","modified":1437008878000},{"_id":"themes/next/source/css/_common/_fonts/icon-default.styl","hash":"86bd4135afa2589ad074e0cf8ebb054ff3d10f24","modified":1437008878000},{"_id":"themes/next/source/css/_common/_fonts/icon-feather.styl","hash":"f49f8966496166bd62f79f75a3277d4d5b1102e8","modified":1437008878000},{"_id":"themes/next/source/css/_common/_fonts/icon-fifty-shades.styl","hash":"90e68936ea0f26af93c2c517fe1b891538f9c1b1","modified":1437008878000},{"_id":"themes/next/source/css/_common/_fonts/icon-font.styl","hash":"6fd7caf8194656b90c3b7976295f157bce593b54","modified":1437008878000},{"_id":"themes/next/source/css/_common/_fonts/icon-linecons.styl","hash":"3874252c8392b5a18e849ac69b6d66999ec1de16","modified":1437008878000},{"_id":"themes/next/source/css/_common/_page/archive.styl","hash":"dff879f55ca65fa79c07e9098719e53eeea7ac88","modified":1437008878000},{"_id":"themes/next/source/css/_common/_page/categories.styl","hash":"4f696a2eaeee2f214adcf273eab25c62a398077a","modified":1437008878000},{"_id":"themes/next/source/css/_common/_page/post-detail.styl","hash":"73796f6f13caa7151a2ee8e55755627e0d189f55","modified":1437008878000},{"_id":"themes/next/source/css/_common/_section/body.styl","hash":"ca1a4766cbe25baac757c6b47a4858d221afdc40","modified":1437008878000},{"_id":"themes/next/source/css/_common/_section/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1437008878000},{"_id":"themes/next/source/css/_common/_section/header.styl","hash":"ba501332fb111bd72dc0777f2e1c8a29ad538ff9","modified":1437008878000},{"_id":"themes/next/source/css/_common/_section/layout.styl","hash":"4daaadd156ece64ae05908ad6bb0159c8a27c071","modified":1437008878000},{"_id":"themes/next/source/css/_common/_section/media.styl","hash":"fa9809d2ecc753cf32f70803c1d0821c405211f4","modified":1437008878000},{"_id":"themes/next/source/css/_common/_section/sidebar.styl","hash":"d57e1769ebd2c472d2b27d17a706d3f564f94033","modified":1437008878000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"b0037a87ee1a613f315c331e8ecf1673c6d82211","modified":1437008878000},{"_id":"themes/next/source/css/_schemes/default/_menu.styl","hash":"4bba29cece65ffc5122f4e052063dea4439fe4ae","modified":1437008878000},{"_id":"themes/next/source/css/_schemes/default/_search.styl","hash":"05045d24850a982dc8069012c86c878b130b60eb","modified":1437008878000},{"_id":"themes/next/source/css/_schemes/default/index.styl","hash":"2588e55132e10d82c0608f03c2c72a2bace8fa4e","modified":1437008878000},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1437008878000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1437008878000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1437008878000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1437008878000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1437008878000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1437008878000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1437008878000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1437008878000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1437008878000},{"_id":"themes/next/source/css/_common/_vendor/highlight/highlight.styl","hash":"6259f4780f2aae1e6f85b892d8822c1c7ebc28bc","modified":1437008878000},{"_id":"themes/next/source/css/_common/_vendor/highlight/theme.styl","hash":"ae19721ceee5ba460e131cb2427dae3c1ff39d6f","modified":1437008878000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1437008878000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1437008878000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1437008878000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1437008878000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1437008878000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1437008878000},{"_id":"themes/next/source/vendors/velocity/velocity.js","hash":"e63dc7cea055ca60a95d286f32349d88b10c5a4d","modified":1437008878000},{"_id":"public/tags/index.html","hash":"4770bef19a9745022d540816eee3dcd9bbe574a7","modified":1599279773739},{"_id":"public/archives/index.html","hash":"d5fc655a20d1757996d7668b68341e8b75fdd06f","modified":1599279773739},{"_id":"public/archives/page/2/index.html","hash":"a4310f6cd056175e6569d31491222ac104a9c750","modified":1599279773739},{"_id":"public/archives/2016/index.html","hash":"59d3d47f6856b9ac59ad0d8a80b6d556d6fa22e4","modified":1599279773739},{"_id":"public/archives/2016/05/index.html","hash":"51936a70290ea757dd08ef57fe67df3cb19aeb6f","modified":1599279773739},{"_id":"public/archives/2018/index.html","hash":"7ee081d09ae2660ab0c0e7c594c6abe0678a8f16","modified":1599279773739},{"_id":"public/archives/2018/05/index.html","hash":"e1470b1ca975172b105bf2ebdbe07484c4901322","modified":1599279773739},{"_id":"public/archives/2020/index.html","hash":"67ec8decc43ee6207f41d8ef1a5fcf526dbd6609","modified":1599279773739},{"_id":"public/archives/2020/09/index.html","hash":"cc341a7b4a3a20e86dd1f9d3b3b732e4b3e7c3c9","modified":1599279773739},{"_id":"public/tags/git/index.html","hash":"300c70ae4f8803abf9cd10d167e5a3c68c04f0aa","modified":1599279773740},{"_id":"public/tags/nodejs/index.html","hash":"aaefb4aeb9493001f8ec99ccb637b25a5aada569","modified":1599279773740},{"_id":"public/tags/http/index.html","hash":"e1f207bdae4ce6eb1a931acb679acbdcb1d7faba","modified":1599279773740},{"_id":"public/tags/bash/index.html","hash":"abcf13fe80492cd5f11146a976ed13dc7734e596","modified":1599279773740},{"_id":"public/tags/canvas/index.html","hash":"d739d9308704697333ced996259f525fcdf42cfb","modified":1599279773740},{"_id":"public/tags/百分比/index.html","hash":"232cef42a921bfb2178712893b628266b741dcc2","modified":1599279773740},{"_id":"public/tags/前端环境/index.html","hash":"5a200fc1fee1aa8b2002ab92ba4aef7a4afa9e5e","modified":1599279773740},{"_id":"public/tags/sublime/index.html","hash":"d2c268fe340b170924b9d480100f391673bfab18","modified":1599279773740},{"_id":"public/tags/vdom/index.html","hash":"fb459c42ff3da5f3f306b38a55e5217642f7825f","modified":1599279773740},{"_id":"public/tags/promise/index.html","hash":"4dd2be0f1bbee89cd6e6b74d171b4877a95b5e87","modified":1599279773740},{"_id":"public/tags/js/index.html","hash":"57b775d1a1c2ca91cb350e7b62af465eb2c4dbff","modified":1599279773740},{"_id":"public/categories/前端/index.html","hash":"fadddd3da963c373dd5b1ec3d3f865bc6b0177d5","modified":1599279773740},{"_id":"public/page/2/index.html","hash":"67e5787daa72a15fa774aa5305f793e2edc5331f","modified":1599279773740},{"_id":"public/uncategorized/打开hexo的next主题下的tags/index.html","hash":"8f33421306cad584371fd67023814532ef07be79","modified":1599279773740},{"_id":"public/uncategorized/package.json部分知识/index.html","hash":"b2e475fffe1466e93b7564ec9b23d6bafea4d794","modified":1599279773740},{"_id":"public/uncategorized/windows自定义bash的alias/index.html","hash":"1e83009aa65a5f955b1457865f925a0e2e5b9637","modified":1599279773740},{"_id":"public/uncategorized/一个canvas画的可自定义颜色和起止位置的动画百分比/index.html","hash":"6eaa134b563725cab993713757eb74648fc7cfce","modified":1599279773740},{"_id":"public/前端/windows下的git-bash中添加tree/index.html","hash":"243a60f5537af8bdb4cc2a639515a72362546dd1","modified":1599279773741},{"_id":"public/前端/promise/index.html","hash":"6f4ee8f39d5e59ec16ac4984561ed269622689f2","modified":1599279773741},{"_id":"public/前端/vdom/index.html","hash":"31e18cbd6ff81beb73a9753e5a8fed23aced3fa6","modified":1599279773741},{"_id":"public/前端/http-head/index.html","hash":"6099aff479237d012812715983da5dfce0f16cad","modified":1599279773741},{"_id":"public/前端/git项目中用工具直观的对比文件（windows）/index.html","hash":"68015c1e75745cbddb1c91cca0039497b0c4dd52","modified":1599279773741},{"_id":"public/uncategorized/修改Git默认编辑器/index.html","hash":"ec19c445df3d34f23a6fe76596fa0040eefdd0fb","modified":1599279773741},{"_id":"public/uncategorized/利用Expres-jade-stylus-nodemon构建前端项目/index.html","hash":"842b43c55999f00f65a5b5c1115a95b06f6058b8","modified":1599279773741},{"_id":"public/index.html","hash":"2d40f3877c1a56f3a64b1015ed316302752f8821","modified":1599279773741},{"_id":"public/images/bkdefault_avatar.jpg","hash":"b687bb4bfbe35a32b592c24d652ba80cfdc770fc","modified":1599279773748},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1599279773748},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1599279773748},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1599279773748},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1599279773748},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1599279773748},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1599279773748},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1599279773748},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1599279773748},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1599279773748},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1599279773748},{"_id":"public/fonts/icon-default/icomoon.eot","hash":"a58d5e893c6faefc90d5c2589cc314dff8ffca7a","modified":1599279773748},{"_id":"public/fonts/icon-default/icomoon.ttf","hash":"e6452f07b050ee0ff265b3b99a1e7ef82eb561b2","modified":1599279773748},{"_id":"public/fonts/icon-default/icomoon.svg","hash":"4f18f0bb815b1aeba57739069c3416106240b7c1","modified":1599279773749},{"_id":"public/fonts/icon-default/icomoon.woff","hash":"4d0adc55240f331c6de225e23afd76ea5318da9c","modified":1599279773749},{"_id":"public/fonts/icon-feather/icomoon.eot","hash":"6d0eb1a5bfef4f2bf77089bd090e88c5b2f7944d","modified":1599279773749},{"_id":"public/fonts/icon-feather/icomoon.svg","hash":"690836f81c0feb1a49e2253d4f984ad543414986","modified":1599279773749},{"_id":"public/fonts/icon-feather/icomoon.ttf","hash":"8c865cffa3845be32406737fcc0466cf9cd965b3","modified":1599279773749},{"_id":"public/fonts/icon-feather/icomoon.woff","hash":"9159eea8641b840e0f7aa6e087dae414044ecdd3","modified":1599279773749},{"_id":"public/fonts/icon-icomoon/icomoon.eot","hash":"301fcf00c24750dddf1c529f944ca62c7f1a217d","modified":1599279773749},{"_id":"public/fonts/icon-icomoon/icomoon.svg","hash":"e316347805eb93425faa678611c5e42a7152da8f","modified":1599279773749},{"_id":"public/fonts/icon-icomoon/icomoon.ttf","hash":"f399713d1c9400d4d3373e38991a7e362a754a94","modified":1599279773749},{"_id":"public/fonts/icon-icomoon/icomoon.woff","hash":"05f1ec0bd307da5e731a86eb4961589a6042aebb","modified":1599279773749},{"_id":"public/fonts/icon-fifty-shades/icomoon.eot","hash":"f27c3643af6ed6f3d29a0be0c8dbea9b157857db","modified":1599279773749},{"_id":"public/fonts/icon-fifty-shades/icomoon.svg","hash":"f0790da03008b6cb3ae4215cbb656cb4b4599633","modified":1599279773749},{"_id":"public/fonts/icon-fifty-shades/icomoon.ttf","hash":"e0b5e4a23a949bac499908bcef2fae56430e230e","modified":1599279773749},{"_id":"public/fonts/icon-fifty-shades/icomoon.woff","hash":"088a16303b0700e1c9e2c6962240b4c2f0fc3aa4","modified":1599279773749},{"_id":"public/fonts/icon-linecons/icomoon.eot","hash":"176695cc0dc12daba049b2bb889397a7bf2e553c","modified":1599279773749},{"_id":"public/fonts/icon-linecons/icomoon.woff","hash":"d1ed08a17670fa259df02c1d52dc9ce754343775","modified":1599279773749},{"_id":"public/fonts/icon-linecons/icomoon.ttf","hash":"c8ec218adabc788b17f976f60dd1c5fa872d9fc4","modified":1599279773749},{"_id":"public/vendors/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1599279773749},{"_id":"public/vendors/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1599279773749},{"_id":"public/vendors/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1599279773749},{"_id":"public/vendors/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1599279773750},{"_id":"public/vendors/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1599279773750},{"_id":"public/vendors/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1599279773750},{"_id":"public/vendors/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1599279773750},{"_id":"public/fonts/icon-linecons/icomoon.svg","hash":"888a285a4a7329210b2210742c673611c27425eb","modified":1599279774098},{"_id":"public/js/fancy-box.js","hash":"116cafc741e048497287121a508d7a54c050c70c","modified":1599279774102},{"_id":"public/js/helpers.js","hash":"c2117b0ec653df4c45dd9d9575b190cbe1035335","modified":1599279774102},{"_id":"public/js/bootstrap.scrollspy.js","hash":"ae7bdce88b515aade4eea8bf7407eec458bcd625","modified":1599279774102},{"_id":"public/js/hook-duoshuo.js","hash":"e529f5d6dda3aee77fadfed879da9fe1fb570165","modified":1599279774102},{"_id":"public/js/lazyload.js","hash":"b92e9acdc7afc15468314c03f4a643b0c93944cf","modified":1599279774102},{"_id":"public/js/motion_fallback.js","hash":"a767d522c65a8b2fbad49135c9332135c6785c3e","modified":1599279774102},{"_id":"public/js/search-toggle.js","hash":"0bf617514cd86307f0678a226761341100dd86d4","modified":1599279774102},{"_id":"public/js/motion_global.js","hash":"e6df9e7e61109667df0e22c4f7cc25c85015440b","modified":1599279774102},{"_id":"public/vendors/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1599279774102},{"_id":"public/vendors/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1599279774102},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1599279774102},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1599279774103},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1599279774103},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1599279774103},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1599279774103},{"_id":"public/css/main.css","hash":"46b1ff277bb687ffa0860b8cef4ec4976d9c8c05","modified":1599279774103},{"_id":"public/js/ua-parser.min.js","hash":"acf0ee6a47ffb7231472b56e43996e3f947c258a","modified":1599279774106},{"_id":"public/vendors/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1599279774106},{"_id":"public/vendors/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1599279774110},{"_id":"public/vendors/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1599279774113},{"_id":"public/vendors/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1599279774113},{"_id":"public/vendors/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1599279774118},{"_id":"public/vendors/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1599279774132},{"_id":"public/vendors/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1599279774138}],"Category":[{"name":"前端","_id":"ckep5vtcd0002l4i9b7cxd5qb"}],"Data":[],"Page":[{"title":"tags","date":"2020-09-04T04:13:14.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"title: tags\ndate: 2020-09-04 12:13:14\ntype: \"tags\"\n---","updated":"2020-09-05T04:13:23.493Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ckep5vtfm000zl4i9ha1f6wag","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"git项目中用工具直观的对比文件（windows）","_content":"\n## 缘由\n在git项目下对比修改过的文件我们一般用`git diff`来操作，如果改动不大可以在git bash左侧看到由加减号列出增减的改动内容，但如果改动的内容太多，在git bash上显示众多的改动内容会是一个令人头疼的问题，因为git bash显示的对比过于简单、不直观，因此我们需要外部的工具来帮我们完成直观的对比。\n\n## 配置\ngit也意识到了这一点，所以我们可以通过.gitconfig文件来配置我们需要的外部对比工具（比如winMerge）。\n文件（一般直接在C盘user里你的名字文件夹下）可以配置如下：\n```\n[mergetool]\n    prompt = false\n    keepBackup = false\n    keepTemporaries = false\n \n[merge]\n    tool = winmerge\n \n[mergetool \"winmerge\"]\n    name = WinMerge\n    trustExitCode = true\n    cmd = \"/c/Program\\\\ Files\\\\ \\\\(x86\\\\)/WinMerge/WinMergeU.exe\" -u -e -dl \\\"Local\\\" -dr \\\"Remote\\\" $LOCAL $REMOTE $MERGED\n \n[diff]\n    tool = winmerge\n \n[difftool \"winmerge\"]\n    name = WinMerge\n    trustExitCode = true\n    cmd = \"/c/Program\\\\ Files\\\\ \\\\(x86\\\\)/WinMerge/WinMergeU.exe\" -u -e $LOCAL $REMOTE\n```\n里面的具体参数请参看[git官方说明](http://git-scm.com/docs/git-config)。\n\n## 调用\n当你再次遇上需要对比或合并时，就可以运行`git difftool <file>` 或 `git mergetool <file>` 来自动打开对比工具进行直观的对比。\n-- just enjoy it--\n![图片](http://www.edowning.net/pic/20083314532471369.png)\n","source":"_posts/git项目中用工具直观的对比文件（windows）.md","raw":"title: git项目中用工具直观的对比文件（windows）\ntags: git\ncategories: 前端\n---\n\n## 缘由\n在git项目下对比修改过的文件我们一般用`git diff`来操作，如果改动不大可以在git bash左侧看到由加减号列出增减的改动内容，但如果改动的内容太多，在git bash上显示众多的改动内容会是一个令人头疼的问题，因为git bash显示的对比过于简单、不直观，因此我们需要外部的工具来帮我们完成直观的对比。\n\n## 配置\ngit也意识到了这一点，所以我们可以通过.gitconfig文件来配置我们需要的外部对比工具（比如winMerge）。\n文件（一般直接在C盘user里你的名字文件夹下）可以配置如下：\n```\n[mergetool]\n    prompt = false\n    keepBackup = false\n    keepTemporaries = false\n \n[merge]\n    tool = winmerge\n \n[mergetool \"winmerge\"]\n    name = WinMerge\n    trustExitCode = true\n    cmd = \"/c/Program\\\\ Files\\\\ \\\\(x86\\\\)/WinMerge/WinMergeU.exe\" -u -e -dl \\\"Local\\\" -dr \\\"Remote\\\" $LOCAL $REMOTE $MERGED\n \n[diff]\n    tool = winmerge\n \n[difftool \"winmerge\"]\n    name = WinMerge\n    trustExitCode = true\n    cmd = \"/c/Program\\\\ Files\\\\ \\\\(x86\\\\)/WinMerge/WinMergeU.exe\" -u -e $LOCAL $REMOTE\n```\n里面的具体参数请参看[git官方说明](http://git-scm.com/docs/git-config)。\n\n## 调用\n当你再次遇上需要对比或合并时，就可以运行`git difftool <file>` 或 `git mergetool <file>` 来自动打开对比工具进行直观的对比。\n-- just enjoy it--\n![图片](http://www.edowning.net/pic/20083314532471369.png)\n","slug":"git项目中用工具直观的对比文件（windows）","published":1,"date":"2020-09-04T02:56:58.994Z","updated":"2020-09-04T02:56:58.994Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckep5vtc40000l4i90jfcuq44","content":"<h2 id=\"缘由\"><a href=\"#缘由\" class=\"headerlink\" title=\"缘由\"></a>缘由</h2><p>在git项目下对比修改过的文件我们一般用<code>git diff</code>来操作，如果改动不大可以在git bash左侧看到由加减号列出增减的改动内容，但如果改动的内容太多，在git bash上显示众多的改动内容会是一个令人头疼的问题，因为git bash显示的对比过于简单、不直观，因此我们需要外部的工具来帮我们完成直观的对比。</p>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>git也意识到了这一点，所以我们可以通过.gitconfig文件来配置我们需要的外部对比工具（比如winMerge）。<br>文件（一般直接在C盘user里你的名字文件夹下）可以配置如下：<br><figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mergetool]</span><br><span class=\"line\">    prompt = <span class=\"literal\">false</span></span><br><span class=\"line\">    keepBackup = <span class=\"literal\">false</span></span><br><span class=\"line\">    keepTemporaries = <span class=\"literal\">false</span></span><br><span class=\"line\"> </span><br><span class=\"line\">[merge]</span><br><span class=\"line\">   <span class=\"built_in\"> tool </span>= winmerge</span><br><span class=\"line\"> </span><br><span class=\"line\">[mergetool <span class=\"string\">\"winmerge\"</span>]</span><br><span class=\"line\">    name = WinMerge</span><br><span class=\"line\">    trustExitCode = <span class=\"literal\">true</span></span><br><span class=\"line\">    cmd = <span class=\"string\">\"/c/Program\\\\ Files\\\\ \\\\(x86\\\\)/WinMerge/WinMergeU.exe\"</span> -u -e -dl \\<span class=\"string\">\"Local\\\" -dr \\\"Remote\\\" <span class=\"variable\">$LOCAL</span> <span class=\"variable\">$REMOTE</span> <span class=\"variable\">$MERGED</span></span></span><br><span class=\"line\"><span class=\"string\"> </span></span><br><span class=\"line\"><span class=\"string\">[diff]</span></span><br><span class=\"line\"><span class=\"string\">    tool = winmerge</span></span><br><span class=\"line\"><span class=\"string\"> </span></span><br><span class=\"line\"><span class=\"string\">[difftool \"</span>winmerge<span class=\"string\">\"]</span></span><br><span class=\"line\"><span class=\"string\">    name = WinMerge</span></span><br><span class=\"line\"><span class=\"string\">    trustExitCode = true</span></span><br><span class=\"line\"><span class=\"string\">    cmd = \"</span>/c/Program\\\\ Files\\\\ \\\\(x86\\\\)/WinMerge/WinMergeU.exe<span class=\"string\">\" -u -e <span class=\"variable\">$LOCAL</span> <span class=\"variable\">$REMOTE</span></span></span><br></pre></td></tr></table></figure></p>\n<p>里面的具体参数请参看<a href=\"http://git-scm.com/docs/git-config\" target=\"_blank\" rel=\"noopener\">git官方说明</a>。</p>\n<h2 id=\"调用\"><a href=\"#调用\" class=\"headerlink\" title=\"调用\"></a>调用</h2><p>当你再次遇上需要对比或合并时，就可以运行<code>git difftool &lt;file&gt;</code> 或 <code>git mergetool &lt;file&gt;</code> 来自动打开对比工具进行直观的对比。<br>– just enjoy it–<br><img src=\"http://www.edowning.net/pic/20083314532471369.png\" alt=\"图片\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"缘由\"><a href=\"#缘由\" class=\"headerlink\" title=\"缘由\"></a>缘由</h2><p>在git项目下对比修改过的文件我们一般用<code>git diff</code>来操作，如果改动不大可以在git bash左侧看到由加减号列出增减的改动内容，但如果改动的内容太多，在git bash上显示众多的改动内容会是一个令人头疼的问题，因为git bash显示的对比过于简单、不直观，因此我们需要外部的工具来帮我们完成直观的对比。</p>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>git也意识到了这一点，所以我们可以通过.gitconfig文件来配置我们需要的外部对比工具（比如winMerge）。<br>文件（一般直接在C盘user里你的名字文件夹下）可以配置如下：<br><figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mergetool]</span><br><span class=\"line\">    prompt = <span class=\"literal\">false</span></span><br><span class=\"line\">    keepBackup = <span class=\"literal\">false</span></span><br><span class=\"line\">    keepTemporaries = <span class=\"literal\">false</span></span><br><span class=\"line\"> </span><br><span class=\"line\">[merge]</span><br><span class=\"line\">   <span class=\"built_in\"> tool </span>= winmerge</span><br><span class=\"line\"> </span><br><span class=\"line\">[mergetool <span class=\"string\">\"winmerge\"</span>]</span><br><span class=\"line\">    name = WinMerge</span><br><span class=\"line\">    trustExitCode = <span class=\"literal\">true</span></span><br><span class=\"line\">    cmd = <span class=\"string\">\"/c/Program\\\\ Files\\\\ \\\\(x86\\\\)/WinMerge/WinMergeU.exe\"</span> -u -e -dl \\<span class=\"string\">\"Local\\\" -dr \\\"Remote\\\" <span class=\"variable\">$LOCAL</span> <span class=\"variable\">$REMOTE</span> <span class=\"variable\">$MERGED</span></span></span><br><span class=\"line\"><span class=\"string\"> </span></span><br><span class=\"line\"><span class=\"string\">[diff]</span></span><br><span class=\"line\"><span class=\"string\">    tool = winmerge</span></span><br><span class=\"line\"><span class=\"string\"> </span></span><br><span class=\"line\"><span class=\"string\">[difftool \"</span>winmerge<span class=\"string\">\"]</span></span><br><span class=\"line\"><span class=\"string\">    name = WinMerge</span></span><br><span class=\"line\"><span class=\"string\">    trustExitCode = true</span></span><br><span class=\"line\"><span class=\"string\">    cmd = \"</span>/c/Program\\\\ Files\\\\ \\\\(x86\\\\)/WinMerge/WinMergeU.exe<span class=\"string\">\" -u -e <span class=\"variable\">$LOCAL</span> <span class=\"variable\">$REMOTE</span></span></span><br></pre></td></tr></table></figure></p>\n<p>里面的具体参数请参看<a href=\"http://git-scm.com/docs/git-config\" target=\"_blank\" rel=\"noopener\">git官方说明</a>。</p>\n<h2 id=\"调用\"><a href=\"#调用\" class=\"headerlink\" title=\"调用\"></a>调用</h2><p>当你再次遇上需要对比或合并时，就可以运行<code>git difftool &lt;file&gt;</code> 或 <code>git mergetool &lt;file&gt;</code> 来自动打开对比工具进行直观的对比。<br>– just enjoy it–<br><img src=\"http://www.edowning.net/pic/20083314532471369.png\" alt=\"图片\"></p>\n"},{"title":"pacakge.json部分知识理解","_content":"\n\n### Version\n\n软件版本号有四部分组成：\n\n- 第一部分为主版本号，变化了表示有了一个`不兼容上个版本的大更改`。\n- 第二部分为次版本号，变化了表示`增加了新功能，并且可以向后兼容`。\n- 第三部分为修订版本号，变化了表示`有bug修复，并且可以向后兼容`。\n- 第四部分为日期版本号加希腊字母版本号，希腊字母版本号共有五种，分别为base、alpha、beta 、RC 、 release\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190118111447199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgxNzExNQ==,size_16,color_FFFFFF,t_70)\n\n```js\n{\n  \"dependencies\": {\n\t\t\t\"foo\": \"2.1.0\", // 指定版本\n      \"bar\": \"~1.2.3\", // 锁定主要版本和次要版本，只能改变最后一位且大于等于当前值\n      \"elf\": \"^2.1.2\" // 主要版本非0状态下锁定大版本，次要版本和小版本可以变动为大于等于当前值，主要版本为0状态下，锁定主要版本和次要版本，同~\n    \t\"thr\": \"latest\" // 最新版本\n  \t}\n}\n```\n\n\n\n### License\n\n![img](https://ruanyifeng.com/blogimg/asset/201105/bg2011050101.png)\n\n### 依赖包\n\n**dependencies** : 业务依赖\n\n**devDependencies** ：开发依赖 \n\n**peerDependencies** : 同等/同伴依赖\n\n要求安装者安装本插件包时，指定其他依赖的版本号，但只是警告⚠️，并非强制给你安装，需要自行安装指定版本，用来解决插件与依赖的包不一致。\n\n比如安装element-ui插件包时，它会指定vue的版本号，如果你安装的vue版本号不在它指定的范围内它会警告你并提示你手动安装它指定的版本。\n\n**bundledDependencies** : 打包依赖\n\n`npm pack` 用来生成一个包含非node_modules的gtz压缩文件，如果要加上node_modules，可以在`bundledDependencies`属性里把dependencies和devDependencies已有的依赖放入数组中：\n\n```js\n\n\"name\": \"font-end\",\n\"version\": \"1.0.0\",\n\"dependencies\": {\n\t\"fe1\": \"^0.3.2\",\n\t...\n },\n\"devDependencies\": {\n\t...\n\t\"fe2\": \"^1.0.0\"\n },\n\"bundledDependencies\": [\n\t\"fe1\",\n\t\"fe2\"\n ]\n}\n```\n\n\n\n### package-lock.json\n\n- 在⼤版本相同的前提下，如果⼀个模块在 package.json 中的⼩版本要⼤于 package-lock.json 中的⼩版本，则在执⾏ npminstall 时，会将该模块更新到⼤版本下的最新的版本，并将版本号更新⾄ package-lock.json 。如果⼩于，则被package-lock.json 中的版本锁定。\n\n- 如果⼀个模块在 package.json 和 package-lock.json 中的⼤版本不相同，则在执⾏ npm install 时，都将根据 package.json 中⼤版本下的最新版本进⾏更新，并将版本号更新⾄ package-lock.json 。\n\n- 如果⼀个模块在 package.json 中有记录，⽽在 package\u0002-lock.json 中⽆记录，执⾏ npm install 后，则会在 package-lock.json ⽣成该模块的详细记录。同理，⼀个模块在 package.json 中⽆记录，⽽在 package-lock.json 中有记录，执⾏ npm install 后，则会在 package-lock.json 删除该模块的详细记录。\n\n\n\n### bin\n\n它是一个命令名和本地文件名的映射。在安装时，如果是全局安装，npm将会使用符号链接把这些文件链接到prefix/bin，如果是本地安装，会链接到./node_modules/.bin/。\n\n通俗点理解就是我们全局安装， 我们就可以在命令行中执行这个文件， 本地安装我们可以在当前工程目录的命令行中执行该文件。\n\n```js\n\"bin\": {\n  \"mason\": \"./index.js\"\n},\n```\n\n要注意： 这个index.js文件的头部必须有这个`#!/usr/bin/env node`节点， 否则脚本将在没有节点可执行文件的情况下启动。\n\nIndex.js文件：\n\n```js\n#!/usr/bin/env node\n\nconsole.log('cool')\n```\n\n\n\n全局`npm i `后接下来你在任意目录新开一个命令行， 输入`mason`， 你将看到`cool`字段。\n\nvue-cli和create-react-app都是这个道理。\n\n\n\n### script\n\nnpm 脚本的原理非常简单。每当执行npm run，就会自动新建一个 Shell，在这个 Shell 里面执行指定的脚本命令。因此，只要是 Shell（一般是 Bash）可以运行的命令，就可以写在 npm 脚本里面。\n\n比较特别的是，npm run新建的这个 Shell，会将当前目录的node_modules/.bin子目录加入PATH变量，执行结束后，再将PATH变量恢复原样。\n\n这意味着，当前目录的node_modules/.bin子目录里面的所有脚本，都可以直接用脚本名调用，而不必加上路径。比如，当前项目的依赖里面有 Mocha，只要直接写mocha test就可以了。\n\n- 通配符：`*`表示任意文件名，`**`表示任意一层子目录。\n\n  ```js\n  \"lint\": \"jshint *.js\"\n  \"lint\": \"jshint **/*.js\"\n  ```\n\n如果要将通配符传入原始命令，防止被 Shell 转义，要将星号转义。\n\n   ```js\n   \"test\": \"tap test/\\*.js\"\n   ```\n\n- 脚本传参符号： --\n\n  ```js\n  \"server\": \"webpack-dev-server --mode=development --open --iframe=true \"\n  ```\n\n- 脚本执行顺序\n\n  并行执行（即同时的平行执行），可以使用`&`符号\n\n  ```js\n  npm run script1.js & npm run script2.js\n  ```\n\n  继发执行（即只有前一个任务成功，才执行下一个任务），可以使用`&&`符号\n\n  ```js\n  $ npm run script1.js && npm run script2.js\n  ```\n\n- 脚本钩子\n\n  npm 脚本有pre和post两个钩子。举例来说，build脚本命令的钩子就是prebuild和postbuild。\n\n  ```\n  \"prebuild\": \"echo I run before the build script\",\n  \"build\": \"cross-env NODE_ENV=production webpack\",\n\"postbuild\": \"echo I run after the build script\"\n  ```\n\n  用户执行npm run build的时候，会自动按照下面的顺序执行。\n\n  ```\n  npm run prebuild && npm run build && npm run postbuild\n  ```\n  \n  因此，可以在这两个钩子里面，完成一些准备工作和清理工作。下面是一个例子。\n  \n  ```\n  \"clean\": \"rimraf ./dist && mkdir dist\",\n  \"prebuild\": \"npm run clean\",\n  \"build\": \"cross-env NODE_ENV=production webpack\"\n  ```\n  \n  \n  \n  npm 默认提供下面这些钩子。\n  \n  - prepublish，postpublish\n  - preinstall，postinstall\n  - preuninstall，postuninstall\n  - preversion，postversion\n  - pretest，posttest\n  - prestop，poststop\n  - prestart，poststart\n  - prerestart，postrestart\n  \n  自定义的脚本命令也可以加上pre和post钩子。比如，myscript这个脚本命令，也有premyscript和postmyscript钩子。不过，双重的pre和post无效，比如prepretest和postposttest是无效的。\n  \n  npm 提供一个npm_lifecycle_event变量，返回当前正在运行的脚本名称，比如pretest、test、posttest等等。所以，可以利用这个变量，在同一个脚本文件里面，为不同的npm scripts命令编写代码。请看下面的例子。\n  \n  ```js\n  const TARGET = process.env.npm_lifecycle_event;\n   \n  if (TARGET === 'test') {\n   console.log(`Running the test task!`);\n  }\n   \n  if (TARGET === 'pretest') {\n   console.log(`Running the pretest task!`);\n  }\n   \n  if (TARGET === 'posttest') {\n   console.log(`Running the posttest task!`);\n  }\n  ```\n  \n  \n  \n  \n\n### windows下拿到package.json的变量\n\n需要安装cross-env\n\n```js\nnpm install cross-env --save-dev\n```\n\nPackage.json:\n\n```js\n\"page\": \"test\",\n  \"scripts\": {\n    \"dev\": \"cross-env PAGE=$npm_package_page cross-env NODE_ENV=dev \n  },\n```\n\n在执行 `npm run dev`的时候通过 `process.env.NODE_ENV` 即可获取环境变量 `dev`，通过`process.env.PAGE`即可获取变量`test`\n\n\n\n\n\n","source":"_posts/package.json部分知识.md","raw":"\ntitle: pacakge.json部分知识理解\ntags: [nodejs]\n---\n\n\n### Version\n\n软件版本号有四部分组成：\n\n- 第一部分为主版本号，变化了表示有了一个`不兼容上个版本的大更改`。\n- 第二部分为次版本号，变化了表示`增加了新功能，并且可以向后兼容`。\n- 第三部分为修订版本号，变化了表示`有bug修复，并且可以向后兼容`。\n- 第四部分为日期版本号加希腊字母版本号，希腊字母版本号共有五种，分别为base、alpha、beta 、RC 、 release\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190118111447199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgxNzExNQ==,size_16,color_FFFFFF,t_70)\n\n```js\n{\n  \"dependencies\": {\n\t\t\t\"foo\": \"2.1.0\", // 指定版本\n      \"bar\": \"~1.2.3\", // 锁定主要版本和次要版本，只能改变最后一位且大于等于当前值\n      \"elf\": \"^2.1.2\" // 主要版本非0状态下锁定大版本，次要版本和小版本可以变动为大于等于当前值，主要版本为0状态下，锁定主要版本和次要版本，同~\n    \t\"thr\": \"latest\" // 最新版本\n  \t}\n}\n```\n\n\n\n### License\n\n![img](https://ruanyifeng.com/blogimg/asset/201105/bg2011050101.png)\n\n### 依赖包\n\n**dependencies** : 业务依赖\n\n**devDependencies** ：开发依赖 \n\n**peerDependencies** : 同等/同伴依赖\n\n要求安装者安装本插件包时，指定其他依赖的版本号，但只是警告⚠️，并非强制给你安装，需要自行安装指定版本，用来解决插件与依赖的包不一致。\n\n比如安装element-ui插件包时，它会指定vue的版本号，如果你安装的vue版本号不在它指定的范围内它会警告你并提示你手动安装它指定的版本。\n\n**bundledDependencies** : 打包依赖\n\n`npm pack` 用来生成一个包含非node_modules的gtz压缩文件，如果要加上node_modules，可以在`bundledDependencies`属性里把dependencies和devDependencies已有的依赖放入数组中：\n\n```js\n\n\"name\": \"font-end\",\n\"version\": \"1.0.0\",\n\"dependencies\": {\n\t\"fe1\": \"^0.3.2\",\n\t...\n },\n\"devDependencies\": {\n\t...\n\t\"fe2\": \"^1.0.0\"\n },\n\"bundledDependencies\": [\n\t\"fe1\",\n\t\"fe2\"\n ]\n}\n```\n\n\n\n### package-lock.json\n\n- 在⼤版本相同的前提下，如果⼀个模块在 package.json 中的⼩版本要⼤于 package-lock.json 中的⼩版本，则在执⾏ npminstall 时，会将该模块更新到⼤版本下的最新的版本，并将版本号更新⾄ package-lock.json 。如果⼩于，则被package-lock.json 中的版本锁定。\n\n- 如果⼀个模块在 package.json 和 package-lock.json 中的⼤版本不相同，则在执⾏ npm install 时，都将根据 package.json 中⼤版本下的最新版本进⾏更新，并将版本号更新⾄ package-lock.json 。\n\n- 如果⼀个模块在 package.json 中有记录，⽽在 package\u0002-lock.json 中⽆记录，执⾏ npm install 后，则会在 package-lock.json ⽣成该模块的详细记录。同理，⼀个模块在 package.json 中⽆记录，⽽在 package-lock.json 中有记录，执⾏ npm install 后，则会在 package-lock.json 删除该模块的详细记录。\n\n\n\n### bin\n\n它是一个命令名和本地文件名的映射。在安装时，如果是全局安装，npm将会使用符号链接把这些文件链接到prefix/bin，如果是本地安装，会链接到./node_modules/.bin/。\n\n通俗点理解就是我们全局安装， 我们就可以在命令行中执行这个文件， 本地安装我们可以在当前工程目录的命令行中执行该文件。\n\n```js\n\"bin\": {\n  \"mason\": \"./index.js\"\n},\n```\n\n要注意： 这个index.js文件的头部必须有这个`#!/usr/bin/env node`节点， 否则脚本将在没有节点可执行文件的情况下启动。\n\nIndex.js文件：\n\n```js\n#!/usr/bin/env node\n\nconsole.log('cool')\n```\n\n\n\n全局`npm i `后接下来你在任意目录新开一个命令行， 输入`mason`， 你将看到`cool`字段。\n\nvue-cli和create-react-app都是这个道理。\n\n\n\n### script\n\nnpm 脚本的原理非常简单。每当执行npm run，就会自动新建一个 Shell，在这个 Shell 里面执行指定的脚本命令。因此，只要是 Shell（一般是 Bash）可以运行的命令，就可以写在 npm 脚本里面。\n\n比较特别的是，npm run新建的这个 Shell，会将当前目录的node_modules/.bin子目录加入PATH变量，执行结束后，再将PATH变量恢复原样。\n\n这意味着，当前目录的node_modules/.bin子目录里面的所有脚本，都可以直接用脚本名调用，而不必加上路径。比如，当前项目的依赖里面有 Mocha，只要直接写mocha test就可以了。\n\n- 通配符：`*`表示任意文件名，`**`表示任意一层子目录。\n\n  ```js\n  \"lint\": \"jshint *.js\"\n  \"lint\": \"jshint **/*.js\"\n  ```\n\n如果要将通配符传入原始命令，防止被 Shell 转义，要将星号转义。\n\n   ```js\n   \"test\": \"tap test/\\*.js\"\n   ```\n\n- 脚本传参符号： --\n\n  ```js\n  \"server\": \"webpack-dev-server --mode=development --open --iframe=true \"\n  ```\n\n- 脚本执行顺序\n\n  并行执行（即同时的平行执行），可以使用`&`符号\n\n  ```js\n  npm run script1.js & npm run script2.js\n  ```\n\n  继发执行（即只有前一个任务成功，才执行下一个任务），可以使用`&&`符号\n\n  ```js\n  $ npm run script1.js && npm run script2.js\n  ```\n\n- 脚本钩子\n\n  npm 脚本有pre和post两个钩子。举例来说，build脚本命令的钩子就是prebuild和postbuild。\n\n  ```\n  \"prebuild\": \"echo I run before the build script\",\n  \"build\": \"cross-env NODE_ENV=production webpack\",\n\"postbuild\": \"echo I run after the build script\"\n  ```\n\n  用户执行npm run build的时候，会自动按照下面的顺序执行。\n\n  ```\n  npm run prebuild && npm run build && npm run postbuild\n  ```\n  \n  因此，可以在这两个钩子里面，完成一些准备工作和清理工作。下面是一个例子。\n  \n  ```\n  \"clean\": \"rimraf ./dist && mkdir dist\",\n  \"prebuild\": \"npm run clean\",\n  \"build\": \"cross-env NODE_ENV=production webpack\"\n  ```\n  \n  \n  \n  npm 默认提供下面这些钩子。\n  \n  - prepublish，postpublish\n  - preinstall，postinstall\n  - preuninstall，postuninstall\n  - preversion，postversion\n  - pretest，posttest\n  - prestop，poststop\n  - prestart，poststart\n  - prerestart，postrestart\n  \n  自定义的脚本命令也可以加上pre和post钩子。比如，myscript这个脚本命令，也有premyscript和postmyscript钩子。不过，双重的pre和post无效，比如prepretest和postposttest是无效的。\n  \n  npm 提供一个npm_lifecycle_event变量，返回当前正在运行的脚本名称，比如pretest、test、posttest等等。所以，可以利用这个变量，在同一个脚本文件里面，为不同的npm scripts命令编写代码。请看下面的例子。\n  \n  ```js\n  const TARGET = process.env.npm_lifecycle_event;\n   \n  if (TARGET === 'test') {\n   console.log(`Running the test task!`);\n  }\n   \n  if (TARGET === 'pretest') {\n   console.log(`Running the pretest task!`);\n  }\n   \n  if (TARGET === 'posttest') {\n   console.log(`Running the posttest task!`);\n  }\n  ```\n  \n  \n  \n  \n\n### windows下拿到package.json的变量\n\n需要安装cross-env\n\n```js\nnpm install cross-env --save-dev\n```\n\nPackage.json:\n\n```js\n\"page\": \"test\",\n  \"scripts\": {\n    \"dev\": \"cross-env PAGE=$npm_package_page cross-env NODE_ENV=dev \n  },\n```\n\n在执行 `npm run dev`的时候通过 `process.env.NODE_ENV` 即可获取环境变量 `dev`，通过`process.env.PAGE`即可获取变量`test`\n\n\n\n\n\n","slug":"package.json部分知识","published":1,"date":"2020-09-04T09:31:38.216Z","updated":"2020-09-04T09:31:38.216Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckep5vtcb0001l4i9u1dnsdc1","content":"<h3 id=\"Version\"><a href=\"#Version\" class=\"headerlink\" title=\"Version\"></a>Version</h3><p>软件版本号有四部分组成：</p>\n<ul>\n<li>第一部分为主版本号，变化了表示有了一个<code>不兼容上个版本的大更改</code>。</li>\n<li>第二部分为次版本号，变化了表示<code>增加了新功能，并且可以向后兼容</code>。</li>\n<li>第三部分为修订版本号，变化了表示<code>有bug修复，并且可以向后兼容</code>。</li>\n<li>第四部分为日期版本号加希腊字母版本号，希腊字母版本号共有五种，分别为base、alpha、beta 、RC 、 release<br><img src=\"https://img-blog.csdnimg.cn/20190118111447199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgxNzExNQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"dependencies\"</span>: &#123;</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"foo\"</span>: <span class=\"string\">\"2.1.0\"</span>, <span class=\"comment\">// 指定版本</span></span><br><span class=\"line\">      <span class=\"string\">\"bar\"</span>: <span class=\"string\">\"~1.2.3\"</span>, <span class=\"comment\">// 锁定主要版本和次要版本，只能改变最后一位且大于等于当前值</span></span><br><span class=\"line\">      <span class=\"string\">\"elf\"</span>: <span class=\"string\">\"^2.1.2\"</span> <span class=\"comment\">// 主要版本非0状态下锁定大版本，次要版本和小版本可以变动为大于等于当前值，主要版本为0状态下，锁定主要版本和次要版本，同~</span></span><br><span class=\"line\">    \t<span class=\"string\">\"thr\"</span>: <span class=\"string\">\"latest\"</span> <span class=\"comment\">// 最新版本</span></span><br><span class=\"line\">  \t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"License\"><a href=\"#License\" class=\"headerlink\" title=\"License\"></a>License</h3><p><img src=\"https://ruanyifeng.com/blogimg/asset/201105/bg2011050101.png\" alt=\"img\"></p>\n<h3 id=\"依赖包\"><a href=\"#依赖包\" class=\"headerlink\" title=\"依赖包\"></a>依赖包</h3><p><strong>dependencies</strong> : 业务依赖</p>\n<p><strong>devDependencies</strong> ：开发依赖 </p>\n<p><strong>peerDependencies</strong> : 同等/同伴依赖</p>\n<p>要求安装者安装本插件包时，指定其他依赖的版本号，但只是警告⚠️，并非强制给你安装，需要自行安装指定版本，用来解决插件与依赖的包不一致。</p>\n<p>比如安装element-ui插件包时，它会指定vue的版本号，如果你安装的vue版本号不在它指定的范围内它会警告你并提示你手动安装它指定的版本。</p>\n<p><strong>bundledDependencies</strong> : 打包依赖</p>\n<p><code>npm pack</code> 用来生成一个包含非node_modules的gtz压缩文件，如果要加上node_modules，可以在<code>bundledDependencies</code>属性里把dependencies和devDependencies已有的依赖放入数组中：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">\"name\"</span>: <span class=\"string\">\"font-end\"</span>,</span><br><span class=\"line\"><span class=\"string\">\"version\"</span>: <span class=\"string\">\"1.0.0\"</span>,</span><br><span class=\"line\"><span class=\"string\">\"dependencies\"</span>: &#123;</span><br><span class=\"line\">\t<span class=\"string\">\"fe1\"</span>: <span class=\"string\">\"^0.3.2\"</span>,</span><br><span class=\"line\">\t...</span><br><span class=\"line\"> &#125;,</span><br><span class=\"line\"><span class=\"string\">\"devDependencies\"</span>: &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"string\">\"fe2\"</span>: <span class=\"string\">\"^1.0.0\"</span></span><br><span class=\"line\"> &#125;,</span><br><span class=\"line\"><span class=\"string\">\"bundledDependencies\"</span>: [</span><br><span class=\"line\">\t<span class=\"string\">\"fe1\"</span>,</span><br><span class=\"line\">\t<span class=\"string\">\"fe2\"</span></span><br><span class=\"line\"> ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"package-lock-json\"><a href=\"#package-lock-json\" class=\"headerlink\" title=\"package-lock.json\"></a>package-lock.json</h3><ul>\n<li><p>在⼤版本相同的前提下，如果⼀个模块在 package.json 中的⼩版本要⼤于 package-lock.json 中的⼩版本，则在执⾏ npminstall 时，会将该模块更新到⼤版本下的最新的版本，并将版本号更新⾄ package-lock.json 。如果⼩于，则被package-lock.json 中的版本锁定。</p>\n</li>\n<li><p>如果⼀个模块在 package.json 和 package-lock.json 中的⼤版本不相同，则在执⾏ npm install 时，都将根据 package.json 中⼤版本下的最新版本进⾏更新，并将版本号更新⾄ package-lock.json 。</p>\n</li>\n<li><p>如果⼀个模块在 package.json 中有记录，⽽在 package\u0002-lock.json 中⽆记录，执⾏ npm install 后，则会在 package-lock.json ⽣成该模块的详细记录。同理，⼀个模块在 package.json 中⽆记录，⽽在 package-lock.json 中有记录，执⾏ npm install 后，则会在 package-lock.json 删除该模块的详细记录。</p>\n</li>\n</ul>\n<h3 id=\"bin\"><a href=\"#bin\" class=\"headerlink\" title=\"bin\"></a>bin</h3><p>它是一个命令名和本地文件名的映射。在安装时，如果是全局安装，npm将会使用符号链接把这些文件链接到prefix/bin，如果是本地安装，会链接到./node_modules/.bin/。</p>\n<p>通俗点理解就是我们全局安装， 我们就可以在命令行中执行这个文件， 本地安装我们可以在当前工程目录的命令行中执行该文件。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"bin\"</span>: &#123;</span><br><span class=\"line\">  <span class=\"string\">\"mason\"</span>: <span class=\"string\">\"./index.js\"</span></span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<p>要注意： 这个index.js文件的头部必须有这个<code>#!/usr/bin/env node</code>节点， 否则脚本将在没有节点可执行文件的情况下启动。</p>\n<p>Index.js文件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/usr/bin/env node</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'cool'</span>)</span><br></pre></td></tr></table></figure>\n<p>全局<code>npm i</code>后接下来你在任意目录新开一个命令行， 输入<code>mason</code>， 你将看到<code>cool</code>字段。</p>\n<p>vue-cli和create-react-app都是这个道理。</p>\n<h3 id=\"script\"><a href=\"#script\" class=\"headerlink\" title=\"script\"></a>script</h3><p>npm 脚本的原理非常简单。每当执行npm run，就会自动新建一个 Shell，在这个 Shell 里面执行指定的脚本命令。因此，只要是 Shell（一般是 Bash）可以运行的命令，就可以写在 npm 脚本里面。</p>\n<p>比较特别的是，npm run新建的这个 Shell，会将当前目录的node_modules/.bin子目录加入PATH变量，执行结束后，再将PATH变量恢复原样。</p>\n<p>这意味着，当前目录的node_modules/.bin子目录里面的所有脚本，都可以直接用脚本名调用，而不必加上路径。比如，当前项目的依赖里面有 Mocha，只要直接写mocha test就可以了。</p>\n<ul>\n<li><p>通配符：<code>*</code>表示任意文件名，<code>**</code>表示任意一层子目录。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"lint\"</span>: <span class=\"string\">\"jshint *.js\"</span></span><br><span class=\"line\"><span class=\"string\">\"lint\"</span>: <span class=\"string\">\"jshint **/*.js\"</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>如果要将通配符传入原始命令，防止被 Shell 转义，要将星号转义。</p>\n   <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"test\"</span>: <span class=\"string\">\"tap test/\\*.js\"</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>脚本传参符号： –</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"server\"</span>: <span class=\"string\">\"webpack-dev-server --mode=development --open --iframe=true \"</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>脚本执行顺序</p>\n<p>并行执行（即同时的平行执行），可以使用<code>&amp;</code>符号</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run script1.js &amp; npm run script2.js</span><br></pre></td></tr></table></figure>\n<p>继发执行（即只有前一个任务成功，才执行下一个任务），可以使用<code>&amp;&amp;</code>符号</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm run script1.js &amp;&amp; npm run script2.js</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>脚本钩子</p>\n<p>npm 脚本有pre和post两个钩子。举例来说，build脚本命令的钩子就是prebuild和postbuild。</p>\n<figure class=\"highlight smalltalk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"comment\">\"prebuild\"</span>: <span class=\"comment\">\"echo I run before the build script\"</span>,</span><br><span class=\"line\">  <span class=\"comment\">\"build\"</span>: <span class=\"comment\">\"cross-env NODE_ENV=production webpack\"</span>,</span><br><span class=\"line\"><span class=\"comment\">\"postbuild\"</span>: <span class=\"comment\">\"echo I run after the build script\"</span></span><br></pre></td></tr></table></figure>\n<p>用户执行npm run build的时候，会自动按照下面的顺序执行。</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm <span class=\"builtin-name\">run</span> prebuild &amp;&amp; npm <span class=\"builtin-name\">run</span> build &amp;&amp; npm <span class=\"builtin-name\">run</span> postbuild</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>  因此，可以在这两个钩子里面，完成一些准备工作和清理工作。下面是一个例子。</p>\n  <figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"clean\"</span>: <span class=\"string\">\"rimraf ./dist &amp;&amp; mkdir dist\"</span>,</span><br><span class=\"line\"><span class=\"string\">\"prebuild\"</span>: <span class=\"string\">\"npm run clean\"</span>,</span><br><span class=\"line\"><span class=\"string\">\"build\"</span>: <span class=\"string\">\"cross-env NODE_ENV=production webpack\"</span></span><br></pre></td></tr></table></figure>\n<p>  npm 默认提供下面这些钩子。</p>\n<ul>\n<li>prepublish，postpublish</li>\n<li>preinstall，postinstall</li>\n<li>preuninstall，postuninstall</li>\n<li>preversion，postversion</li>\n<li>pretest，posttest</li>\n<li>prestop，poststop</li>\n<li>prestart，poststart</li>\n<li><p>prerestart，postrestart</p>\n<p>自定义的脚本命令也可以加上pre和post钩子。比如，myscript这个脚本命令，也有premyscript和postmyscript钩子。不过，双重的pre和post无效，比如prepretest和postposttest是无效的。</p>\n<p>npm 提供一个npm_lifecycle_event变量，返回当前正在运行的脚本名称，比如pretest、test、posttest等等。所以，可以利用这个变量，在同一个脚本文件里面，为不同的npm scripts命令编写代码。请看下面的例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> TARGET = process.env.npm_lifecycle_event;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">if</span> (TARGET === <span class=\"string\">'test'</span>) &#123;</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">`Running the test task!`</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">if</span> (TARGET === <span class=\"string\">'pretest'</span>) &#123;</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">`Running the pretest task!`</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">if</span> (TARGET === <span class=\"string\">'posttest'</span>) &#123;</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">`Running the posttest task!`</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"windows下拿到package-json的变量\"><a href=\"#windows下拿到package-json的变量\" class=\"headerlink\" title=\"windows下拿到package.json的变量\"></a>windows下拿到package.json的变量</h3><p>需要安装cross-env</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install cross-env --save-dev</span><br></pre></td></tr></table></figure>\n<p>Package.json:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"page\"</span>: <span class=\"string\">\"test\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"dev\"</span>: <span class=\"string\">\"cross-env PAGE=$npm_package_page cross-env NODE_ENV=dev </span></span><br><span class=\"line\"><span class=\"string\">  &#125;,</span></span><br></pre></td></tr></table></figure>\n<p>在执行 <code>npm run dev</code>的时候通过 <code>process.env.NODE_ENV</code> 即可获取环境变量 <code>dev</code>，通过<code>process.env.PAGE</code>即可获取变量<code>test</code></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Version\"><a href=\"#Version\" class=\"headerlink\" title=\"Version\"></a>Version</h3><p>软件版本号有四部分组成：</p>\n<ul>\n<li>第一部分为主版本号，变化了表示有了一个<code>不兼容上个版本的大更改</code>。</li>\n<li>第二部分为次版本号，变化了表示<code>增加了新功能，并且可以向后兼容</code>。</li>\n<li>第三部分为修订版本号，变化了表示<code>有bug修复，并且可以向后兼容</code>。</li>\n<li>第四部分为日期版本号加希腊字母版本号，希腊字母版本号共有五种，分别为base、alpha、beta 、RC 、 release<br><img src=\"https://img-blog.csdnimg.cn/20190118111447199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgxNzExNQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"dependencies\"</span>: &#123;</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"foo\"</span>: <span class=\"string\">\"2.1.0\"</span>, <span class=\"comment\">// 指定版本</span></span><br><span class=\"line\">      <span class=\"string\">\"bar\"</span>: <span class=\"string\">\"~1.2.3\"</span>, <span class=\"comment\">// 锁定主要版本和次要版本，只能改变最后一位且大于等于当前值</span></span><br><span class=\"line\">      <span class=\"string\">\"elf\"</span>: <span class=\"string\">\"^2.1.2\"</span> <span class=\"comment\">// 主要版本非0状态下锁定大版本，次要版本和小版本可以变动为大于等于当前值，主要版本为0状态下，锁定主要版本和次要版本，同~</span></span><br><span class=\"line\">    \t<span class=\"string\">\"thr\"</span>: <span class=\"string\">\"latest\"</span> <span class=\"comment\">// 最新版本</span></span><br><span class=\"line\">  \t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"License\"><a href=\"#License\" class=\"headerlink\" title=\"License\"></a>License</h3><p><img src=\"https://ruanyifeng.com/blogimg/asset/201105/bg2011050101.png\" alt=\"img\"></p>\n<h3 id=\"依赖包\"><a href=\"#依赖包\" class=\"headerlink\" title=\"依赖包\"></a>依赖包</h3><p><strong>dependencies</strong> : 业务依赖</p>\n<p><strong>devDependencies</strong> ：开发依赖 </p>\n<p><strong>peerDependencies</strong> : 同等/同伴依赖</p>\n<p>要求安装者安装本插件包时，指定其他依赖的版本号，但只是警告⚠️，并非强制给你安装，需要自行安装指定版本，用来解决插件与依赖的包不一致。</p>\n<p>比如安装element-ui插件包时，它会指定vue的版本号，如果你安装的vue版本号不在它指定的范围内它会警告你并提示你手动安装它指定的版本。</p>\n<p><strong>bundledDependencies</strong> : 打包依赖</p>\n<p><code>npm pack</code> 用来生成一个包含非node_modules的gtz压缩文件，如果要加上node_modules，可以在<code>bundledDependencies</code>属性里把dependencies和devDependencies已有的依赖放入数组中：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">\"name\"</span>: <span class=\"string\">\"font-end\"</span>,</span><br><span class=\"line\"><span class=\"string\">\"version\"</span>: <span class=\"string\">\"1.0.0\"</span>,</span><br><span class=\"line\"><span class=\"string\">\"dependencies\"</span>: &#123;</span><br><span class=\"line\">\t<span class=\"string\">\"fe1\"</span>: <span class=\"string\">\"^0.3.2\"</span>,</span><br><span class=\"line\">\t...</span><br><span class=\"line\"> &#125;,</span><br><span class=\"line\"><span class=\"string\">\"devDependencies\"</span>: &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"string\">\"fe2\"</span>: <span class=\"string\">\"^1.0.0\"</span></span><br><span class=\"line\"> &#125;,</span><br><span class=\"line\"><span class=\"string\">\"bundledDependencies\"</span>: [</span><br><span class=\"line\">\t<span class=\"string\">\"fe1\"</span>,</span><br><span class=\"line\">\t<span class=\"string\">\"fe2\"</span></span><br><span class=\"line\"> ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"package-lock-json\"><a href=\"#package-lock-json\" class=\"headerlink\" title=\"package-lock.json\"></a>package-lock.json</h3><ul>\n<li><p>在⼤版本相同的前提下，如果⼀个模块在 package.json 中的⼩版本要⼤于 package-lock.json 中的⼩版本，则在执⾏ npminstall 时，会将该模块更新到⼤版本下的最新的版本，并将版本号更新⾄ package-lock.json 。如果⼩于，则被package-lock.json 中的版本锁定。</p>\n</li>\n<li><p>如果⼀个模块在 package.json 和 package-lock.json 中的⼤版本不相同，则在执⾏ npm install 时，都将根据 package.json 中⼤版本下的最新版本进⾏更新，并将版本号更新⾄ package-lock.json 。</p>\n</li>\n<li><p>如果⼀个模块在 package.json 中有记录，⽽在 package\u0002-lock.json 中⽆记录，执⾏ npm install 后，则会在 package-lock.json ⽣成该模块的详细记录。同理，⼀个模块在 package.json 中⽆记录，⽽在 package-lock.json 中有记录，执⾏ npm install 后，则会在 package-lock.json 删除该模块的详细记录。</p>\n</li>\n</ul>\n<h3 id=\"bin\"><a href=\"#bin\" class=\"headerlink\" title=\"bin\"></a>bin</h3><p>它是一个命令名和本地文件名的映射。在安装时，如果是全局安装，npm将会使用符号链接把这些文件链接到prefix/bin，如果是本地安装，会链接到./node_modules/.bin/。</p>\n<p>通俗点理解就是我们全局安装， 我们就可以在命令行中执行这个文件， 本地安装我们可以在当前工程目录的命令行中执行该文件。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"bin\"</span>: &#123;</span><br><span class=\"line\">  <span class=\"string\">\"mason\"</span>: <span class=\"string\">\"./index.js\"</span></span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<p>要注意： 这个index.js文件的头部必须有这个<code>#!/usr/bin/env node</code>节点， 否则脚本将在没有节点可执行文件的情况下启动。</p>\n<p>Index.js文件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/usr/bin/env node</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'cool'</span>)</span><br></pre></td></tr></table></figure>\n<p>全局<code>npm i</code>后接下来你在任意目录新开一个命令行， 输入<code>mason</code>， 你将看到<code>cool</code>字段。</p>\n<p>vue-cli和create-react-app都是这个道理。</p>\n<h3 id=\"script\"><a href=\"#script\" class=\"headerlink\" title=\"script\"></a>script</h3><p>npm 脚本的原理非常简单。每当执行npm run，就会自动新建一个 Shell，在这个 Shell 里面执行指定的脚本命令。因此，只要是 Shell（一般是 Bash）可以运行的命令，就可以写在 npm 脚本里面。</p>\n<p>比较特别的是，npm run新建的这个 Shell，会将当前目录的node_modules/.bin子目录加入PATH变量，执行结束后，再将PATH变量恢复原样。</p>\n<p>这意味着，当前目录的node_modules/.bin子目录里面的所有脚本，都可以直接用脚本名调用，而不必加上路径。比如，当前项目的依赖里面有 Mocha，只要直接写mocha test就可以了。</p>\n<ul>\n<li><p>通配符：<code>*</code>表示任意文件名，<code>**</code>表示任意一层子目录。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"lint\"</span>: <span class=\"string\">\"jshint *.js\"</span></span><br><span class=\"line\"><span class=\"string\">\"lint\"</span>: <span class=\"string\">\"jshint **/*.js\"</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>如果要将通配符传入原始命令，防止被 Shell 转义，要将星号转义。</p>\n   <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"test\"</span>: <span class=\"string\">\"tap test/\\*.js\"</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>脚本传参符号： –</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"server\"</span>: <span class=\"string\">\"webpack-dev-server --mode=development --open --iframe=true \"</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>脚本执行顺序</p>\n<p>并行执行（即同时的平行执行），可以使用<code>&amp;</code>符号</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run script1.js &amp; npm run script2.js</span><br></pre></td></tr></table></figure>\n<p>继发执行（即只有前一个任务成功，才执行下一个任务），可以使用<code>&amp;&amp;</code>符号</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm run script1.js &amp;&amp; npm run script2.js</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>脚本钩子</p>\n<p>npm 脚本有pre和post两个钩子。举例来说，build脚本命令的钩子就是prebuild和postbuild。</p>\n<figure class=\"highlight smalltalk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"comment\">\"prebuild\"</span>: <span class=\"comment\">\"echo I run before the build script\"</span>,</span><br><span class=\"line\">  <span class=\"comment\">\"build\"</span>: <span class=\"comment\">\"cross-env NODE_ENV=production webpack\"</span>,</span><br><span class=\"line\"><span class=\"comment\">\"postbuild\"</span>: <span class=\"comment\">\"echo I run after the build script\"</span></span><br></pre></td></tr></table></figure>\n<p>用户执行npm run build的时候，会自动按照下面的顺序执行。</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm <span class=\"builtin-name\">run</span> prebuild &amp;&amp; npm <span class=\"builtin-name\">run</span> build &amp;&amp; npm <span class=\"builtin-name\">run</span> postbuild</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>  因此，可以在这两个钩子里面，完成一些准备工作和清理工作。下面是一个例子。</p>\n  <figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"clean\"</span>: <span class=\"string\">\"rimraf ./dist &amp;&amp; mkdir dist\"</span>,</span><br><span class=\"line\"><span class=\"string\">\"prebuild\"</span>: <span class=\"string\">\"npm run clean\"</span>,</span><br><span class=\"line\"><span class=\"string\">\"build\"</span>: <span class=\"string\">\"cross-env NODE_ENV=production webpack\"</span></span><br></pre></td></tr></table></figure>\n<p>  npm 默认提供下面这些钩子。</p>\n<ul>\n<li>prepublish，postpublish</li>\n<li>preinstall，postinstall</li>\n<li>preuninstall，postuninstall</li>\n<li>preversion，postversion</li>\n<li>pretest，posttest</li>\n<li>prestop，poststop</li>\n<li>prestart，poststart</li>\n<li><p>prerestart，postrestart</p>\n<p>自定义的脚本命令也可以加上pre和post钩子。比如，myscript这个脚本命令，也有premyscript和postmyscript钩子。不过，双重的pre和post无效，比如prepretest和postposttest是无效的。</p>\n<p>npm 提供一个npm_lifecycle_event变量，返回当前正在运行的脚本名称，比如pretest、test、posttest等等。所以，可以利用这个变量，在同一个脚本文件里面，为不同的npm scripts命令编写代码。请看下面的例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> TARGET = process.env.npm_lifecycle_event;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">if</span> (TARGET === <span class=\"string\">'test'</span>) &#123;</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">`Running the test task!`</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">if</span> (TARGET === <span class=\"string\">'pretest'</span>) &#123;</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">`Running the pretest task!`</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">if</span> (TARGET === <span class=\"string\">'posttest'</span>) &#123;</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">`Running the posttest task!`</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"windows下拿到package-json的变量\"><a href=\"#windows下拿到package-json的变量\" class=\"headerlink\" title=\"windows下拿到package.json的变量\"></a>windows下拿到package.json的变量</h3><p>需要安装cross-env</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install cross-env --save-dev</span><br></pre></td></tr></table></figure>\n<p>Package.json:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"page\"</span>: <span class=\"string\">\"test\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"dev\"</span>: <span class=\"string\">\"cross-env PAGE=$npm_package_page cross-env NODE_ENV=dev </span></span><br><span class=\"line\"><span class=\"string\">  &#125;,</span></span><br></pre></td></tr></table></figure>\n<p>在执行 <code>npm run dev</code>的时候通过 <code>process.env.NODE_ENV</code> 即可获取环境变量 <code>dev</code>，通过<code>process.env.PAGE</code>即可获取变量<code>test</code></p>\n"},{"title":"HTTP协议详解之消息报头篇","_content":"\n\n\n###HTTP消息？\n\nHTTP消息由客户端到服务器的请求和服务器到客户端的响应组成。请求消息和响应消息都是由开始行（对于请求消息，开始行就是请求行，对于响应消息，开始行就是状态行），消息报头（可选），空行（只有CRLF的行），消息正文（可选）组成。**常用于分析ajax请求等。**\n\n### HTTP消息报头分类\n\nHTTP消息报头包括`普通报头`、`请求报头`、`响应报头`、`实体报头`。\n每一个报头域都是由名字+“：”+空格+值 组成，消息报头域的名字是大小写无关的。\n\n![head](/images/head.png)\n\n#####1、普通报头\n\n在普通报头中，有少数报头域用于所有的请求和响应消息，但并不用于被传输的实体，只用于传输的消息。\n\neg：\nCache-Control 用于指定缓存指令，缓存指令是单向的（响应中出现的缓存指令在请求中未必会出现），且是独立的（一个消息的缓存指令不会影响另一个消息处理的缓存机制），HTTP1.0使用的类似的报头域为Pragma。\n请求时的缓存指令包括：no-cache（用于指示请求或响应消息不能缓存）、no-store、max-age、max-stale、min-fresh、only-if-cached;\n响应时的缓存指令包括：public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age、s-maxage.\n\n\neg：为了指示IE浏览器（客户端）不要缓存页面，服务器端的JSP程序可以编写如下：response.sehHeader(\"Cache-Control\",\"no-cache\");\n//response.setHeader(\"Pragma\",\"no-cache\");作用相当于上述代码，通常两者//合用\n这句代码将在发送的响应消息中设置普通报头域：Cache-Control:no-cache\n\nDate普通报头域表示消息产生的日期和时间\n\nConnection普通报头域允许发送指定连接的选项。例如指定连接是连续，或者指定“close”选项，通知服务器，在响应完成后，关闭连接\n\n\n\n#####2、请求报头\n\n请求报头允许客户端向服务器端传递请求的附加信息以及客户端自身的信息。\n常用的请求报头\n\n**Accept**\n\nAccept请求报头域用于指定客户端接受哪些类型的信息。eg：Accept：image/gif，表明客户端希望接受GIF图象格式的资源；Accept：text/html，表明客户端希望接受html文本。\n\n**Accept-Charset**\n\nAccept-Charset请求报头域用于指定客户端接受的字符集。eg：Accept-Charset:iso-8859-1,gb2312.如果在请求消息中没有设置这个域，缺省是任何字符集都可以接受。\n\n**Accept-Encoding**\n\nAccept-Encoding请求报头域类似于Accept，但是它是用于指定可接受的内容编码。eg：Accept-Encoding:gzip.deflate.如果请求消息中没有设置这个域服务器假定客户端对各种内容编码都可以接受。\n\n**Accept-Language**\n\nAccept-Language请求报头域类似于Accept，但是它是用于指定一种自然语言。eg：Accept-Language:zh-cn.如果请求消息中没有设置这个报头域，服务器假定客户端对各种语言都可以接受。\n\n**Authorization**\n\nAuthorization请求报头域主要用于证明客户端有权查看某个资源。当浏览器访问一个页面时，如果收到服务器的响应代码为401（未授权），可以发送一个包含Authorization请求报头域的请求，要求服务器对其进行验证。\n\n**Host（发送请求时，该报头域是必需的）**\n\nHost请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的，eg：\n我们在浏览器中输入：http://www.guet.edu.cn/index.html\n浏览器发送的请求消息中，就会包含Host请求报头域，如下：\nHost：www.guet.edu.cn\n此处使用缺省端口号80，若指定了端口号，则变成：Host：www.guet.edu.cn:指定端口号\n\n**User-Agent**\n\n我们上网登陆论坛的时候，往往会看到一些欢迎信息，其中列出了你的操作系统的名称和版本，你所使用的浏览器的名称和版本，这往往让很多人感到很神奇，实际上，服务器应用程序就是从User-Agent这个请求报头域中获取到这些信息。User-Agent请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。不过，这个报头域不是必需的，如果我们自己编写一个浏览器，不使用User-Agent请求报头域，那么服务器端就无法得知我们的信息了。\n\n#####3、响应报头\n\n响应报头允许服务器传递不能放在状态行中的附加响应信息，以及关于服务器的信息和对Request-URI所标识的资源进行下一步访问的信息。\n常用的响应报头\n\n\n**Location**\n\nLocation响应报头域用于重定向接受者到一个新的位置。Location响应报头域常用在更换域名的时候。\n\n**Server**\n\nServer响应报头域包含了服务器用来处理请求的软件信息。与User-Agent请求报头域是相对应的。下面是\nServer响应报头域的一个例子：\nServer：Apache-Coyote/1.1\n\n**WWW-Authenticate**\n\nWWW-Authenticate响应报头域必须被包含在401（未授权的）响应消息中，客户端收到401响应消息时候，并发送Authorization报头域请求服务器对其进行验证时，服务端响应报头就包含该报头域。\neg：WWW-Authenticate:Basic realm=\"Basic Auth Test!\" //可以看出服务器对请求资源采用的是基本验证机制\n\n#####4、实体报头\n\n请求和响应消息都可以传送一个实体。一个实体由实体报头域和实体正文组成，但并不是说实体报头域和实体正文要在一起发送，可以只发送实体报头域。实体报头定义了关于实体正文（eg：有无实体正文）和请求所标识的资源的元信息。\n常用的实体报头\n\n**Content-Encoding**\n\nContent- Encoding实体报头域被用作媒体类型的修饰符，它的值指示了已经被应用到实体正文的附加内容的编码，因而要获得Content-Type报头域中所引用的媒体类型，必须采用相应的解码机制。Content-Encoding这样用于记录文档的压缩方法，eg：Content- Encoding：gzip\n\n**Content-Language**\n\nContent-Language实体报头域描述了资源所用的自然语言。没有设置该域则认为实体内容将提供给所有的语言阅读\n者。eg：Content-Language:da\n\n**Content-Length**\n\nContent-Length实体报头域用于指明实体正文的长度，以字节方式存储的十进制数字来表示。\n\n**Content-Type**\n\nContent-Type实体报头域用语指明发送给接收者的实体正文的媒体类型。eg：\nContent-Type:text/html;charset=ISO-8859-1\nContent-Type:text/html;charset=GB2312\n\n**Last-Modified**\n\nLast-Modified实体报头域用于指示资源的最后修改日期和时间。\n\n**Expires**\n\nExpires 实体报头域给出响应过期的日期和时间。为了让代理服务器或浏览器在一段时间以后更新缓存中(再次访问曾访问过的页面时，直接从缓存中加载，缩短响应时间和降低服务器负载)的页面，我们可以使用Expires实体报头域指定页面过期的时间。eg：Expires：Thu，15 Sep 2006 16:23:12 GMT\nHTTP1.1的客户端和缓存必须将其他非法的日期格式（包括0）看作已经过期。eg：为了让浏览器不要缓存页面，我们也可以利用Expires实体报头域，设置为0，jsp中程序如下：response.setDateHeader(\"Expires\",\"0\");\n\n\n","source":"_posts/http-head.md","raw":"title: HTTP协议详解之消息报头篇\ntags: [http]\ncategories: 前端\n---\n\n\n\n###HTTP消息？\n\nHTTP消息由客户端到服务器的请求和服务器到客户端的响应组成。请求消息和响应消息都是由开始行（对于请求消息，开始行就是请求行，对于响应消息，开始行就是状态行），消息报头（可选），空行（只有CRLF的行），消息正文（可选）组成。**常用于分析ajax请求等。**\n\n### HTTP消息报头分类\n\nHTTP消息报头包括`普通报头`、`请求报头`、`响应报头`、`实体报头`。\n每一个报头域都是由名字+“：”+空格+值 组成，消息报头域的名字是大小写无关的。\n\n![head](/images/head.png)\n\n#####1、普通报头\n\n在普通报头中，有少数报头域用于所有的请求和响应消息，但并不用于被传输的实体，只用于传输的消息。\n\neg：\nCache-Control 用于指定缓存指令，缓存指令是单向的（响应中出现的缓存指令在请求中未必会出现），且是独立的（一个消息的缓存指令不会影响另一个消息处理的缓存机制），HTTP1.0使用的类似的报头域为Pragma。\n请求时的缓存指令包括：no-cache（用于指示请求或响应消息不能缓存）、no-store、max-age、max-stale、min-fresh、only-if-cached;\n响应时的缓存指令包括：public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age、s-maxage.\n\n\neg：为了指示IE浏览器（客户端）不要缓存页面，服务器端的JSP程序可以编写如下：response.sehHeader(\"Cache-Control\",\"no-cache\");\n//response.setHeader(\"Pragma\",\"no-cache\");作用相当于上述代码，通常两者//合用\n这句代码将在发送的响应消息中设置普通报头域：Cache-Control:no-cache\n\nDate普通报头域表示消息产生的日期和时间\n\nConnection普通报头域允许发送指定连接的选项。例如指定连接是连续，或者指定“close”选项，通知服务器，在响应完成后，关闭连接\n\n\n\n#####2、请求报头\n\n请求报头允许客户端向服务器端传递请求的附加信息以及客户端自身的信息。\n常用的请求报头\n\n**Accept**\n\nAccept请求报头域用于指定客户端接受哪些类型的信息。eg：Accept：image/gif，表明客户端希望接受GIF图象格式的资源；Accept：text/html，表明客户端希望接受html文本。\n\n**Accept-Charset**\n\nAccept-Charset请求报头域用于指定客户端接受的字符集。eg：Accept-Charset:iso-8859-1,gb2312.如果在请求消息中没有设置这个域，缺省是任何字符集都可以接受。\n\n**Accept-Encoding**\n\nAccept-Encoding请求报头域类似于Accept，但是它是用于指定可接受的内容编码。eg：Accept-Encoding:gzip.deflate.如果请求消息中没有设置这个域服务器假定客户端对各种内容编码都可以接受。\n\n**Accept-Language**\n\nAccept-Language请求报头域类似于Accept，但是它是用于指定一种自然语言。eg：Accept-Language:zh-cn.如果请求消息中没有设置这个报头域，服务器假定客户端对各种语言都可以接受。\n\n**Authorization**\n\nAuthorization请求报头域主要用于证明客户端有权查看某个资源。当浏览器访问一个页面时，如果收到服务器的响应代码为401（未授权），可以发送一个包含Authorization请求报头域的请求，要求服务器对其进行验证。\n\n**Host（发送请求时，该报头域是必需的）**\n\nHost请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的，eg：\n我们在浏览器中输入：http://www.guet.edu.cn/index.html\n浏览器发送的请求消息中，就会包含Host请求报头域，如下：\nHost：www.guet.edu.cn\n此处使用缺省端口号80，若指定了端口号，则变成：Host：www.guet.edu.cn:指定端口号\n\n**User-Agent**\n\n我们上网登陆论坛的时候，往往会看到一些欢迎信息，其中列出了你的操作系统的名称和版本，你所使用的浏览器的名称和版本，这往往让很多人感到很神奇，实际上，服务器应用程序就是从User-Agent这个请求报头域中获取到这些信息。User-Agent请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。不过，这个报头域不是必需的，如果我们自己编写一个浏览器，不使用User-Agent请求报头域，那么服务器端就无法得知我们的信息了。\n\n#####3、响应报头\n\n响应报头允许服务器传递不能放在状态行中的附加响应信息，以及关于服务器的信息和对Request-URI所标识的资源进行下一步访问的信息。\n常用的响应报头\n\n\n**Location**\n\nLocation响应报头域用于重定向接受者到一个新的位置。Location响应报头域常用在更换域名的时候。\n\n**Server**\n\nServer响应报头域包含了服务器用来处理请求的软件信息。与User-Agent请求报头域是相对应的。下面是\nServer响应报头域的一个例子：\nServer：Apache-Coyote/1.1\n\n**WWW-Authenticate**\n\nWWW-Authenticate响应报头域必须被包含在401（未授权的）响应消息中，客户端收到401响应消息时候，并发送Authorization报头域请求服务器对其进行验证时，服务端响应报头就包含该报头域。\neg：WWW-Authenticate:Basic realm=\"Basic Auth Test!\" //可以看出服务器对请求资源采用的是基本验证机制\n\n#####4、实体报头\n\n请求和响应消息都可以传送一个实体。一个实体由实体报头域和实体正文组成，但并不是说实体报头域和实体正文要在一起发送，可以只发送实体报头域。实体报头定义了关于实体正文（eg：有无实体正文）和请求所标识的资源的元信息。\n常用的实体报头\n\n**Content-Encoding**\n\nContent- Encoding实体报头域被用作媒体类型的修饰符，它的值指示了已经被应用到实体正文的附加内容的编码，因而要获得Content-Type报头域中所引用的媒体类型，必须采用相应的解码机制。Content-Encoding这样用于记录文档的压缩方法，eg：Content- Encoding：gzip\n\n**Content-Language**\n\nContent-Language实体报头域描述了资源所用的自然语言。没有设置该域则认为实体内容将提供给所有的语言阅读\n者。eg：Content-Language:da\n\n**Content-Length**\n\nContent-Length实体报头域用于指明实体正文的长度，以字节方式存储的十进制数字来表示。\n\n**Content-Type**\n\nContent-Type实体报头域用语指明发送给接收者的实体正文的媒体类型。eg：\nContent-Type:text/html;charset=ISO-8859-1\nContent-Type:text/html;charset=GB2312\n\n**Last-Modified**\n\nLast-Modified实体报头域用于指示资源的最后修改日期和时间。\n\n**Expires**\n\nExpires 实体报头域给出响应过期的日期和时间。为了让代理服务器或浏览器在一段时间以后更新缓存中(再次访问曾访问过的页面时，直接从缓存中加载，缩短响应时间和降低服务器负载)的页面，我们可以使用Expires实体报头域指定页面过期的时间。eg：Expires：Thu，15 Sep 2006 16:23:12 GMT\nHTTP1.1的客户端和缓存必须将其他非法的日期格式（包括0）看作已经过期。eg：为了让浏览器不要缓存页面，我们也可以利用Expires实体报头域，设置为0，jsp中程序如下：response.setDateHeader(\"Expires\",\"0\");\n\n\n","slug":"http-head","published":1,"date":"2020-09-04T02:56:58.995Z","updated":"2020-09-04T02:56:58.995Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckep5vtcf0004l4i99epf94qs","content":"<p>###HTTP消息？</p>\n<p>HTTP消息由客户端到服务器的请求和服务器到客户端的响应组成。请求消息和响应消息都是由开始行（对于请求消息，开始行就是请求行，对于响应消息，开始行就是状态行），消息报头（可选），空行（只有CRLF的行），消息正文（可选）组成。<strong>常用于分析ajax请求等。</strong></p>\n<h3 id=\"HTTP消息报头分类\"><a href=\"#HTTP消息报头分类\" class=\"headerlink\" title=\"HTTP消息报头分类\"></a>HTTP消息报头分类</h3><p>HTTP消息报头包括<code>普通报头</code>、<code>请求报头</code>、<code>响应报头</code>、<code>实体报头</code>。<br>每一个报头域都是由名字+“：”+空格+值 组成，消息报头域的名字是大小写无关的。</p>\n<p><img src=\"/images/head.png\" alt=\"head\"></p>\n<p>#####1、普通报头</p>\n<p>在普通报头中，有少数报头域用于所有的请求和响应消息，但并不用于被传输的实体，只用于传输的消息。</p>\n<p>eg：<br>Cache-Control 用于指定缓存指令，缓存指令是单向的（响应中出现的缓存指令在请求中未必会出现），且是独立的（一个消息的缓存指令不会影响另一个消息处理的缓存机制），HTTP1.0使用的类似的报头域为Pragma。<br>请求时的缓存指令包括：no-cache（用于指示请求或响应消息不能缓存）、no-store、max-age、max-stale、min-fresh、only-if-cached;<br>响应时的缓存指令包括：public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age、s-maxage.</p>\n<p>eg：为了指示IE浏览器（客户端）不要缓存页面，服务器端的JSP程序可以编写如下：response.sehHeader(“Cache-Control”,”no-cache”);<br>//response.setHeader(“Pragma”,”no-cache”);作用相当于上述代码，通常两者//合用<br>这句代码将在发送的响应消息中设置普通报头域：Cache-Control:no-cache</p>\n<p>Date普通报头域表示消息产生的日期和时间</p>\n<p>Connection普通报头域允许发送指定连接的选项。例如指定连接是连续，或者指定“close”选项，通知服务器，在响应完成后，关闭连接</p>\n<p>#####2、请求报头</p>\n<p>请求报头允许客户端向服务器端传递请求的附加信息以及客户端自身的信息。<br>常用的请求报头</p>\n<p><strong>Accept</strong></p>\n<p>Accept请求报头域用于指定客户端接受哪些类型的信息。eg：Accept：image/gif，表明客户端希望接受GIF图象格式的资源；Accept：text/html，表明客户端希望接受html文本。</p>\n<p><strong>Accept-Charset</strong></p>\n<p>Accept-Charset请求报头域用于指定客户端接受的字符集。eg：Accept-Charset:iso-8859-1,gb2312.如果在请求消息中没有设置这个域，缺省是任何字符集都可以接受。</p>\n<p><strong>Accept-Encoding</strong></p>\n<p>Accept-Encoding请求报头域类似于Accept，但是它是用于指定可接受的内容编码。eg：Accept-Encoding:gzip.deflate.如果请求消息中没有设置这个域服务器假定客户端对各种内容编码都可以接受。</p>\n<p><strong>Accept-Language</strong></p>\n<p>Accept-Language请求报头域类似于Accept，但是它是用于指定一种自然语言。eg：Accept-Language:zh-cn.如果请求消息中没有设置这个报头域，服务器假定客户端对各种语言都可以接受。</p>\n<p><strong>Authorization</strong></p>\n<p>Authorization请求报头域主要用于证明客户端有权查看某个资源。当浏览器访问一个页面时，如果收到服务器的响应代码为401（未授权），可以发送一个包含Authorization请求报头域的请求，要求服务器对其进行验证。</p>\n<p><strong>Host（发送请求时，该报头域是必需的）</strong></p>\n<p>Host请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的，eg：<br>我们在浏览器中输入：<a href=\"http://www.guet.edu.cn/index.html\" target=\"_blank\" rel=\"noopener\">http://www.guet.edu.cn/index.html</a><br>浏览器发送的请求消息中，就会包含Host请求报头域，如下：<br>Host：<a href=\"http://www.guet.edu.cn\" target=\"_blank\" rel=\"noopener\">www.guet.edu.cn</a><br>此处使用缺省端口号80，若指定了端口号，则变成：Host：<a href=\"http://www.guet.edu.cn:指定端口号\" target=\"_blank\" rel=\"noopener\">www.guet.edu.cn:指定端口号</a></p>\n<p><strong>User-Agent</strong></p>\n<p>我们上网登陆论坛的时候，往往会看到一些欢迎信息，其中列出了你的操作系统的名称和版本，你所使用的浏览器的名称和版本，这往往让很多人感到很神奇，实际上，服务器应用程序就是从User-Agent这个请求报头域中获取到这些信息。User-Agent请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。不过，这个报头域不是必需的，如果我们自己编写一个浏览器，不使用User-Agent请求报头域，那么服务器端就无法得知我们的信息了。</p>\n<p>#####3、响应报头</p>\n<p>响应报头允许服务器传递不能放在状态行中的附加响应信息，以及关于服务器的信息和对Request-URI所标识的资源进行下一步访问的信息。<br>常用的响应报头</p>\n<p><strong>Location</strong></p>\n<p>Location响应报头域用于重定向接受者到一个新的位置。Location响应报头域常用在更换域名的时候。</p>\n<p><strong>Server</strong></p>\n<p>Server响应报头域包含了服务器用来处理请求的软件信息。与User-Agent请求报头域是相对应的。下面是<br>Server响应报头域的一个例子：<br>Server：Apache-Coyote/1.1</p>\n<p><strong>WWW-Authenticate</strong></p>\n<p>WWW-Authenticate响应报头域必须被包含在401（未授权的）响应消息中，客户端收到401响应消息时候，并发送Authorization报头域请求服务器对其进行验证时，服务端响应报头就包含该报头域。<br>eg：WWW-Authenticate:Basic realm=”Basic Auth Test!” //可以看出服务器对请求资源采用的是基本验证机制</p>\n<p>#####4、实体报头</p>\n<p>请求和响应消息都可以传送一个实体。一个实体由实体报头域和实体正文组成，但并不是说实体报头域和实体正文要在一起发送，可以只发送实体报头域。实体报头定义了关于实体正文（eg：有无实体正文）和请求所标识的资源的元信息。<br>常用的实体报头</p>\n<p><strong>Content-Encoding</strong></p>\n<p>Content- Encoding实体报头域被用作媒体类型的修饰符，它的值指示了已经被应用到实体正文的附加内容的编码，因而要获得Content-Type报头域中所引用的媒体类型，必须采用相应的解码机制。Content-Encoding这样用于记录文档的压缩方法，eg：Content- Encoding：gzip</p>\n<p><strong>Content-Language</strong></p>\n<p>Content-Language实体报头域描述了资源所用的自然语言。没有设置该域则认为实体内容将提供给所有的语言阅读<br>者。eg：Content-Language:da</p>\n<p><strong>Content-Length</strong></p>\n<p>Content-Length实体报头域用于指明实体正文的长度，以字节方式存储的十进制数字来表示。</p>\n<p><strong>Content-Type</strong></p>\n<p>Content-Type实体报头域用语指明发送给接收者的实体正文的媒体类型。eg：<br>Content-Type:text/html;charset=ISO-8859-1<br>Content-Type:text/html;charset=GB2312</p>\n<p><strong>Last-Modified</strong></p>\n<p>Last-Modified实体报头域用于指示资源的最后修改日期和时间。</p>\n<p><strong>Expires</strong></p>\n<p>Expires 实体报头域给出响应过期的日期和时间。为了让代理服务器或浏览器在一段时间以后更新缓存中(再次访问曾访问过的页面时，直接从缓存中加载，缩短响应时间和降低服务器负载)的页面，我们可以使用Expires实体报头域指定页面过期的时间。eg：Expires：Thu，15 Sep 2006 16:23:12 GMT<br>HTTP1.1的客户端和缓存必须将其他非法的日期格式（包括0）看作已经过期。eg：为了让浏览器不要缓存页面，我们也可以利用Expires实体报头域，设置为0，jsp中程序如下：response.setDateHeader(“Expires”,”0”);</p>\n","site":{"data":{}},"excerpt":"","more":"<p>###HTTP消息？</p>\n<p>HTTP消息由客户端到服务器的请求和服务器到客户端的响应组成。请求消息和响应消息都是由开始行（对于请求消息，开始行就是请求行，对于响应消息，开始行就是状态行），消息报头（可选），空行（只有CRLF的行），消息正文（可选）组成。<strong>常用于分析ajax请求等。</strong></p>\n<h3 id=\"HTTP消息报头分类\"><a href=\"#HTTP消息报头分类\" class=\"headerlink\" title=\"HTTP消息报头分类\"></a>HTTP消息报头分类</h3><p>HTTP消息报头包括<code>普通报头</code>、<code>请求报头</code>、<code>响应报头</code>、<code>实体报头</code>。<br>每一个报头域都是由名字+“：”+空格+值 组成，消息报头域的名字是大小写无关的。</p>\n<p><img src=\"/images/head.png\" alt=\"head\"></p>\n<p>#####1、普通报头</p>\n<p>在普通报头中，有少数报头域用于所有的请求和响应消息，但并不用于被传输的实体，只用于传输的消息。</p>\n<p>eg：<br>Cache-Control 用于指定缓存指令，缓存指令是单向的（响应中出现的缓存指令在请求中未必会出现），且是独立的（一个消息的缓存指令不会影响另一个消息处理的缓存机制），HTTP1.0使用的类似的报头域为Pragma。<br>请求时的缓存指令包括：no-cache（用于指示请求或响应消息不能缓存）、no-store、max-age、max-stale、min-fresh、only-if-cached;<br>响应时的缓存指令包括：public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age、s-maxage.</p>\n<p>eg：为了指示IE浏览器（客户端）不要缓存页面，服务器端的JSP程序可以编写如下：response.sehHeader(“Cache-Control”,”no-cache”);<br>//response.setHeader(“Pragma”,”no-cache”);作用相当于上述代码，通常两者//合用<br>这句代码将在发送的响应消息中设置普通报头域：Cache-Control:no-cache</p>\n<p>Date普通报头域表示消息产生的日期和时间</p>\n<p>Connection普通报头域允许发送指定连接的选项。例如指定连接是连续，或者指定“close”选项，通知服务器，在响应完成后，关闭连接</p>\n<p>#####2、请求报头</p>\n<p>请求报头允许客户端向服务器端传递请求的附加信息以及客户端自身的信息。<br>常用的请求报头</p>\n<p><strong>Accept</strong></p>\n<p>Accept请求报头域用于指定客户端接受哪些类型的信息。eg：Accept：image/gif，表明客户端希望接受GIF图象格式的资源；Accept：text/html，表明客户端希望接受html文本。</p>\n<p><strong>Accept-Charset</strong></p>\n<p>Accept-Charset请求报头域用于指定客户端接受的字符集。eg：Accept-Charset:iso-8859-1,gb2312.如果在请求消息中没有设置这个域，缺省是任何字符集都可以接受。</p>\n<p><strong>Accept-Encoding</strong></p>\n<p>Accept-Encoding请求报头域类似于Accept，但是它是用于指定可接受的内容编码。eg：Accept-Encoding:gzip.deflate.如果请求消息中没有设置这个域服务器假定客户端对各种内容编码都可以接受。</p>\n<p><strong>Accept-Language</strong></p>\n<p>Accept-Language请求报头域类似于Accept，但是它是用于指定一种自然语言。eg：Accept-Language:zh-cn.如果请求消息中没有设置这个报头域，服务器假定客户端对各种语言都可以接受。</p>\n<p><strong>Authorization</strong></p>\n<p>Authorization请求报头域主要用于证明客户端有权查看某个资源。当浏览器访问一个页面时，如果收到服务器的响应代码为401（未授权），可以发送一个包含Authorization请求报头域的请求，要求服务器对其进行验证。</p>\n<p><strong>Host（发送请求时，该报头域是必需的）</strong></p>\n<p>Host请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的，eg：<br>我们在浏览器中输入：<a href=\"http://www.guet.edu.cn/index.html\" target=\"_blank\" rel=\"noopener\">http://www.guet.edu.cn/index.html</a><br>浏览器发送的请求消息中，就会包含Host请求报头域，如下：<br>Host：<a href=\"http://www.guet.edu.cn\" target=\"_blank\" rel=\"noopener\">www.guet.edu.cn</a><br>此处使用缺省端口号80，若指定了端口号，则变成：Host：<a href=\"http://www.guet.edu.cn:指定端口号\" target=\"_blank\" rel=\"noopener\">www.guet.edu.cn:指定端口号</a></p>\n<p><strong>User-Agent</strong></p>\n<p>我们上网登陆论坛的时候，往往会看到一些欢迎信息，其中列出了你的操作系统的名称和版本，你所使用的浏览器的名称和版本，这往往让很多人感到很神奇，实际上，服务器应用程序就是从User-Agent这个请求报头域中获取到这些信息。User-Agent请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。不过，这个报头域不是必需的，如果我们自己编写一个浏览器，不使用User-Agent请求报头域，那么服务器端就无法得知我们的信息了。</p>\n<p>#####3、响应报头</p>\n<p>响应报头允许服务器传递不能放在状态行中的附加响应信息，以及关于服务器的信息和对Request-URI所标识的资源进行下一步访问的信息。<br>常用的响应报头</p>\n<p><strong>Location</strong></p>\n<p>Location响应报头域用于重定向接受者到一个新的位置。Location响应报头域常用在更换域名的时候。</p>\n<p><strong>Server</strong></p>\n<p>Server响应报头域包含了服务器用来处理请求的软件信息。与User-Agent请求报头域是相对应的。下面是<br>Server响应报头域的一个例子：<br>Server：Apache-Coyote/1.1</p>\n<p><strong>WWW-Authenticate</strong></p>\n<p>WWW-Authenticate响应报头域必须被包含在401（未授权的）响应消息中，客户端收到401响应消息时候，并发送Authorization报头域请求服务器对其进行验证时，服务端响应报头就包含该报头域。<br>eg：WWW-Authenticate:Basic realm=”Basic Auth Test!” //可以看出服务器对请求资源采用的是基本验证机制</p>\n<p>#####4、实体报头</p>\n<p>请求和响应消息都可以传送一个实体。一个实体由实体报头域和实体正文组成，但并不是说实体报头域和实体正文要在一起发送，可以只发送实体报头域。实体报头定义了关于实体正文（eg：有无实体正文）和请求所标识的资源的元信息。<br>常用的实体报头</p>\n<p><strong>Content-Encoding</strong></p>\n<p>Content- Encoding实体报头域被用作媒体类型的修饰符，它的值指示了已经被应用到实体正文的附加内容的编码，因而要获得Content-Type报头域中所引用的媒体类型，必须采用相应的解码机制。Content-Encoding这样用于记录文档的压缩方法，eg：Content- Encoding：gzip</p>\n<p><strong>Content-Language</strong></p>\n<p>Content-Language实体报头域描述了资源所用的自然语言。没有设置该域则认为实体内容将提供给所有的语言阅读<br>者。eg：Content-Language:da</p>\n<p><strong>Content-Length</strong></p>\n<p>Content-Length实体报头域用于指明实体正文的长度，以字节方式存储的十进制数字来表示。</p>\n<p><strong>Content-Type</strong></p>\n<p>Content-Type实体报头域用语指明发送给接收者的实体正文的媒体类型。eg：<br>Content-Type:text/html;charset=ISO-8859-1<br>Content-Type:text/html;charset=GB2312</p>\n<p><strong>Last-Modified</strong></p>\n<p>Last-Modified实体报头域用于指示资源的最后修改日期和时间。</p>\n<p><strong>Expires</strong></p>\n<p>Expires 实体报头域给出响应过期的日期和时间。为了让代理服务器或浏览器在一段时间以后更新缓存中(再次访问曾访问过的页面时，直接从缓存中加载，缩短响应时间和降低服务器负载)的页面，我们可以使用Expires实体报头域指定页面过期的时间。eg：Expires：Thu，15 Sep 2006 16:23:12 GMT<br>HTTP1.1的客户端和缓存必须将其他非法的日期格式（包括0）看作已经过期。eg：为了让浏览器不要缓存页面，我们也可以利用Expires实体报头域，设置为0，jsp中程序如下：response.setDateHeader(“Expires”,”0”);</p>\n"},{"title":"windows下的git bash中添加tree","_content":"\n# 下载tree\n[下载地址](https://sourceforge.net/projects/gnuwin32/)\n请下载 Binaries 版本。\n\n# 添加tree\n将下载文件的 bin/ 目录下的 tree.exe 复制到 c:/program files/git/usr/bin 目录中。\n\n[原文地址](https://blog.csdn.net/mint_ying/article/details/82793911)\n\n# 例子\n```\ntree -I node_modules -L 2 //忽略node_modules后只显示2级目录\n```","source":"_posts/windows下的git-bash中添加tree.md","raw":"title: windows下的git bash中添加tree\ntags: [git]\ncategories: 前端\n---\n\n# 下载tree\n[下载地址](https://sourceforge.net/projects/gnuwin32/)\n请下载 Binaries 版本。\n\n# 添加tree\n将下载文件的 bin/ 目录下的 tree.exe 复制到 c:/program files/git/usr/bin 目录中。\n\n[原文地址](https://blog.csdn.net/mint_ying/article/details/82793911)\n\n# 例子\n```\ntree -I node_modules -L 2 //忽略node_modules后只显示2级目录\n```","slug":"windows下的git-bash中添加tree","published":1,"date":"2020-09-04T02:56:58.996Z","updated":"2020-09-04T02:56:58.996Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckep5vtck0005l4i9zwld8f72","content":"<h1 id=\"下载tree\"><a href=\"#下载tree\" class=\"headerlink\" title=\"下载tree\"></a>下载tree</h1><p><a href=\"https://sourceforge.net/projects/gnuwin32/\" target=\"_blank\" rel=\"noopener\">下载地址</a><br>请下载 Binaries 版本。</p>\n<h1 id=\"添加tree\"><a href=\"#添加tree\" class=\"headerlink\" title=\"添加tree\"></a>添加tree</h1><p>将下载文件的 bin/ 目录下的 tree.exe 复制到 c:/program files/git/usr/bin 目录中。</p>\n<p><a href=\"https://blog.csdn.net/mint_ying/article/details/82793911\" target=\"_blank\" rel=\"noopener\">原文地址</a></p>\n<h1 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h1><figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">tree</span> -I node_modules -L <span class=\"number\">2</span> <span class=\"comment\">//忽略node_modules后只显示2级目录</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"下载tree\"><a href=\"#下载tree\" class=\"headerlink\" title=\"下载tree\"></a>下载tree</h1><p><a href=\"https://sourceforge.net/projects/gnuwin32/\" target=\"_blank\" rel=\"noopener\">下载地址</a><br>请下载 Binaries 版本。</p>\n<h1 id=\"添加tree\"><a href=\"#添加tree\" class=\"headerlink\" title=\"添加tree\"></a>添加tree</h1><p>将下载文件的 bin/ 目录下的 tree.exe 复制到 c:/program files/git/usr/bin 目录中。</p>\n<p><a href=\"https://blog.csdn.net/mint_ying/article/details/82793911\" target=\"_blank\" rel=\"noopener\">原文地址</a></p>\n<h1 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h1><figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">tree</span> -I node_modules -L <span class=\"number\">2</span> <span class=\"comment\">//忽略node_modules后只显示2级目录</span></span><br></pre></td></tr></table></figure>"},{"title":"windows自定义bash的alias","_content":"\n### 缘由\n又来装逼了，看到同事的mac上可以简单敲gco就能切换分支，而自己在git bash里只能用敲`git checkout`， 麻烦！\n\n### 方法\n其实git bash支持自定义alias，如下两种方法 ：\n> 1、在C盘用户名下的.gitconfig里可以输入[alias] co = checkout\n> 2、用命令 `git config --global alias.co checkout`\n\n但这两种方法实际用的时候只能这样省略：`git co`， 前面还有git没有简写。  \n\n### bash 方法\n后来想到git bash也是bash，于是用命令`alias gs=\"git status\"` 终于可以实现，莫急，窗口关闭后再打开又没了，需要重新设置。麻烦！\n\n### 改进\n于是google了一下搜到可以在c盘自己用户名下建一个.bashrc文件专门用于存放自己的alias，类似：```\nalias gs=\"git status\"    \nalias gco=\"git checkout\"  \nalias gada=\"git add --all\"```\n\n然后还需在旁边加一个 .bash_profile 文件,文件中写入内容 `source ~/.bashrc`，\n重开窗口输入`gco master` 成功切换到master分支！","source":"_posts/windows自定义bash的alias.md","raw":"title: windows自定义bash的alias\ntags: [bash,git]\n---\n\n### 缘由\n又来装逼了，看到同事的mac上可以简单敲gco就能切换分支，而自己在git bash里只能用敲`git checkout`， 麻烦！\n\n### 方法\n其实git bash支持自定义alias，如下两种方法 ：\n> 1、在C盘用户名下的.gitconfig里可以输入[alias] co = checkout\n> 2、用命令 `git config --global alias.co checkout`\n\n但这两种方法实际用的时候只能这样省略：`git co`， 前面还有git没有简写。  \n\n### bash 方法\n后来想到git bash也是bash，于是用命令`alias gs=\"git status\"` 终于可以实现，莫急，窗口关闭后再打开又没了，需要重新设置。麻烦！\n\n### 改进\n于是google了一下搜到可以在c盘自己用户名下建一个.bashrc文件专门用于存放自己的alias，类似：```\nalias gs=\"git status\"    \nalias gco=\"git checkout\"  \nalias gada=\"git add --all\"```\n\n然后还需在旁边加一个 .bash_profile 文件,文件中写入内容 `source ~/.bashrc`，\n重开窗口输入`gco master` 成功切换到master分支！","slug":"windows自定义bash的alias","published":1,"date":"2020-09-04T07:42:29.334Z","updated":"2020-09-04T07:42:29.334Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckep5vtcl0006l4i9w2t8nuvw","content":"<h3 id=\"缘由\"><a href=\"#缘由\" class=\"headerlink\" title=\"缘由\"></a>缘由</h3><p>又来装逼了，看到同事的mac上可以简单敲gco就能切换分支，而自己在git bash里只能用敲<code>git checkout</code>， 麻烦！</p>\n<h3 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h3><p>其实git bash支持自定义alias，如下两种方法 ：</p>\n<blockquote>\n<p>1、在C盘用户名下的.gitconfig里可以输入[alias] co = checkout<br>2、用命令 <code>git config --global alias.co checkout</code></p>\n</blockquote>\n<p>但这两种方法实际用的时候只能这样省略：<code>git co</code>， 前面还有git没有简写。  </p>\n<h3 id=\"bash-方法\"><a href=\"#bash-方法\" class=\"headerlink\" title=\"bash 方法\"></a>bash 方法</h3><p>后来想到git bash也是bash，于是用命令<code>alias gs=&quot;git status&quot;</code> 终于可以实现，莫急，窗口关闭后再打开又没了，需要重新设置。麻烦！</p>\n<h3 id=\"改进\"><a href=\"#改进\" class=\"headerlink\" title=\"改进\"></a>改进</h3><p>于是google了一下搜到可以在c盘自己用户名下建一个.bashrc文件专门用于存放自己的alias，类似：<figure class=\"highlight monkey\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">alias</span> <span class=\"title\">gs</span>=<span class=\"string\">\"git status\"</span>    </span><br><span class=\"line\"><span class=\"keyword\">alias</span> <span class=\"title\">gco</span>=<span class=\"string\">\"git checkout\"</span>  </span><br><span class=\"line\"><span class=\"keyword\">alias</span> <span class=\"title\">gada</span>=<span class=\"string\">\"git add --all\"</span></span><br></pre></td></tr></table></figure></p>\n<p>然后还需在旁边加一个 .bash_profile 文件,文件中写入内容 <code>source ~/.bashrc</code>，<br>重开窗口输入<code>gco master</code> 成功切换到master分支！</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"缘由\"><a href=\"#缘由\" class=\"headerlink\" title=\"缘由\"></a>缘由</h3><p>又来装逼了，看到同事的mac上可以简单敲gco就能切换分支，而自己在git bash里只能用敲<code>git checkout</code>， 麻烦！</p>\n<h3 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h3><p>其实git bash支持自定义alias，如下两种方法 ：</p>\n<blockquote>\n<p>1、在C盘用户名下的.gitconfig里可以输入[alias] co = checkout<br>2、用命令 <code>git config --global alias.co checkout</code></p>\n</blockquote>\n<p>但这两种方法实际用的时候只能这样省略：<code>git co</code>， 前面还有git没有简写。  </p>\n<h3 id=\"bash-方法\"><a href=\"#bash-方法\" class=\"headerlink\" title=\"bash 方法\"></a>bash 方法</h3><p>后来想到git bash也是bash，于是用命令<code>alias gs=&quot;git status&quot;</code> 终于可以实现，莫急，窗口关闭后再打开又没了，需要重新设置。麻烦！</p>\n<h3 id=\"改进\"><a href=\"#改进\" class=\"headerlink\" title=\"改进\"></a>改进</h3><p>于是google了一下搜到可以在c盘自己用户名下建一个.bashrc文件专门用于存放自己的alias，类似：<figure class=\"highlight monkey\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">alias</span> <span class=\"title\">gs</span>=<span class=\"string\">\"git status\"</span>    </span><br><span class=\"line\"><span class=\"keyword\">alias</span> <span class=\"title\">gco</span>=<span class=\"string\">\"git checkout\"</span>  </span><br><span class=\"line\"><span class=\"keyword\">alias</span> <span class=\"title\">gada</span>=<span class=\"string\">\"git add --all\"</span></span><br></pre></td></tr></table></figure></p>\n<p>然后还需在旁边加一个 .bash_profile 文件,文件中写入内容 <code>source ~/.bashrc</code>，<br>重开窗口输入<code>gco master</code> 成功切换到master分支！</p>\n"},{"title":"自定义起止位置的canvas动画百分比","_content":"\n\n\n## 说明\n一个简单的用canvas画的可自定义颜色和起止位置的动画百分比\n\n<b class=\"clickme\" style=\"cursor: pointer;vertical-align: top;color: blue;\">-->先看效果<--</b><canvas width=\"190\" height=\"170\" class=\"aaa\"></canvas><canvas width=\"190\" height=\"170\" class=\"bbb\"></canvas><canvas width=\"190\" height=\"170\" class=\"ccc\"></canvas>\n<script src=\"/vendors/jquery/index.js\"></script>\n<script>\n    \n  // call function\n    $('.clickme').click(function(){\n        function PercentageAnimation(element, options) {\n    var canvas = $(element),\n        cWidth = canvas[0].width,\n        cHeight = canvas[0].height;\n    this.options = $.extend({}, $.fn.percentageAnimation.defaults, options);\n    this.canvas = canvas;\n    this.cWidth = canvas[0].width;\n    this.cHeight = canvas[0].height;\n    this.init();\n}\nPercentageAnimation.prototype = {\n    init: function() {\n        var drawingStaff,\n            num,\n            endArc,\n            arcIncrements = 0,\n            difference = this.options.roundStartDegree - this.options.roundEndDegree,\n            actureDegree = difference > 0 ? 360 - difference : Math.abs(difference),\n            that = this,\n            cxt = this.canvas[0].getContext('2d');\n        endArc = this.options.percentage * actureDegree * Math.PI / 180;\n        drawingStaff = setInterval(function() {\n            arcIncrements += Math.PI / 180;\n            that.drawCanvasStaff(cxt, arcIncrements, actureDegree);\n            if (arcIncrements > endArc) {\n                clearInterval(drawingStaff);\n            };\n        }, this.options.speed)\n    },\n    drawCanvasStaff: function(cxt, arcEndStaff, actureDegree) {\n        var text,\n            textWidth;\n        this.drawCanvasRound(cxt, this.options.baseColor, this.options.roundStartDegree * Math.PI / 180, this.options.roundEndDegree * Math.PI / 180);\n\n        // draw cover round\n        cxt.beginPath();\n        cxt.strokeStyle = this.options.coverColor;\n        cxt.lineWidth = this.options.lineWidth;\n        cxt.lineCap = this.options.shape;\n        cxt.arc(this.cWidth / 2, this.cHeight / 2, this.options.radius, this.options.coverStartDegree * Math.PI / 180, arcEndStaff - (actureDegree - this.options.roundEndDegree) * Math.PI / 180, false);\n        cxt.stroke();\n\n        // draw text\n        cxt.fillStyle = this.options.coverColor;\n        cxt.font = this.options.numberFont;\n        text = Math.floor(arcEndStaff / (actureDegree * Math.PI / 180) * 100);\n        textWidth = cxt.measureText(text).width;\n        cxt.fillText(text, this.cWidth / 2 - textWidth / 2, this.cHeight / 2 + 20);\n        cxt.font = this.options.subFont;\n        cxt.fillStyle = '#ccc';\n        cxt.fillText(this.options.subtitle, this.cWidth / 2 + textWidth / 2, this.cHeight / 2 + 20);\n\n    },\n    // draw basic round\n    drawCanvasRound: function(cxt, color, sAngle, eAngle) {\n        cxt.clearRect(0, 0, this.cWidth, this.cHeight);\n\n        cxt.beginPath();\n        cxt.strokeStyle = color;\n        cxt.lineWidth = this.options.lineWidth;\n        cxt.arc(this.cWidth / 2, this.cHeight / 2, this.options.radius, sAngle, eAngle, false);\n        cxt.stroke();\n    }\n}\n$.fn.percentageAnimation = function(options) {\n    return this.each(function() {\n        new PercentageAnimation(this, options)\n    });\n}\n$.fn.percentageAnimation.defaults = {\n    baseColor: '#e1e1e1',\n    coverColor: '#e45050',\n    lineWidth: 6,\n    percentage: 0.8,\n    roundStartDegree: 0,\n    roundEndDegree: 360,\n    coverStartDegree: 0,\n    radius: 80,\n    speed: 10, //the more the slower\n    shape: 'round', //square\\butt\\round\n    subtitle: '分',\n    numberFont: '60px Microsoft YaHei',\n    subFont: '18px PT Sans'\n}\n        $('.aaa').percentageAnimation();\n        $('.bbb').percentageAnimation({\n            percentage: 0.5,\n            roundStartDegree : 135,\n            roundEndDegree : 45,\n            coverStartDegree : 135,\n            numberFont : '54px songti',\n            coverColor : 'green'\n        })\n        $('.ccc').percentageAnimation({\n            percentage: 0.2,\n            subtitle : '%',\n            shape : 'square',\n            roundStartDegree : 90,\n            roundEndDegree : 270,\n            coverStartDegree : 90,\n            coverColor : 'blue',\n            speed: 50,\n            lineWidth: 10\n        })\n    })\n</script>\n\n\n## 配置\n| 参数        | 默认值   |  说明  |\n| --------   | -----:  | ----:  |\n| baseColor     | #e1e1e1 |   底部圆颜色     |\n| coverColor        |   #45050   |   动画圆颜色   |\n| lineWidth        |    6    |  圆宽  |\n| percentage        |    0.8    |  百分比  |\n| roundStartDegree        |    0    |  底部圆结束度数  |\n| roundEndDegree        |    360    |  底部圆结束度数  |\n| coverStartDegree        |    0    |  动画圆开始度数  |\n| radius        |    80    |  半径  |\n| speed        |    10    |  动画速度  |\n| shape        |    round    |  动画圆边角形状  |\n| subtitle        |    分    |  辅助文字  |\n| numberFont        |    60px Microsoft YaHei    |  数字字体  |\n| subFont        |    18px PT Sans    |  辅助字体  |\n\n## 计算度数和弧度\n知道起止度数，计算实际静止圆的度数：\n```\ndifference = this.options.roundStartDegree - this.options.roundEndDegree,\nactureDegree = difference > 0 ? 360 - difference : Math.abs(difference),\n```\n知道实际静止圆的度数和百分比算出动画圆的结束弧度\n```\nendArc = this.options.percentage * actureDegree * Math.PI / 180;\n```\n\n## 依赖  \njQuery\n\n## 调用\n例如：\n```\n$('.aaa').percentageAnimation({  \n    speed: 20  \n});\n```\n\n## Git地址\n[percentageAnimation项目地址](https://github.com/nameit/percentageAnimation)","source":"_posts/一个canvas画的可自定义颜色和起止位置的动画百分比.md","raw":"title: 自定义起止位置的canvas动画百分比\ntags: [canvas,百分比]\n---\n\n\n\n## 说明\n一个简单的用canvas画的可自定义颜色和起止位置的动画百分比\n\n<b class=\"clickme\" style=\"cursor: pointer;vertical-align: top;color: blue;\">-->先看效果<--</b><canvas width=\"190\" height=\"170\" class=\"aaa\"></canvas><canvas width=\"190\" height=\"170\" class=\"bbb\"></canvas><canvas width=\"190\" height=\"170\" class=\"ccc\"></canvas>\n<script src=\"/vendors/jquery/index.js\"></script>\n<script>\n    \n  // call function\n    $('.clickme').click(function(){\n        function PercentageAnimation(element, options) {\n    var canvas = $(element),\n        cWidth = canvas[0].width,\n        cHeight = canvas[0].height;\n    this.options = $.extend({}, $.fn.percentageAnimation.defaults, options);\n    this.canvas = canvas;\n    this.cWidth = canvas[0].width;\n    this.cHeight = canvas[0].height;\n    this.init();\n}\nPercentageAnimation.prototype = {\n    init: function() {\n        var drawingStaff,\n            num,\n            endArc,\n            arcIncrements = 0,\n            difference = this.options.roundStartDegree - this.options.roundEndDegree,\n            actureDegree = difference > 0 ? 360 - difference : Math.abs(difference),\n            that = this,\n            cxt = this.canvas[0].getContext('2d');\n        endArc = this.options.percentage * actureDegree * Math.PI / 180;\n        drawingStaff = setInterval(function() {\n            arcIncrements += Math.PI / 180;\n            that.drawCanvasStaff(cxt, arcIncrements, actureDegree);\n            if (arcIncrements > endArc) {\n                clearInterval(drawingStaff);\n            };\n        }, this.options.speed)\n    },\n    drawCanvasStaff: function(cxt, arcEndStaff, actureDegree) {\n        var text,\n            textWidth;\n        this.drawCanvasRound(cxt, this.options.baseColor, this.options.roundStartDegree * Math.PI / 180, this.options.roundEndDegree * Math.PI / 180);\n\n        // draw cover round\n        cxt.beginPath();\n        cxt.strokeStyle = this.options.coverColor;\n        cxt.lineWidth = this.options.lineWidth;\n        cxt.lineCap = this.options.shape;\n        cxt.arc(this.cWidth / 2, this.cHeight / 2, this.options.radius, this.options.coverStartDegree * Math.PI / 180, arcEndStaff - (actureDegree - this.options.roundEndDegree) * Math.PI / 180, false);\n        cxt.stroke();\n\n        // draw text\n        cxt.fillStyle = this.options.coverColor;\n        cxt.font = this.options.numberFont;\n        text = Math.floor(arcEndStaff / (actureDegree * Math.PI / 180) * 100);\n        textWidth = cxt.measureText(text).width;\n        cxt.fillText(text, this.cWidth / 2 - textWidth / 2, this.cHeight / 2 + 20);\n        cxt.font = this.options.subFont;\n        cxt.fillStyle = '#ccc';\n        cxt.fillText(this.options.subtitle, this.cWidth / 2 + textWidth / 2, this.cHeight / 2 + 20);\n\n    },\n    // draw basic round\n    drawCanvasRound: function(cxt, color, sAngle, eAngle) {\n        cxt.clearRect(0, 0, this.cWidth, this.cHeight);\n\n        cxt.beginPath();\n        cxt.strokeStyle = color;\n        cxt.lineWidth = this.options.lineWidth;\n        cxt.arc(this.cWidth / 2, this.cHeight / 2, this.options.radius, sAngle, eAngle, false);\n        cxt.stroke();\n    }\n}\n$.fn.percentageAnimation = function(options) {\n    return this.each(function() {\n        new PercentageAnimation(this, options)\n    });\n}\n$.fn.percentageAnimation.defaults = {\n    baseColor: '#e1e1e1',\n    coverColor: '#e45050',\n    lineWidth: 6,\n    percentage: 0.8,\n    roundStartDegree: 0,\n    roundEndDegree: 360,\n    coverStartDegree: 0,\n    radius: 80,\n    speed: 10, //the more the slower\n    shape: 'round', //square\\butt\\round\n    subtitle: '分',\n    numberFont: '60px Microsoft YaHei',\n    subFont: '18px PT Sans'\n}\n        $('.aaa').percentageAnimation();\n        $('.bbb').percentageAnimation({\n            percentage: 0.5,\n            roundStartDegree : 135,\n            roundEndDegree : 45,\n            coverStartDegree : 135,\n            numberFont : '54px songti',\n            coverColor : 'green'\n        })\n        $('.ccc').percentageAnimation({\n            percentage: 0.2,\n            subtitle : '%',\n            shape : 'square',\n            roundStartDegree : 90,\n            roundEndDegree : 270,\n            coverStartDegree : 90,\n            coverColor : 'blue',\n            speed: 50,\n            lineWidth: 10\n        })\n    })\n</script>\n\n\n## 配置\n| 参数        | 默认值   |  说明  |\n| --------   | -----:  | ----:  |\n| baseColor     | #e1e1e1 |   底部圆颜色     |\n| coverColor        |   #45050   |   动画圆颜色   |\n| lineWidth        |    6    |  圆宽  |\n| percentage        |    0.8    |  百分比  |\n| roundStartDegree        |    0    |  底部圆结束度数  |\n| roundEndDegree        |    360    |  底部圆结束度数  |\n| coverStartDegree        |    0    |  动画圆开始度数  |\n| radius        |    80    |  半径  |\n| speed        |    10    |  动画速度  |\n| shape        |    round    |  动画圆边角形状  |\n| subtitle        |    分    |  辅助文字  |\n| numberFont        |    60px Microsoft YaHei    |  数字字体  |\n| subFont        |    18px PT Sans    |  辅助字体  |\n\n## 计算度数和弧度\n知道起止度数，计算实际静止圆的度数：\n```\ndifference = this.options.roundStartDegree - this.options.roundEndDegree,\nactureDegree = difference > 0 ? 360 - difference : Math.abs(difference),\n```\n知道实际静止圆的度数和百分比算出动画圆的结束弧度\n```\nendArc = this.options.percentage * actureDegree * Math.PI / 180;\n```\n\n## 依赖  \njQuery\n\n## 调用\n例如：\n```\n$('.aaa').percentageAnimation({  \n    speed: 20  \n});\n```\n\n## Git地址\n[percentageAnimation项目地址](https://github.com/nameit/percentageAnimation)","slug":"一个canvas画的可自定义颜色和起止位置的动画百分比","published":1,"date":"2020-09-04T07:42:29.334Z","updated":"2020-09-04T07:42:29.334Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckep5vtco000al4i962wro7fq","content":"<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>一个简单的用canvas画的可自定义颜色和起止位置的动画百分比</p>\n<p><b class=\"clickme\" style=\"cursor: pointer;vertical-align: top;color: blue;\">–&gt;先看效果&lt;–</b><canvas width=\"190\" height=\"170\" class=\"aaa\"></canvas><canvas width=\"190\" height=\"170\" class=\"bbb\"></canvas><canvas width=\"190\" height=\"170\" class=\"ccc\"></canvas></p>\n<script src=\"/vendors/jquery/index.js\"></script>\n<script>\n\n  // call function\n    $('.clickme').click(function(){\n        function PercentageAnimation(element, options) {\n    var canvas = $(element),\n        cWidth = canvas[0].width,\n        cHeight = canvas[0].height;\n    this.options = $.extend({}, $.fn.percentageAnimation.defaults, options);\n    this.canvas = canvas;\n    this.cWidth = canvas[0].width;\n    this.cHeight = canvas[0].height;\n    this.init();\n}\nPercentageAnimation.prototype = {\n    init: function() {\n        var drawingStaff,\n            num,\n            endArc,\n            arcIncrements = 0,\n            difference = this.options.roundStartDegree - this.options.roundEndDegree,\n            actureDegree = difference > 0 ? 360 - difference : Math.abs(difference),\n            that = this,\n            cxt = this.canvas[0].getContext('2d');\n        endArc = this.options.percentage * actureDegree * Math.PI / 180;\n        drawingStaff = setInterval(function() {\n            arcIncrements += Math.PI / 180;\n            that.drawCanvasStaff(cxt, arcIncrements, actureDegree);\n            if (arcIncrements > endArc) {\n                clearInterval(drawingStaff);\n            };\n        }, this.options.speed)\n    },\n    drawCanvasStaff: function(cxt, arcEndStaff, actureDegree) {\n        var text,\n            textWidth;\n        this.drawCanvasRound(cxt, this.options.baseColor, this.options.roundStartDegree * Math.PI / 180, this.options.roundEndDegree * Math.PI / 180);\n\n        // draw cover round\n        cxt.beginPath();\n        cxt.strokeStyle = this.options.coverColor;\n        cxt.lineWidth = this.options.lineWidth;\n        cxt.lineCap = this.options.shape;\n        cxt.arc(this.cWidth / 2, this.cHeight / 2, this.options.radius, this.options.coverStartDegree * Math.PI / 180, arcEndStaff - (actureDegree - this.options.roundEndDegree) * Math.PI / 180, false);\n        cxt.stroke();\n\n        // draw text\n        cxt.fillStyle = this.options.coverColor;\n        cxt.font = this.options.numberFont;\n        text = Math.floor(arcEndStaff / (actureDegree * Math.PI / 180) * 100);\n        textWidth = cxt.measureText(text).width;\n        cxt.fillText(text, this.cWidth / 2 - textWidth / 2, this.cHeight / 2 + 20);\n        cxt.font = this.options.subFont;\n        cxt.fillStyle = '#ccc';\n        cxt.fillText(this.options.subtitle, this.cWidth / 2 + textWidth / 2, this.cHeight / 2 + 20);\n\n    },\n    // draw basic round\n    drawCanvasRound: function(cxt, color, sAngle, eAngle) {\n        cxt.clearRect(0, 0, this.cWidth, this.cHeight);\n\n        cxt.beginPath();\n        cxt.strokeStyle = color;\n        cxt.lineWidth = this.options.lineWidth;\n        cxt.arc(this.cWidth / 2, this.cHeight / 2, this.options.radius, sAngle, eAngle, false);\n        cxt.stroke();\n    }\n}\n$.fn.percentageAnimation = function(options) {\n    return this.each(function() {\n        new PercentageAnimation(this, options)\n    });\n}\n$.fn.percentageAnimation.defaults = {\n    baseColor: '#e1e1e1',\n    coverColor: '#e45050',\n    lineWidth: 6,\n    percentage: 0.8,\n    roundStartDegree: 0,\n    roundEndDegree: 360,\n    coverStartDegree: 0,\n    radius: 80,\n    speed: 10, //the more the slower\n    shape: 'round', //square\\butt\\round\n    subtitle: '分',\n    numberFont: '60px Microsoft YaHei',\n    subFont: '18px PT Sans'\n}\n        $('.aaa').percentageAnimation();\n        $('.bbb').percentageAnimation({\n            percentage: 0.5,\n            roundStartDegree : 135,\n            roundEndDegree : 45,\n            coverStartDegree : 135,\n            numberFont : '54px songti',\n            coverColor : 'green'\n        })\n        $('.ccc').percentageAnimation({\n            percentage: 0.2,\n            subtitle : '%',\n            shape : 'square',\n            roundStartDegree : 90,\n            roundEndDegree : 270,\n            coverStartDegree : 90,\n            coverColor : 'blue',\n            speed: 50,\n            lineWidth: 10\n        })\n    })\n</script>\n\n\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><table>\n<thead>\n<tr>\n<th>参数</th>\n<th style=\"text-align:right\">默认值</th>\n<th style=\"text-align:right\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>baseColor</td>\n<td style=\"text-align:right\">#e1e1e1</td>\n<td style=\"text-align:right\">底部圆颜色</td>\n</tr>\n<tr>\n<td>coverColor</td>\n<td style=\"text-align:right\">#45050</td>\n<td style=\"text-align:right\">动画圆颜色</td>\n</tr>\n<tr>\n<td>lineWidth</td>\n<td style=\"text-align:right\">6</td>\n<td style=\"text-align:right\">圆宽</td>\n</tr>\n<tr>\n<td>percentage</td>\n<td style=\"text-align:right\">0.8</td>\n<td style=\"text-align:right\">百分比</td>\n</tr>\n<tr>\n<td>roundStartDegree</td>\n<td style=\"text-align:right\">0</td>\n<td style=\"text-align:right\">底部圆结束度数</td>\n</tr>\n<tr>\n<td>roundEndDegree</td>\n<td style=\"text-align:right\">360</td>\n<td style=\"text-align:right\">底部圆结束度数</td>\n</tr>\n<tr>\n<td>coverStartDegree</td>\n<td style=\"text-align:right\">0</td>\n<td style=\"text-align:right\">动画圆开始度数</td>\n</tr>\n<tr>\n<td>radius</td>\n<td style=\"text-align:right\">80</td>\n<td style=\"text-align:right\">半径</td>\n</tr>\n<tr>\n<td>speed</td>\n<td style=\"text-align:right\">10</td>\n<td style=\"text-align:right\">动画速度</td>\n</tr>\n<tr>\n<td>shape</td>\n<td style=\"text-align:right\">round</td>\n<td style=\"text-align:right\">动画圆边角形状</td>\n</tr>\n<tr>\n<td>subtitle</td>\n<td style=\"text-align:right\">分</td>\n<td style=\"text-align:right\">辅助文字</td>\n</tr>\n<tr>\n<td>numberFont</td>\n<td style=\"text-align:right\">60px Microsoft YaHei</td>\n<td style=\"text-align:right\">数字字体</td>\n</tr>\n<tr>\n<td>subFont</td>\n<td style=\"text-align:right\">18px PT Sans</td>\n<td style=\"text-align:right\">辅助字体</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"计算度数和弧度\"><a href=\"#计算度数和弧度\" class=\"headerlink\" title=\"计算度数和弧度\"></a>计算度数和弧度</h2><p>知道起止度数，计算实际静止圆的度数：<br><figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">difference = <span class=\"keyword\">this</span>.<span class=\"keyword\">options</span>.roundStartDegree - <span class=\"keyword\">this</span>.<span class=\"keyword\">options</span>.roundEndDegree,</span><br><span class=\"line\">actureDegree = difference &gt; <span class=\"number\">0</span> ? <span class=\"number\">360</span> - difference : Math.<span class=\"keyword\">abs</span>(difference),</span><br></pre></td></tr></table></figure></p>\n<p>知道实际静止圆的度数和百分比算出动画圆的结束弧度<br><figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">endArc</span> = this.options.percentage * actureDegree * Math.PI / <span class=\"number\">180</span><span class=\"comment\">;</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"依赖\"><a href=\"#依赖\" class=\"headerlink\" title=\"依赖\"></a>依赖</h2><p>jQuery</p>\n<h2 id=\"调用\"><a href=\"#调用\" class=\"headerlink\" title=\"调用\"></a>调用</h2><p>例如：<br><figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$(</span><span class=\"string\">'.aaa'</span>).percentageAnimation(&#123;  </span><br><span class=\"line\">    <span class=\"symbol\">speed:</span> <span class=\"number\">20</span>  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Git地址\"><a href=\"#Git地址\" class=\"headerlink\" title=\"Git地址\"></a>Git地址</h2><p><a href=\"https://github.com/nameit/percentageAnimation\" target=\"_blank\" rel=\"noopener\">percentageAnimation项目地址</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>一个简单的用canvas画的可自定义颜色和起止位置的动画百分比</p>\n<p><b class=\"clickme\" style=\"cursor: pointer;vertical-align: top;color: blue;\">–&gt;先看效果&lt;–</b><canvas width=\"190\" height=\"170\" class=\"aaa\"></canvas><canvas width=\"190\" height=\"170\" class=\"bbb\"></canvas><canvas width=\"190\" height=\"170\" class=\"ccc\"></canvas></p>\n<script src=\"/vendors/jquery/index.js\"></script>\n<script>\n\n  // call function\n    $('.clickme').click(function(){\n        function PercentageAnimation(element, options) {\n    var canvas = $(element),\n        cWidth = canvas[0].width,\n        cHeight = canvas[0].height;\n    this.options = $.extend({}, $.fn.percentageAnimation.defaults, options);\n    this.canvas = canvas;\n    this.cWidth = canvas[0].width;\n    this.cHeight = canvas[0].height;\n    this.init();\n}\nPercentageAnimation.prototype = {\n    init: function() {\n        var drawingStaff,\n            num,\n            endArc,\n            arcIncrements = 0,\n            difference = this.options.roundStartDegree - this.options.roundEndDegree,\n            actureDegree = difference > 0 ? 360 - difference : Math.abs(difference),\n            that = this,\n            cxt = this.canvas[0].getContext('2d');\n        endArc = this.options.percentage * actureDegree * Math.PI / 180;\n        drawingStaff = setInterval(function() {\n            arcIncrements += Math.PI / 180;\n            that.drawCanvasStaff(cxt, arcIncrements, actureDegree);\n            if (arcIncrements > endArc) {\n                clearInterval(drawingStaff);\n            };\n        }, this.options.speed)\n    },\n    drawCanvasStaff: function(cxt, arcEndStaff, actureDegree) {\n        var text,\n            textWidth;\n        this.drawCanvasRound(cxt, this.options.baseColor, this.options.roundStartDegree * Math.PI / 180, this.options.roundEndDegree * Math.PI / 180);\n\n        // draw cover round\n        cxt.beginPath();\n        cxt.strokeStyle = this.options.coverColor;\n        cxt.lineWidth = this.options.lineWidth;\n        cxt.lineCap = this.options.shape;\n        cxt.arc(this.cWidth / 2, this.cHeight / 2, this.options.radius, this.options.coverStartDegree * Math.PI / 180, arcEndStaff - (actureDegree - this.options.roundEndDegree) * Math.PI / 180, false);\n        cxt.stroke();\n\n        // draw text\n        cxt.fillStyle = this.options.coverColor;\n        cxt.font = this.options.numberFont;\n        text = Math.floor(arcEndStaff / (actureDegree * Math.PI / 180) * 100);\n        textWidth = cxt.measureText(text).width;\n        cxt.fillText(text, this.cWidth / 2 - textWidth / 2, this.cHeight / 2 + 20);\n        cxt.font = this.options.subFont;\n        cxt.fillStyle = '#ccc';\n        cxt.fillText(this.options.subtitle, this.cWidth / 2 + textWidth / 2, this.cHeight / 2 + 20);\n\n    },\n    // draw basic round\n    drawCanvasRound: function(cxt, color, sAngle, eAngle) {\n        cxt.clearRect(0, 0, this.cWidth, this.cHeight);\n\n        cxt.beginPath();\n        cxt.strokeStyle = color;\n        cxt.lineWidth = this.options.lineWidth;\n        cxt.arc(this.cWidth / 2, this.cHeight / 2, this.options.radius, sAngle, eAngle, false);\n        cxt.stroke();\n    }\n}\n$.fn.percentageAnimation = function(options) {\n    return this.each(function() {\n        new PercentageAnimation(this, options)\n    });\n}\n$.fn.percentageAnimation.defaults = {\n    baseColor: '#e1e1e1',\n    coverColor: '#e45050',\n    lineWidth: 6,\n    percentage: 0.8,\n    roundStartDegree: 0,\n    roundEndDegree: 360,\n    coverStartDegree: 0,\n    radius: 80,\n    speed: 10, //the more the slower\n    shape: 'round', //square\\butt\\round\n    subtitle: '分',\n    numberFont: '60px Microsoft YaHei',\n    subFont: '18px PT Sans'\n}\n        $('.aaa').percentageAnimation();\n        $('.bbb').percentageAnimation({\n            percentage: 0.5,\n            roundStartDegree : 135,\n            roundEndDegree : 45,\n            coverStartDegree : 135,\n            numberFont : '54px songti',\n            coverColor : 'green'\n        })\n        $('.ccc').percentageAnimation({\n            percentage: 0.2,\n            subtitle : '%',\n            shape : 'square',\n            roundStartDegree : 90,\n            roundEndDegree : 270,\n            coverStartDegree : 90,\n            coverColor : 'blue',\n            speed: 50,\n            lineWidth: 10\n        })\n    })\n</script>\n\n\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><table>\n<thead>\n<tr>\n<th>参数</th>\n<th style=\"text-align:right\">默认值</th>\n<th style=\"text-align:right\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>baseColor</td>\n<td style=\"text-align:right\">#e1e1e1</td>\n<td style=\"text-align:right\">底部圆颜色</td>\n</tr>\n<tr>\n<td>coverColor</td>\n<td style=\"text-align:right\">#45050</td>\n<td style=\"text-align:right\">动画圆颜色</td>\n</tr>\n<tr>\n<td>lineWidth</td>\n<td style=\"text-align:right\">6</td>\n<td style=\"text-align:right\">圆宽</td>\n</tr>\n<tr>\n<td>percentage</td>\n<td style=\"text-align:right\">0.8</td>\n<td style=\"text-align:right\">百分比</td>\n</tr>\n<tr>\n<td>roundStartDegree</td>\n<td style=\"text-align:right\">0</td>\n<td style=\"text-align:right\">底部圆结束度数</td>\n</tr>\n<tr>\n<td>roundEndDegree</td>\n<td style=\"text-align:right\">360</td>\n<td style=\"text-align:right\">底部圆结束度数</td>\n</tr>\n<tr>\n<td>coverStartDegree</td>\n<td style=\"text-align:right\">0</td>\n<td style=\"text-align:right\">动画圆开始度数</td>\n</tr>\n<tr>\n<td>radius</td>\n<td style=\"text-align:right\">80</td>\n<td style=\"text-align:right\">半径</td>\n</tr>\n<tr>\n<td>speed</td>\n<td style=\"text-align:right\">10</td>\n<td style=\"text-align:right\">动画速度</td>\n</tr>\n<tr>\n<td>shape</td>\n<td style=\"text-align:right\">round</td>\n<td style=\"text-align:right\">动画圆边角形状</td>\n</tr>\n<tr>\n<td>subtitle</td>\n<td style=\"text-align:right\">分</td>\n<td style=\"text-align:right\">辅助文字</td>\n</tr>\n<tr>\n<td>numberFont</td>\n<td style=\"text-align:right\">60px Microsoft YaHei</td>\n<td style=\"text-align:right\">数字字体</td>\n</tr>\n<tr>\n<td>subFont</td>\n<td style=\"text-align:right\">18px PT Sans</td>\n<td style=\"text-align:right\">辅助字体</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"计算度数和弧度\"><a href=\"#计算度数和弧度\" class=\"headerlink\" title=\"计算度数和弧度\"></a>计算度数和弧度</h2><p>知道起止度数，计算实际静止圆的度数：<br><figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">difference = <span class=\"keyword\">this</span>.<span class=\"keyword\">options</span>.roundStartDegree - <span class=\"keyword\">this</span>.<span class=\"keyword\">options</span>.roundEndDegree,</span><br><span class=\"line\">actureDegree = difference &gt; <span class=\"number\">0</span> ? <span class=\"number\">360</span> - difference : Math.<span class=\"keyword\">abs</span>(difference),</span><br></pre></td></tr></table></figure></p>\n<p>知道实际静止圆的度数和百分比算出动画圆的结束弧度<br><figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">endArc</span> = this.options.percentage * actureDegree * Math.PI / <span class=\"number\">180</span><span class=\"comment\">;</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"依赖\"><a href=\"#依赖\" class=\"headerlink\" title=\"依赖\"></a>依赖</h2><p>jQuery</p>\n<h2 id=\"调用\"><a href=\"#调用\" class=\"headerlink\" title=\"调用\"></a>调用</h2><p>例如：<br><figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$(</span><span class=\"string\">'.aaa'</span>).percentageAnimation(&#123;  </span><br><span class=\"line\">    <span class=\"symbol\">speed:</span> <span class=\"number\">20</span>  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Git地址\"><a href=\"#Git地址\" class=\"headerlink\" title=\"Git地址\"></a>Git地址</h2><p><a href=\"https://github.com/nameit/percentageAnimation\" target=\"_blank\" rel=\"noopener\">percentageAnimation项目地址</a></p>\n"},{"title":"利用 Expres+jade+stylus+nodemon+browserSync 构建高效前端环境","date":"2016-05-27T08:25:51.000Z","_content":"\n# 起因\n随着公司业务的极具增长，赶进度式的开发要求前端人员能更高效的构建自己的开发环境。\n项目跑了很多，但从各方面来看总是不够快。\n\n# 为什么是它们\n跑项目总要起服务，从最初的apache到connect中间件以及现在的browser-sync，browser-sync的实时、快速响应文件的更改并自动刷新页面，移动端还能真机调试是我选择他的原因。\nExpress，本想用它来起服务的，但有了browserSync似乎就多余了，但路由控制和中间件的使用总少不了它，比起之前先生成静态html文件再起服务，express要快不只一点点。\njade，额……目前改名为pug。喜欢其缩进式的表达方式---简洁、清晰，传参和数据导入都有，作为模板元老，管理也够用了，而且express默认的模板引擎也是它。\nstylus,css的预编译器。喜欢他也是因为其简洁缩进式的风格，不需要冒号、分号和括号，好处就是如果你要在缩进式的中间添加一个类名，直接添加即可，不需要再去找对应结束的大括号，而且sass有的功能他几乎都有，当然它也提供了中间件的支持和自带sourcemaps，相对于sass比起来，sytlus更轻巧，对node更有亲和力，对于我这样一个懒前端来说不需要安装ruby之类的外部语言是最好不过了。\n既然采用路由的方式来构建，我们最终能在浏览器端看到文件的改变需要重启app应用，nodemon这个轻量级的自动重启工具就必不可少。\n\n# 项目目录\n```\n.\n├── dist\n│   ├── css\n│   ├── images\n│   ├── js\n│   └── temp\n├── docs       // 项目的相关文档\n├── gulpfile.js  // 运行dist用到的插件\n├── jade\n│   ├── _includes    // 用于include的部分\n│   └── _layout   // 用于继承的模板\n├── package.json  // 依赖包\n├── public    // 静态文件目录\n│   ├── css\n│   ├── images\n│   ├── js\n│   └── temp\n├── README.md\n├── server.js  // 主app入口\n└── stylus\n    ├── _components  // 组件样式\n    ├── _config    // 样式配置\n    └── css       // 主文件\n```\n# 项目注意事项\n\n为了方便配置路由，package.json中引入了glob这个依赖，有了它我们就可以找到并筛选想要的文件，以便我们对路由的统一配置。\n\n最后为了方便开发获取代码，生成dist文件夹推入dist的分支。\n\n","source":"_posts/利用Expres-jade-stylus-nodemon构建前端项目.md","raw":"title: 利用 Expres+jade+stylus+nodemon+browserSync 构建高效前端环境\ndate: 2016-05-27 16:25:51\ntags: [前端环境]\n---\n\n# 起因\n随着公司业务的极具增长，赶进度式的开发要求前端人员能更高效的构建自己的开发环境。\n项目跑了很多，但从各方面来看总是不够快。\n\n# 为什么是它们\n跑项目总要起服务，从最初的apache到connect中间件以及现在的browser-sync，browser-sync的实时、快速响应文件的更改并自动刷新页面，移动端还能真机调试是我选择他的原因。\nExpress，本想用它来起服务的，但有了browserSync似乎就多余了，但路由控制和中间件的使用总少不了它，比起之前先生成静态html文件再起服务，express要快不只一点点。\njade，额……目前改名为pug。喜欢其缩进式的表达方式---简洁、清晰，传参和数据导入都有，作为模板元老，管理也够用了，而且express默认的模板引擎也是它。\nstylus,css的预编译器。喜欢他也是因为其简洁缩进式的风格，不需要冒号、分号和括号，好处就是如果你要在缩进式的中间添加一个类名，直接添加即可，不需要再去找对应结束的大括号，而且sass有的功能他几乎都有，当然它也提供了中间件的支持和自带sourcemaps，相对于sass比起来，sytlus更轻巧，对node更有亲和力，对于我这样一个懒前端来说不需要安装ruby之类的外部语言是最好不过了。\n既然采用路由的方式来构建，我们最终能在浏览器端看到文件的改变需要重启app应用，nodemon这个轻量级的自动重启工具就必不可少。\n\n# 项目目录\n```\n.\n├── dist\n│   ├── css\n│   ├── images\n│   ├── js\n│   └── temp\n├── docs       // 项目的相关文档\n├── gulpfile.js  // 运行dist用到的插件\n├── jade\n│   ├── _includes    // 用于include的部分\n│   └── _layout   // 用于继承的模板\n├── package.json  // 依赖包\n├── public    // 静态文件目录\n│   ├── css\n│   ├── images\n│   ├── js\n│   └── temp\n├── README.md\n├── server.js  // 主app入口\n└── stylus\n    ├── _components  // 组件样式\n    ├── _config    // 样式配置\n    └── css       // 主文件\n```\n# 项目注意事项\n\n为了方便配置路由，package.json中引入了glob这个依赖，有了它我们就可以找到并筛选想要的文件，以便我们对路由的统一配置。\n\n最后为了方便开发获取代码，生成dist文件夹推入dist的分支。\n\n","slug":"利用Expres-jade-stylus-nodemon构建前端项目","published":1,"updated":"2018-05-11T07:48:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckep5vtcp000cl4i9um342snf","content":"<h1 id=\"起因\"><a href=\"#起因\" class=\"headerlink\" title=\"起因\"></a>起因</h1><p>随着公司业务的极具增长，赶进度式的开发要求前端人员能更高效的构建自己的开发环境。<br>项目跑了很多，但从各方面来看总是不够快。</p>\n<h1 id=\"为什么是它们\"><a href=\"#为什么是它们\" class=\"headerlink\" title=\"为什么是它们\"></a>为什么是它们</h1><p>跑项目总要起服务，从最初的apache到connect中间件以及现在的browser-sync，browser-sync的实时、快速响应文件的更改并自动刷新页面，移动端还能真机调试是我选择他的原因。<br>Express，本想用它来起服务的，但有了browserSync似乎就多余了，但路由控制和中间件的使用总少不了它，比起之前先生成静态html文件再起服务，express要快不只一点点。<br>jade，额……目前改名为pug。喜欢其缩进式的表达方式—简洁、清晰，传参和数据导入都有，作为模板元老，管理也够用了，而且express默认的模板引擎也是它。<br>stylus,css的预编译器。喜欢他也是因为其简洁缩进式的风格，不需要冒号、分号和括号，好处就是如果你要在缩进式的中间添加一个类名，直接添加即可，不需要再去找对应结束的大括号，而且sass有的功能他几乎都有，当然它也提供了中间件的支持和自带sourcemaps，相对于sass比起来，sytlus更轻巧，对node更有亲和力，对于我这样一个懒前端来说不需要安装ruby之类的外部语言是最好不过了。<br>既然采用路由的方式来构建，我们最终能在浏览器端看到文件的改变需要重启app应用，nodemon这个轻量级的自动重启工具就必不可少。</p>\n<h1 id=\"项目目录\"><a href=\"#项目目录\" class=\"headerlink\" title=\"项目目录\"></a>项目目录</h1><figure class=\"highlight sqf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── dist</span><br><span class=\"line\">│   ├── css</span><br><span class=\"line\">│   ├── images</span><br><span class=\"line\">│   ├── js</span><br><span class=\"line\">│   └── temp</span><br><span class=\"line\">├── docs       <span class=\"comment\">// 项目的相关文档</span></span><br><span class=\"line\">├── gulpfile.js  <span class=\"comment\">// 运行dist用到的插件</span></span><br><span class=\"line\">├── jade</span><br><span class=\"line\">│   ├── <span class=\"variable\">_includes</span>    <span class=\"comment\">// 用于include的部分</span></span><br><span class=\"line\">│   └── <span class=\"variable\">_layout</span>   <span class=\"comment\">// 用于继承的模板</span></span><br><span class=\"line\">├── package.json  <span class=\"comment\">// 依赖包</span></span><br><span class=\"line\">├── public    <span class=\"comment\">// 静态文件目录</span></span><br><span class=\"line\">│   ├── css</span><br><span class=\"line\">│   ├── images</span><br><span class=\"line\">│   ├── js</span><br><span class=\"line\">│   └── temp</span><br><span class=\"line\">├── README.md</span><br><span class=\"line\">├── server.js  <span class=\"comment\">// 主app入口</span></span><br><span class=\"line\">└── stylus</span><br><span class=\"line\">    ├── <span class=\"variable\">_components</span>  <span class=\"comment\">// 组件样式</span></span><br><span class=\"line\">    ├── <span class=\"variable\">_config</span>    <span class=\"comment\">// 样式配置</span></span><br><span class=\"line\">    └── css       <span class=\"comment\">// 主文件</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"项目注意事项\"><a href=\"#项目注意事项\" class=\"headerlink\" title=\"项目注意事项\"></a>项目注意事项</h1><p>为了方便配置路由，package.json中引入了glob这个依赖，有了它我们就可以找到并筛选想要的文件，以便我们对路由的统一配置。</p>\n<p>最后为了方便开发获取代码，生成dist文件夹推入dist的分支。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"起因\"><a href=\"#起因\" class=\"headerlink\" title=\"起因\"></a>起因</h1><p>随着公司业务的极具增长，赶进度式的开发要求前端人员能更高效的构建自己的开发环境。<br>项目跑了很多，但从各方面来看总是不够快。</p>\n<h1 id=\"为什么是它们\"><a href=\"#为什么是它们\" class=\"headerlink\" title=\"为什么是它们\"></a>为什么是它们</h1><p>跑项目总要起服务，从最初的apache到connect中间件以及现在的browser-sync，browser-sync的实时、快速响应文件的更改并自动刷新页面，移动端还能真机调试是我选择他的原因。<br>Express，本想用它来起服务的，但有了browserSync似乎就多余了，但路由控制和中间件的使用总少不了它，比起之前先生成静态html文件再起服务，express要快不只一点点。<br>jade，额……目前改名为pug。喜欢其缩进式的表达方式—简洁、清晰，传参和数据导入都有，作为模板元老，管理也够用了，而且express默认的模板引擎也是它。<br>stylus,css的预编译器。喜欢他也是因为其简洁缩进式的风格，不需要冒号、分号和括号，好处就是如果你要在缩进式的中间添加一个类名，直接添加即可，不需要再去找对应结束的大括号，而且sass有的功能他几乎都有，当然它也提供了中间件的支持和自带sourcemaps，相对于sass比起来，sytlus更轻巧，对node更有亲和力，对于我这样一个懒前端来说不需要安装ruby之类的外部语言是最好不过了。<br>既然采用路由的方式来构建，我们最终能在浏览器端看到文件的改变需要重启app应用，nodemon这个轻量级的自动重启工具就必不可少。</p>\n<h1 id=\"项目目录\"><a href=\"#项目目录\" class=\"headerlink\" title=\"项目目录\"></a>项目目录</h1><figure class=\"highlight sqf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── dist</span><br><span class=\"line\">│   ├── css</span><br><span class=\"line\">│   ├── images</span><br><span class=\"line\">│   ├── js</span><br><span class=\"line\">│   └── temp</span><br><span class=\"line\">├── docs       <span class=\"comment\">// 项目的相关文档</span></span><br><span class=\"line\">├── gulpfile.js  <span class=\"comment\">// 运行dist用到的插件</span></span><br><span class=\"line\">├── jade</span><br><span class=\"line\">│   ├── <span class=\"variable\">_includes</span>    <span class=\"comment\">// 用于include的部分</span></span><br><span class=\"line\">│   └── <span class=\"variable\">_layout</span>   <span class=\"comment\">// 用于继承的模板</span></span><br><span class=\"line\">├── package.json  <span class=\"comment\">// 依赖包</span></span><br><span class=\"line\">├── public    <span class=\"comment\">// 静态文件目录</span></span><br><span class=\"line\">│   ├── css</span><br><span class=\"line\">│   ├── images</span><br><span class=\"line\">│   ├── js</span><br><span class=\"line\">│   └── temp</span><br><span class=\"line\">├── README.md</span><br><span class=\"line\">├── server.js  <span class=\"comment\">// 主app入口</span></span><br><span class=\"line\">└── stylus</span><br><span class=\"line\">    ├── <span class=\"variable\">_components</span>  <span class=\"comment\">// 组件样式</span></span><br><span class=\"line\">    ├── <span class=\"variable\">_config</span>    <span class=\"comment\">// 样式配置</span></span><br><span class=\"line\">    └── css       <span class=\"comment\">// 主文件</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"项目注意事项\"><a href=\"#项目注意事项\" class=\"headerlink\" title=\"项目注意事项\"></a>项目注意事项</h1><p>为了方便配置路由，package.json中引入了glob这个依赖，有了它我们就可以找到并筛选想要的文件，以便我们对路由的统一配置。</p>\n<p>最后为了方便开发获取代码，生成dist文件夹推入dist的分支。</p>\n"},{"title":"修改Git默认编辑器","_content":"\n\n### 缘由\n最近用git commit --amend的时候自动跳出来的vim编辑器内输入“文件”的“文”老是不显示，于是怒下决心要把vim编辑器换成sublime编辑器。\n\n### 配置\n还好git和sublime text 3(Build 3065以上)支持了此功能，只需要敲入命令：\n```\ngit config --global core.editor \"'D:/program files/sublime text 3/subl.exe' -w\"\n```\n即可。\n或\n在.gitconfig文件里设置：\n```\n[core]\n    editor = 'D:/Program Files/Sublime Text 3/subl.exe' -w\n```\n\n### 注意事项\n> * setting 里的`hot_exit`需设置为 true\n> * setting 里的`remember_open_files`需设置为 true\n> * 保存并关闭（CTRL+w）自动跳出来的tab页时才能起保存作用\n\n![sublime-editor](/images/sublime-editor.png)\n\n参考[stackoverflow](http://stackoverflow.com/questions/8951275/how-can-i-make-sublime-text-the-default-editor-for-git)","source":"_posts/修改Git默认编辑器.md","raw":"title: 修改Git默认编辑器\ntags: [sublime,git]\n---\n\n\n### 缘由\n最近用git commit --amend的时候自动跳出来的vim编辑器内输入“文件”的“文”老是不显示，于是怒下决心要把vim编辑器换成sublime编辑器。\n\n### 配置\n还好git和sublime text 3(Build 3065以上)支持了此功能，只需要敲入命令：\n```\ngit config --global core.editor \"'D:/program files/sublime text 3/subl.exe' -w\"\n```\n即可。\n或\n在.gitconfig文件里设置：\n```\n[core]\n    editor = 'D:/Program Files/Sublime Text 3/subl.exe' -w\n```\n\n### 注意事项\n> * setting 里的`hot_exit`需设置为 true\n> * setting 里的`remember_open_files`需设置为 true\n> * 保存并关闭（CTRL+w）自动跳出来的tab页时才能起保存作用\n\n![sublime-editor](/images/sublime-editor.png)\n\n参考[stackoverflow](http://stackoverflow.com/questions/8951275/how-can-i-make-sublime-text-the-default-editor-for-git)","slug":"修改Git默认编辑器","published":1,"date":"2018-05-11T07:48:43.000Z","updated":"2018-05-11T07:48:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckep5vtcr000fl4i93dmeawdw","content":"<h3 id=\"缘由\"><a href=\"#缘由\" class=\"headerlink\" title=\"缘由\"></a>缘由</h3><p>最近用git commit –amend的时候自动跳出来的vim编辑器内输入“文件”的“文”老是不显示，于是怒下决心要把vim编辑器换成sublime编辑器。</p>\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p>还好git和sublime text 3(Build 3065以上)支持了此功能，只需要敲入命令：<br><figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git<span class=\"built_in\"> config </span>--global core.editor <span class=\"string\">\"'D:/program files/sublime text 3/subl.exe' -w\"</span></span><br></pre></td></tr></table></figure></p>\n<p>即可。<br>或<br>在.gitconfig文件里设置：<br><figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"meta\">core</span>]</span><br><span class=\"line\">    editor = <span class=\"string\">'D:/Program Files/Sublime Text 3/subl.exe'</span> -w</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><blockquote>\n<ul>\n<li>setting 里的<code>hot_exit</code>需设置为 true</li>\n<li>setting 里的<code>remember_open_files</code>需设置为 true</li>\n<li>保存并关闭（CTRL+w）自动跳出来的tab页时才能起保存作用</li>\n</ul>\n</blockquote>\n<p><img src=\"/images/sublime-editor.png\" alt=\"sublime-editor\"></p>\n<p>参考<a href=\"http://stackoverflow.com/questions/8951275/how-can-i-make-sublime-text-the-default-editor-for-git\" target=\"_blank\" rel=\"noopener\">stackoverflow</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"缘由\"><a href=\"#缘由\" class=\"headerlink\" title=\"缘由\"></a>缘由</h3><p>最近用git commit –amend的时候自动跳出来的vim编辑器内输入“文件”的“文”老是不显示，于是怒下决心要把vim编辑器换成sublime编辑器。</p>\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p>还好git和sublime text 3(Build 3065以上)支持了此功能，只需要敲入命令：<br><figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git<span class=\"built_in\"> config </span>--global core.editor <span class=\"string\">\"'D:/program files/sublime text 3/subl.exe' -w\"</span></span><br></pre></td></tr></table></figure></p>\n<p>即可。<br>或<br>在.gitconfig文件里设置：<br><figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"meta\">core</span>]</span><br><span class=\"line\">    editor = <span class=\"string\">'D:/Program Files/Sublime Text 3/subl.exe'</span> -w</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><blockquote>\n<ul>\n<li>setting 里的<code>hot_exit</code>需设置为 true</li>\n<li>setting 里的<code>remember_open_files</code>需设置为 true</li>\n<li>保存并关闭（CTRL+w）自动跳出来的tab页时才能起保存作用</li>\n</ul>\n</blockquote>\n<p><img src=\"/images/sublime-editor.png\" alt=\"sublime-editor\"></p>\n<p>参考<a href=\"http://stackoverflow.com/questions/8951275/how-can-i-make-sublime-text-the-default-editor-for-git\" target=\"_blank\" rel=\"noopener\">stackoverflow</a></p>\n"},{"title":"打开next主题下的tags、分类模式","_content":"\n首先打开主题下(比如next)的配置文件_config.yml，然后搜索menu找到如下配置项，将about、tags、categories前的#号去掉，就开启了关于、标签和分类标签，当然还有其他菜单项也可以开启\n\n```\nmenu:\n  home: / || home\n  about: /about/ || user\n  tags: /tags/ || tags\n  categories: /categories/ || th\n  archives: /archives/ || archive\n  #schedule: /schedule/ || calendar\n  #sitemap: /sitemap.xml || sitemap\n  #commonweal: /404/ || heartbeat\n```\n\n重新生成部署后，可以看到新增的菜单项，但是单击后会报如下错误\n\n```\nCannot GET /about/\nCannot GET /tags/\nCannot GET /categories/\n```\n\n这是因为你还需运行如下命令新建相关页面\n\n```\nhexo new page \"about\"\nhexo new page \"tags\"\nhexo new page \"categories\"\n```\n\n运行结果如下，会再source文件下创建about、tags、categories文件夹，每个文件夹下还会创建一个index.md文件表示关于、标签页分类页面，编辑这三个MarkDown文件可以自定义这三个页面的内容\n\n```\nD:\\hexo\\blog>hexo new page \"about\"\n\nINFO  Created: D:\\hexo\\blog\\source\\about\\index.md\nD:\\hexo\\blog>hexo new page \"tags\"\nINFO  Created: D:\\hexo\\blog\\source\\tags\\index.md\nD:\\hexo\\blog>hexo new page \"categories\"\nINFO  Created: D:\\hexo\\blog\\source\\categories\\index.md\n```\n\n还差最后一步，打开各页面对应的index.md文件，编辑如下内容，title和date是默认生成的，增加type即可\n\n```\n---\ntitle: about\ndate: 2019-06-25 19:16:17\ntype: \"about\"\n---\n\n---\ntitle: about\ndate: 2019-06-25 19:16:17\ntype: \"tags\"\n---\n\n```\n\n重新生成和部署即可看到效果","source":"_posts/打开hexo的next主题下的tags.md","raw":"title: 打开next主题下的tags、分类模式\ntags: [nodejs]\n---\n\n首先打开主题下(比如next)的配置文件_config.yml，然后搜索menu找到如下配置项，将about、tags、categories前的#号去掉，就开启了关于、标签和分类标签，当然还有其他菜单项也可以开启\n\n```\nmenu:\n  home: / || home\n  about: /about/ || user\n  tags: /tags/ || tags\n  categories: /categories/ || th\n  archives: /archives/ || archive\n  #schedule: /schedule/ || calendar\n  #sitemap: /sitemap.xml || sitemap\n  #commonweal: /404/ || heartbeat\n```\n\n重新生成部署后，可以看到新增的菜单项，但是单击后会报如下错误\n\n```\nCannot GET /about/\nCannot GET /tags/\nCannot GET /categories/\n```\n\n这是因为你还需运行如下命令新建相关页面\n\n```\nhexo new page \"about\"\nhexo new page \"tags\"\nhexo new page \"categories\"\n```\n\n运行结果如下，会再source文件下创建about、tags、categories文件夹，每个文件夹下还会创建一个index.md文件表示关于、标签页分类页面，编辑这三个MarkDown文件可以自定义这三个页面的内容\n\n```\nD:\\hexo\\blog>hexo new page \"about\"\n\nINFO  Created: D:\\hexo\\blog\\source\\about\\index.md\nD:\\hexo\\blog>hexo new page \"tags\"\nINFO  Created: D:\\hexo\\blog\\source\\tags\\index.md\nD:\\hexo\\blog>hexo new page \"categories\"\nINFO  Created: D:\\hexo\\blog\\source\\categories\\index.md\n```\n\n还差最后一步，打开各页面对应的index.md文件，编辑如下内容，title和date是默认生成的，增加type即可\n\n```\n---\ntitle: about\ndate: 2019-06-25 19:16:17\ntype: \"about\"\n---\n\n---\ntitle: about\ndate: 2019-06-25 19:16:17\ntype: \"tags\"\n---\n\n```\n\n重新生成和部署即可看到效果","slug":"打开hexo的next主题下的tags","published":1,"date":"2020-09-04T09:31:38.218Z","updated":"2020-09-05T03:29:32.973Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckep5vtct000il4i98izlh8dm","content":"<p>首先打开主题下(比如next)的配置文件_config.yml，然后搜索menu找到如下配置项，将about、tags、categories前的#号去掉，就开启了关于、标签和分类标签，当然还有其他菜单项也可以开启</p>\n<figure class=\"highlight dts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">menu:</span></span><br><span class=\"line\"><span class=\"symbol\">  home:</span> / || home</span><br><span class=\"line\"><span class=\"symbol\">  about:</span> <span class=\"meta-keyword\">/about/</span> || user</span><br><span class=\"line\"><span class=\"symbol\">  tags:</span> <span class=\"meta-keyword\">/tags/</span> || tags</span><br><span class=\"line\"><span class=\"symbol\">  categories:</span> <span class=\"meta-keyword\">/categories/</span> || th</span><br><span class=\"line\"><span class=\"symbol\">  archives:</span> <span class=\"meta-keyword\">/archives/</span> || archive</span><br><span class=\"line\">  <span class=\"meta\">#schedule: /schedule/ || calendar</span></span><br><span class=\"line\">  <span class=\"meta\">#sitemap: /sitemap.xml || sitemap</span></span><br><span class=\"line\">  <span class=\"meta\">#commonweal: /404/ || heartbeat</span></span><br></pre></td></tr></table></figure>\n<p>重新生成部署后，可以看到新增的菜单项，但是单击后会报如下错误</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cannot <span class=\"builtin-name\">GET</span> /about/</span><br><span class=\"line\">Cannot <span class=\"builtin-name\">GET</span> /tags/</span><br><span class=\"line\">Cannot <span class=\"builtin-name\">GET</span> /categories/</span><br></pre></td></tr></table></figure>\n<p>这是因为你还需运行如下命令新建相关页面</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new<span class=\"built_in\"> page </span><span class=\"string\">\"about\"</span></span><br><span class=\"line\">hexo new<span class=\"built_in\"> page </span><span class=\"string\">\"tags\"</span></span><br><span class=\"line\">hexo new<span class=\"built_in\"> page </span><span class=\"string\">\"categories\"</span></span><br></pre></td></tr></table></figure>\n<p>运行结果如下，会再source文件下创建about、tags、categories文件夹，每个文件夹下还会创建一个index.md文件表示关于、标签页分类页面，编辑这三个MarkDown文件可以自定义这三个页面的内容</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D:\\hexo\\blog&gt;hexo new<span class=\"built_in\"> page </span><span class=\"string\">\"about\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"builtin-name\">INFO</span>  Created: D:\\hexo\\blog\\source\\about\\index.md</span><br><span class=\"line\">D:\\hexo\\blog&gt;hexo new<span class=\"built_in\"> page </span><span class=\"string\">\"tags\"</span></span><br><span class=\"line\"><span class=\"builtin-name\">INFO</span>  Created: D:\\hexo\\blog\\source\\tags\\index.md</span><br><span class=\"line\">D:\\hexo\\blog&gt;hexo new<span class=\"built_in\"> page </span><span class=\"string\">\"categories\"</span></span><br><span class=\"line\"><span class=\"builtin-name\">INFO</span>  Created: D:\\hexo\\blog\\source\\categories\\index.md</span><br></pre></td></tr></table></figure>\n<p>还差最后一步，打开各页面对应的index.md文件，编辑如下内容，title和date是默认生成的，增加type即可</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">title:</span> <span class=\"string\">about</span></span><br><span class=\"line\"><span class=\"attr\">date:</span> <span class=\"number\">2019</span><span class=\"number\">-06</span><span class=\"number\">-25</span> <span class=\"number\">19</span><span class=\"string\">:16:17</span></span><br><span class=\"line\"><span class=\"attr\">type:</span> <span class=\"string\">\"about\"</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">title:</span> <span class=\"string\">about</span></span><br><span class=\"line\"><span class=\"attr\">date:</span> <span class=\"number\">2019</span><span class=\"number\">-06</span><span class=\"number\">-25</span> <span class=\"number\">19</span><span class=\"string\">:16:17</span></span><br><span class=\"line\"><span class=\"attr\">type:</span> <span class=\"string\">\"tags\"</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br></pre></td></tr></table></figure>\n<p>重新生成和部署即可看到效果</p>\n","site":{"data":{}},"excerpt":"","more":"<p>首先打开主题下(比如next)的配置文件_config.yml，然后搜索menu找到如下配置项，将about、tags、categories前的#号去掉，就开启了关于、标签和分类标签，当然还有其他菜单项也可以开启</p>\n<figure class=\"highlight dts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">menu:</span></span><br><span class=\"line\"><span class=\"symbol\">  home:</span> / || home</span><br><span class=\"line\"><span class=\"symbol\">  about:</span> <span class=\"meta-keyword\">/about/</span> || user</span><br><span class=\"line\"><span class=\"symbol\">  tags:</span> <span class=\"meta-keyword\">/tags/</span> || tags</span><br><span class=\"line\"><span class=\"symbol\">  categories:</span> <span class=\"meta-keyword\">/categories/</span> || th</span><br><span class=\"line\"><span class=\"symbol\">  archives:</span> <span class=\"meta-keyword\">/archives/</span> || archive</span><br><span class=\"line\">  <span class=\"meta\">#schedule: /schedule/ || calendar</span></span><br><span class=\"line\">  <span class=\"meta\">#sitemap: /sitemap.xml || sitemap</span></span><br><span class=\"line\">  <span class=\"meta\">#commonweal: /404/ || heartbeat</span></span><br></pre></td></tr></table></figure>\n<p>重新生成部署后，可以看到新增的菜单项，但是单击后会报如下错误</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cannot <span class=\"builtin-name\">GET</span> /about/</span><br><span class=\"line\">Cannot <span class=\"builtin-name\">GET</span> /tags/</span><br><span class=\"line\">Cannot <span class=\"builtin-name\">GET</span> /categories/</span><br></pre></td></tr></table></figure>\n<p>这是因为你还需运行如下命令新建相关页面</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new<span class=\"built_in\"> page </span><span class=\"string\">\"about\"</span></span><br><span class=\"line\">hexo new<span class=\"built_in\"> page </span><span class=\"string\">\"tags\"</span></span><br><span class=\"line\">hexo new<span class=\"built_in\"> page </span><span class=\"string\">\"categories\"</span></span><br></pre></td></tr></table></figure>\n<p>运行结果如下，会再source文件下创建about、tags、categories文件夹，每个文件夹下还会创建一个index.md文件表示关于、标签页分类页面，编辑这三个MarkDown文件可以自定义这三个页面的内容</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D:\\hexo\\blog&gt;hexo new<span class=\"built_in\"> page </span><span class=\"string\">\"about\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"builtin-name\">INFO</span>  Created: D:\\hexo\\blog\\source\\about\\index.md</span><br><span class=\"line\">D:\\hexo\\blog&gt;hexo new<span class=\"built_in\"> page </span><span class=\"string\">\"tags\"</span></span><br><span class=\"line\"><span class=\"builtin-name\">INFO</span>  Created: D:\\hexo\\blog\\source\\tags\\index.md</span><br><span class=\"line\">D:\\hexo\\blog&gt;hexo new<span class=\"built_in\"> page </span><span class=\"string\">\"categories\"</span></span><br><span class=\"line\"><span class=\"builtin-name\">INFO</span>  Created: D:\\hexo\\blog\\source\\categories\\index.md</span><br></pre></td></tr></table></figure>\n<p>还差最后一步，打开各页面对应的index.md文件，编辑如下内容，title和date是默认生成的，增加type即可</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">title:</span> <span class=\"string\">about</span></span><br><span class=\"line\"><span class=\"attr\">date:</span> <span class=\"number\">2019</span><span class=\"number\">-06</span><span class=\"number\">-25</span> <span class=\"number\">19</span><span class=\"string\">:16:17</span></span><br><span class=\"line\"><span class=\"attr\">type:</span> <span class=\"string\">\"about\"</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">title:</span> <span class=\"string\">about</span></span><br><span class=\"line\"><span class=\"attr\">date:</span> <span class=\"number\">2019</span><span class=\"number\">-06</span><span class=\"number\">-25</span> <span class=\"number\">19</span><span class=\"string\">:16:17</span></span><br><span class=\"line\"><span class=\"attr\">type:</span> <span class=\"string\">\"tags\"</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br></pre></td></tr></table></figure>\n<p>重新生成和部署即可看到效果</p>\n"},{"title":"简易虚拟dom原理","_content":"\n## 虚拟dom的样子\n\n1、原生dom\n\n```html\n<div class=\"outer\" id=\"app\">\n    <div class=\"inner\">内部</div>\n</div>\n```\n\n2、虚拟dom\n\n```js\nvnode = {\n    tag: 'div',\n    data: {\n        class: 'outer',\n        id: 'app'\n    },\n    children: [{\n        tag: 'div',\n        data: {\n            class: 'inner'\n        },\n        children: '内部'\n    }]\n}\n```\n\n\n\n## 什么是虚拟dom\n\n为了避免过多操作原生dom，用js模拟dom树结构的一个对象。\n\n\n\n## js操作原生dom为什么开销大\n\n> 因为浏览器渲染dom树的引擎和 js引擎是分开的，如果通过js操作dom这些跨引擎的通讯增加了成本，以及 dom 操作引起的浏览器的回流和重绘，使得性能开销巨大，原本在 pc 端是没有性能问题的，因为 pc 的计算能力强，但是随着移动端的发展，越来越多的网页在智能手机上运行，而手机的性能参差不齐，会有性能问题。\n\n- 随便新建一个div，它的属性就有如下这么多：\n\n  ```js\n  \"align, title, lang, translate, dir, hidden, accessKey, draggable, spellcheck, autocapitalize, contentEditable, isContentEditable, inputMode, offsetParent, offsetTop, offsetLeft, offsetWidth, offsetHeight, style, innerText, outerText, oncopy, oncut, onpaste, onabort, onblur, oncancel, oncanplay, oncanplaythrough, onchange, onclick, onclose, oncontextmenu, oncuechange, ondblclick, ondrag, ondragend, ondragenter, ondragleave, ondragover, ondragstart, ondrop, ondurationchange, onemptied, onended, onerror, onfocus, oninput, oninvalid, onkeydown, onkeypress, onkeyup, onload, onloadeddata, onloadedmetadata, onloadstart, onmousedown, onmouseenter, onmouseleave, onmousemove, onmouseout, onmouseover, onmouseup, onmousewheel, onpause, onplay, onplaying, onprogress, onratechange, onreset, onresize, onscroll, onseeked, onseeking, onselect, onstalled, onsubmit, onsuspend, ontimeupdate, ontoggle, onvolumechange, onwaiting, onwheel, onauxclick, ongotpointercapture, onlostpointercapture, onpointerdown, onpointermove, onpointerup, onpointercancel, onpointerover, onpointerout, onpointerenter, onpointerleave, onselectstart, onselectionchange, dataset, nonce, tabIndex, click, focus, blur, enterKeyHint, onformdata, onpointerrawupdate, attachInternals, namespaceURI, prefix, localName, tagName, id, className, classList, slot, part, attributes, shadowRoot, assignedSlot, innerHTML, outerHTML, scrollTop, scrollLeft, scrollWidth, scrollHeight, clientTop, clientLeft, clientWidth, clientHeight, attributeStyleMap, onbeforecopy, onbeforecut, onbeforepaste, onsearch, previousElementSibling, nextElementSibling, children, firstElementChild, lastElementChild, childElementCount, onfullscreenchange, onfullscreenerror, onwebkitfullscreenchange, onwebkitfullscreenerror, setPointerCapture, releasePointerCapture, hasPointerCapture, hasAttributes, getAttributeNames, getAttribute, getAttributeNS, setAttribute, setAttributeNS, removeAttribute, removeAttributeNS, hasAttribute, hasAttributeNS, toggleAttribute, getAttributeNode, getAttributeNodeNS, setAttributeNode, setAttributeNodeNS, removeAttributeNode, closest, matches, webkitMatchesSelector, attachShadow, getElementsByTagName, getElementsByTagNameNS, getElementsByClassName, insertAdjacentElement, insertAdjacentText, insertAdjacentHTML, requestPointerLock, getClientRects, getBoundingClientRect, scrollIntoView, scroll, scrollTo, scrollBy, scrollIntoViewIfNeeded, animate, computedStyleMap, before, after, replaceWith, remove, prepend, append, querySelector, querySelectorAll, requestFullscreen, webkitRequestFullScreen, webkitRequestFullscreen, createShadowRoot, getDestinationInsertionPoints, elementTiming, ELEMENT_NODE, ATTRIBUTE_NODE, TEXT_NODE, CDATA_SECTION_NODE, ENTITY_REFERENCE_NODE, ENTITY_NODE, PROCESSING_INSTRUCTION_NODE, COMMENT_NODE, DOCUMENT_NODE, DOCUMENT_TYPE_NODE, DOCUMENT_FRAGMENT_NODE, NOTATION_NODE, DOCUMENT_POSITION_DISCONNECTED, DOCUMENT_POSITION_PRECEDING, DOCUMENT_POSITION_FOLLOWING, DOCUMENT_POSITION_CONTAINS, DOCUMENT_POSITION_CONTAINED_BY, DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC, nodeType, nodeName, baseURI, isConnected, ownerDocument, parentNode, parentElement, childNodes, firstChild, lastChild, previousSibling, nextSibling, nodeValue, textContent, hasChildNodes, getRootNode, normalize, cloneNode, isEqualNode, isSameNode, compareDocumentPosition, contains, lookupPrefix, lookupNamespaceURI, isDefaultNamespace, insertBefore, appendChild, replaceChild, removeChild, addEventListener, removeEventListener, dispatchEvent, \"\n  ```\n\n- [重绘和回流]( https://segmentfault.com/a/1190000017329980 )（重排）\n\n   ![webkit渲染过程](https://image-static.segmentfault.com/408/885/4088852130-5afbe6c95934b_articlex) \n\n  \n\n  如果重排就会改变上面那么多属性的值\n\n  \n\n## 虚拟dom的新建\n\n### 新建标签节点的虚拟dom\n\n```js\ncreateVnodeElement(tag, data, children = null) {\n\tlet flag;\n    if (typeof tag === 'string') {\n        flag = 'html'\n    } else if (typeof tag === 'function') {\n        flag = 'component'\n    } else {\n        flag = 'text'\n    }\n    let childrenFlag;\n    if(children === null) {\n        childrenFlag = 'empty'\n    } else if (Array.isArray(children)) {\n        let length = children.length;\n        if (length === 0) {\n            childrenFlag = 'empty'\n        } else {\n            childrenFlag = 'multiple'\n        }\n    } else {\n        childrenFlag = 'single';\n        children = createTextVnode(children + '');\n    }\n    \n    return {\n        flag,\n        tag,\n        data,\n        children,\n        childrenFlag\n    }\n}\n```\n### 新建文本节点的虚拟dom\n```js\n// 新建文本类型虚拟dom\nfunction createTextVnode(text) {\n  return {\n    flag: vnodeType.TEXT,\n    tag: null,\n    data: null,\n    children: text,\n    childrenFlag: childType.EMPTY\n  }\n}\n```\n\n\n## 虚拟dom的调用\n\n```js\nvnode = createElement('div', {id: 'test'}, [\n      createElement(123)\n      createElement('p', {key: 'a', style: {color: 'blue'}}, '节点1'),\n      createElement('p', {key: 'b', '@click': () => {alert(xx)}}, '节点2'),\n      createElement('p', {key: 'c', 'class': 'item-header'}, '节点3'),\n      createElement('p', {key: 'd'}, '节点4')\n    ])\n```\n\n\n\n## 虚拟dom的渲染\n\n```js\nrender(vnode, document.getElementById('app'))\n```\n\n```js\n// 渲染\nfunction render(vnode, container) {\n    if (container.vnode) {\n       patch(container.vnode, vnode, container)\n    } else {\n  \t   mount(vnode, container)\n    }\n    container.vnode = vnode;\n}\n\n// 首次挂载元素\nfunction mount(vnode, container) {\n  let {flag} = vnode\n  // 标签节点\n  if (flag === 'html') {\n    mountElement(vnode, container)\n  // 文本节点\n  } else if (flag === 'text') {\n    mountText(vnode, container)\n  }\n}\n```\n\n\n\n### 标签节点的属性挂载\n\n```js\nif (data) {\n    for (let key in data) {\n        // 节点，名字，老值，新值\n        patchData(dom, key, null, data[key])\n    }\n}\n```\n\n\n\n### 标签节点的子元素挂载\n\n```js\nif (childrenFlag !== childType.EMPTY) {\n    if (childrenFlag === childType.SINGLE) {\n        mount(children, dom)\n    } else if (childrenFlag === childType.MULTIPLE) {\n        for (let i = 0; i < children.length; i++) {\n            mount(children[i], dom)\n        }\n    }\n}\n```\n\n\n\n\n\n## 虚拟dom核心：diff\n\n这是另一位同学分享的[虚拟dom的diff算法浅析]( http://10.199.140.56/book/part1/react/diff.html )\n\n\n\n- 节点分标签节点和文本节点，所以需要flag来判断\n- childrenFlag判断不同的子元素\n- 判断后进行不同形式的渲染\n- 难点：diff两个数组，例子：[axxbxxc] ->  [cxxaxxb] ，虚拟dom从axxbxxc变为cxxaxxb，c一开始不需要移动位置，只管插入dom中，ab俩是按字母顺序所以b就不需要移动位置，但a到c后面了不是按字母顺序，所以需要移动位置。\n- [abcd] -> [acd]，react或vue的key对应list数组里每个元素，如果删掉一个b，还用index下标作为key的话，c会取代原来b的位置，这时候如果是选中c,效果就会变成d被选中，所以尽量不要用index作为key。\n\n[简易虚拟dom源码](https://github.com/nameit/simple-vdom)","source":"_posts/vdom.md","raw":"title: 简易虚拟dom原理\ntags: [vdom]\ncategories: 前端\n---\n\n## 虚拟dom的样子\n\n1、原生dom\n\n```html\n<div class=\"outer\" id=\"app\">\n    <div class=\"inner\">内部</div>\n</div>\n```\n\n2、虚拟dom\n\n```js\nvnode = {\n    tag: 'div',\n    data: {\n        class: 'outer',\n        id: 'app'\n    },\n    children: [{\n        tag: 'div',\n        data: {\n            class: 'inner'\n        },\n        children: '内部'\n    }]\n}\n```\n\n\n\n## 什么是虚拟dom\n\n为了避免过多操作原生dom，用js模拟dom树结构的一个对象。\n\n\n\n## js操作原生dom为什么开销大\n\n> 因为浏览器渲染dom树的引擎和 js引擎是分开的，如果通过js操作dom这些跨引擎的通讯增加了成本，以及 dom 操作引起的浏览器的回流和重绘，使得性能开销巨大，原本在 pc 端是没有性能问题的，因为 pc 的计算能力强，但是随着移动端的发展，越来越多的网页在智能手机上运行，而手机的性能参差不齐，会有性能问题。\n\n- 随便新建一个div，它的属性就有如下这么多：\n\n  ```js\n  \"align, title, lang, translate, dir, hidden, accessKey, draggable, spellcheck, autocapitalize, contentEditable, isContentEditable, inputMode, offsetParent, offsetTop, offsetLeft, offsetWidth, offsetHeight, style, innerText, outerText, oncopy, oncut, onpaste, onabort, onblur, oncancel, oncanplay, oncanplaythrough, onchange, onclick, onclose, oncontextmenu, oncuechange, ondblclick, ondrag, ondragend, ondragenter, ondragleave, ondragover, ondragstart, ondrop, ondurationchange, onemptied, onended, onerror, onfocus, oninput, oninvalid, onkeydown, onkeypress, onkeyup, onload, onloadeddata, onloadedmetadata, onloadstart, onmousedown, onmouseenter, onmouseleave, onmousemove, onmouseout, onmouseover, onmouseup, onmousewheel, onpause, onplay, onplaying, onprogress, onratechange, onreset, onresize, onscroll, onseeked, onseeking, onselect, onstalled, onsubmit, onsuspend, ontimeupdate, ontoggle, onvolumechange, onwaiting, onwheel, onauxclick, ongotpointercapture, onlostpointercapture, onpointerdown, onpointermove, onpointerup, onpointercancel, onpointerover, onpointerout, onpointerenter, onpointerleave, onselectstart, onselectionchange, dataset, nonce, tabIndex, click, focus, blur, enterKeyHint, onformdata, onpointerrawupdate, attachInternals, namespaceURI, prefix, localName, tagName, id, className, classList, slot, part, attributes, shadowRoot, assignedSlot, innerHTML, outerHTML, scrollTop, scrollLeft, scrollWidth, scrollHeight, clientTop, clientLeft, clientWidth, clientHeight, attributeStyleMap, onbeforecopy, onbeforecut, onbeforepaste, onsearch, previousElementSibling, nextElementSibling, children, firstElementChild, lastElementChild, childElementCount, onfullscreenchange, onfullscreenerror, onwebkitfullscreenchange, onwebkitfullscreenerror, setPointerCapture, releasePointerCapture, hasPointerCapture, hasAttributes, getAttributeNames, getAttribute, getAttributeNS, setAttribute, setAttributeNS, removeAttribute, removeAttributeNS, hasAttribute, hasAttributeNS, toggleAttribute, getAttributeNode, getAttributeNodeNS, setAttributeNode, setAttributeNodeNS, removeAttributeNode, closest, matches, webkitMatchesSelector, attachShadow, getElementsByTagName, getElementsByTagNameNS, getElementsByClassName, insertAdjacentElement, insertAdjacentText, insertAdjacentHTML, requestPointerLock, getClientRects, getBoundingClientRect, scrollIntoView, scroll, scrollTo, scrollBy, scrollIntoViewIfNeeded, animate, computedStyleMap, before, after, replaceWith, remove, prepend, append, querySelector, querySelectorAll, requestFullscreen, webkitRequestFullScreen, webkitRequestFullscreen, createShadowRoot, getDestinationInsertionPoints, elementTiming, ELEMENT_NODE, ATTRIBUTE_NODE, TEXT_NODE, CDATA_SECTION_NODE, ENTITY_REFERENCE_NODE, ENTITY_NODE, PROCESSING_INSTRUCTION_NODE, COMMENT_NODE, DOCUMENT_NODE, DOCUMENT_TYPE_NODE, DOCUMENT_FRAGMENT_NODE, NOTATION_NODE, DOCUMENT_POSITION_DISCONNECTED, DOCUMENT_POSITION_PRECEDING, DOCUMENT_POSITION_FOLLOWING, DOCUMENT_POSITION_CONTAINS, DOCUMENT_POSITION_CONTAINED_BY, DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC, nodeType, nodeName, baseURI, isConnected, ownerDocument, parentNode, parentElement, childNodes, firstChild, lastChild, previousSibling, nextSibling, nodeValue, textContent, hasChildNodes, getRootNode, normalize, cloneNode, isEqualNode, isSameNode, compareDocumentPosition, contains, lookupPrefix, lookupNamespaceURI, isDefaultNamespace, insertBefore, appendChild, replaceChild, removeChild, addEventListener, removeEventListener, dispatchEvent, \"\n  ```\n\n- [重绘和回流]( https://segmentfault.com/a/1190000017329980 )（重排）\n\n   ![webkit渲染过程](https://image-static.segmentfault.com/408/885/4088852130-5afbe6c95934b_articlex) \n\n  \n\n  如果重排就会改变上面那么多属性的值\n\n  \n\n## 虚拟dom的新建\n\n### 新建标签节点的虚拟dom\n\n```js\ncreateVnodeElement(tag, data, children = null) {\n\tlet flag;\n    if (typeof tag === 'string') {\n        flag = 'html'\n    } else if (typeof tag === 'function') {\n        flag = 'component'\n    } else {\n        flag = 'text'\n    }\n    let childrenFlag;\n    if(children === null) {\n        childrenFlag = 'empty'\n    } else if (Array.isArray(children)) {\n        let length = children.length;\n        if (length === 0) {\n            childrenFlag = 'empty'\n        } else {\n            childrenFlag = 'multiple'\n        }\n    } else {\n        childrenFlag = 'single';\n        children = createTextVnode(children + '');\n    }\n    \n    return {\n        flag,\n        tag,\n        data,\n        children,\n        childrenFlag\n    }\n}\n```\n### 新建文本节点的虚拟dom\n```js\n// 新建文本类型虚拟dom\nfunction createTextVnode(text) {\n  return {\n    flag: vnodeType.TEXT,\n    tag: null,\n    data: null,\n    children: text,\n    childrenFlag: childType.EMPTY\n  }\n}\n```\n\n\n## 虚拟dom的调用\n\n```js\nvnode = createElement('div', {id: 'test'}, [\n      createElement(123)\n      createElement('p', {key: 'a', style: {color: 'blue'}}, '节点1'),\n      createElement('p', {key: 'b', '@click': () => {alert(xx)}}, '节点2'),\n      createElement('p', {key: 'c', 'class': 'item-header'}, '节点3'),\n      createElement('p', {key: 'd'}, '节点4')\n    ])\n```\n\n\n\n## 虚拟dom的渲染\n\n```js\nrender(vnode, document.getElementById('app'))\n```\n\n```js\n// 渲染\nfunction render(vnode, container) {\n    if (container.vnode) {\n       patch(container.vnode, vnode, container)\n    } else {\n  \t   mount(vnode, container)\n    }\n    container.vnode = vnode;\n}\n\n// 首次挂载元素\nfunction mount(vnode, container) {\n  let {flag} = vnode\n  // 标签节点\n  if (flag === 'html') {\n    mountElement(vnode, container)\n  // 文本节点\n  } else if (flag === 'text') {\n    mountText(vnode, container)\n  }\n}\n```\n\n\n\n### 标签节点的属性挂载\n\n```js\nif (data) {\n    for (let key in data) {\n        // 节点，名字，老值，新值\n        patchData(dom, key, null, data[key])\n    }\n}\n```\n\n\n\n### 标签节点的子元素挂载\n\n```js\nif (childrenFlag !== childType.EMPTY) {\n    if (childrenFlag === childType.SINGLE) {\n        mount(children, dom)\n    } else if (childrenFlag === childType.MULTIPLE) {\n        for (let i = 0; i < children.length; i++) {\n            mount(children[i], dom)\n        }\n    }\n}\n```\n\n\n\n\n\n## 虚拟dom核心：diff\n\n这是另一位同学分享的[虚拟dom的diff算法浅析]( http://10.199.140.56/book/part1/react/diff.html )\n\n\n\n- 节点分标签节点和文本节点，所以需要flag来判断\n- childrenFlag判断不同的子元素\n- 判断后进行不同形式的渲染\n- 难点：diff两个数组，例子：[axxbxxc] ->  [cxxaxxb] ，虚拟dom从axxbxxc变为cxxaxxb，c一开始不需要移动位置，只管插入dom中，ab俩是按字母顺序所以b就不需要移动位置，但a到c后面了不是按字母顺序，所以需要移动位置。\n- [abcd] -> [acd]，react或vue的key对应list数组里每个元素，如果删掉一个b，还用index下标作为key的话，c会取代原来b的位置，这时候如果是选中c,效果就会变成d被选中，所以尽量不要用index作为key。\n\n[简易虚拟dom源码](https://github.com/nameit/simple-vdom)","slug":"vdom","published":1,"date":"2020-09-04T02:56:58.995Z","updated":"2020-09-04T02:56:58.995Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckep5vtfl000yl4i9ivbmrn5v","content":"<h2 id=\"虚拟dom的样子\"><a href=\"#虚拟dom的样子\" class=\"headerlink\" title=\"虚拟dom的样子\"></a>虚拟dom的样子</h2><p>1、原生dom</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"outer\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"inner\"</span>&gt;</span>内部<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>2、虚拟dom</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vnode = &#123;</span><br><span class=\"line\">    tag: <span class=\"string\">'div'</span>,</span><br><span class=\"line\">    data: &#123;</span><br><span class=\"line\">        class: 'outer',</span><br><span class=\"line\">        id: <span class=\"string\">'app'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    children: [&#123;</span><br><span class=\"line\">        tag: <span class=\"string\">'div'</span>,</span><br><span class=\"line\">        data: &#123;</span><br><span class=\"line\">            class: 'inner'</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        children: <span class=\"string\">'内部'</span></span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"什么是虚拟dom\"><a href=\"#什么是虚拟dom\" class=\"headerlink\" title=\"什么是虚拟dom\"></a>什么是虚拟dom</h2><p>为了避免过多操作原生dom，用js模拟dom树结构的一个对象。</p>\n<h2 id=\"js操作原生dom为什么开销大\"><a href=\"#js操作原生dom为什么开销大\" class=\"headerlink\" title=\"js操作原生dom为什么开销大\"></a>js操作原生dom为什么开销大</h2><blockquote>\n<p>因为浏览器渲染dom树的引擎和 js引擎是分开的，如果通过js操作dom这些跨引擎的通讯增加了成本，以及 dom 操作引起的浏览器的回流和重绘，使得性能开销巨大，原本在 pc 端是没有性能问题的，因为 pc 的计算能力强，但是随着移动端的发展，越来越多的网页在智能手机上运行，而手机的性能参差不齐，会有性能问题。</p>\n</blockquote>\n<ul>\n<li><p>随便新建一个div，它的属性就有如下这么多：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"align, title, lang, translate, dir, hidden, accessKey, draggable, spellcheck, autocapitalize, contentEditable, isContentEditable, inputMode, offsetParent, offsetTop, offsetLeft, offsetWidth, offsetHeight, style, innerText, outerText, oncopy, oncut, onpaste, onabort, onblur, oncancel, oncanplay, oncanplaythrough, onchange, onclick, onclose, oncontextmenu, oncuechange, ondblclick, ondrag, ondragend, ondragenter, ondragleave, ondragover, ondragstart, ondrop, ondurationchange, onemptied, onended, onerror, onfocus, oninput, oninvalid, onkeydown, onkeypress, onkeyup, onload, onloadeddata, onloadedmetadata, onloadstart, onmousedown, onmouseenter, onmouseleave, onmousemove, onmouseout, onmouseover, onmouseup, onmousewheel, onpause, onplay, onplaying, onprogress, onratechange, onreset, onresize, onscroll, onseeked, onseeking, onselect, onstalled, onsubmit, onsuspend, ontimeupdate, ontoggle, onvolumechange, onwaiting, onwheel, onauxclick, ongotpointercapture, onlostpointercapture, onpointerdown, onpointermove, onpointerup, onpointercancel, onpointerover, onpointerout, onpointerenter, onpointerleave, onselectstart, onselectionchange, dataset, nonce, tabIndex, click, focus, blur, enterKeyHint, onformdata, onpointerrawupdate, attachInternals, namespaceURI, prefix, localName, tagName, id, className, classList, slot, part, attributes, shadowRoot, assignedSlot, innerHTML, outerHTML, scrollTop, scrollLeft, scrollWidth, scrollHeight, clientTop, clientLeft, clientWidth, clientHeight, attributeStyleMap, onbeforecopy, onbeforecut, onbeforepaste, onsearch, previousElementSibling, nextElementSibling, children, firstElementChild, lastElementChild, childElementCount, onfullscreenchange, onfullscreenerror, onwebkitfullscreenchange, onwebkitfullscreenerror, setPointerCapture, releasePointerCapture, hasPointerCapture, hasAttributes, getAttributeNames, getAttribute, getAttributeNS, setAttribute, setAttributeNS, removeAttribute, removeAttributeNS, hasAttribute, hasAttributeNS, toggleAttribute, getAttributeNode, getAttributeNodeNS, setAttributeNode, setAttributeNodeNS, removeAttributeNode, closest, matches, webkitMatchesSelector, attachShadow, getElementsByTagName, getElementsByTagNameNS, getElementsByClassName, insertAdjacentElement, insertAdjacentText, insertAdjacentHTML, requestPointerLock, getClientRects, getBoundingClientRect, scrollIntoView, scroll, scrollTo, scrollBy, scrollIntoViewIfNeeded, animate, computedStyleMap, before, after, replaceWith, remove, prepend, append, querySelector, querySelectorAll, requestFullscreen, webkitRequestFullScreen, webkitRequestFullscreen, createShadowRoot, getDestinationInsertionPoints, elementTiming, ELEMENT_NODE, ATTRIBUTE_NODE, TEXT_NODE, CDATA_SECTION_NODE, ENTITY_REFERENCE_NODE, ENTITY_NODE, PROCESSING_INSTRUCTION_NODE, COMMENT_NODE, DOCUMENT_NODE, DOCUMENT_TYPE_NODE, DOCUMENT_FRAGMENT_NODE, NOTATION_NODE, DOCUMENT_POSITION_DISCONNECTED, DOCUMENT_POSITION_PRECEDING, DOCUMENT_POSITION_FOLLOWING, DOCUMENT_POSITION_CONTAINS, DOCUMENT_POSITION_CONTAINED_BY, DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC, nodeType, nodeName, baseURI, isConnected, ownerDocument, parentNode, parentElement, childNodes, firstChild, lastChild, previousSibling, nextSibling, nodeValue, textContent, hasChildNodes, getRootNode, normalize, cloneNode, isEqualNode, isSameNode, compareDocumentPosition, contains, lookupPrefix, lookupNamespaceURI, isDefaultNamespace, insertBefore, appendChild, replaceChild, removeChild, addEventListener, removeEventListener, dispatchEvent, \"</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><a href=\"https://segmentfault.com/a/1190000017329980\" target=\"_blank\" rel=\"noopener\">重绘和回流</a>（重排）</p>\n<p> <img src=\"https://image-static.segmentfault.com/408/885/4088852130-5afbe6c95934b_articlex\" alt=\"webkit渲染过程\"> </p>\n</li>\n</ul>\n<p>  如果重排就会改变上面那么多属性的值</p>\n<h2 id=\"虚拟dom的新建\"><a href=\"#虚拟dom的新建\" class=\"headerlink\" title=\"虚拟dom的新建\"></a>虚拟dom的新建</h2><h3 id=\"新建标签节点的虚拟dom\"><a href=\"#新建标签节点的虚拟dom\" class=\"headerlink\" title=\"新建标签节点的虚拟dom\"></a>新建标签节点的虚拟dom</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">createVnodeElement(tag, data, children = <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">let</span> flag;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> tag === <span class=\"string\">'string'</span>) &#123;</span><br><span class=\"line\">        flag = <span class=\"string\">'html'</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> tag === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">        flag = <span class=\"string\">'component'</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        flag = <span class=\"string\">'text'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> childrenFlag;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(children === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        childrenFlag = <span class=\"string\">'empty'</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(children)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> length = children.length;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (length === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            childrenFlag = <span class=\"string\">'empty'</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            childrenFlag = <span class=\"string\">'multiple'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        childrenFlag = <span class=\"string\">'single'</span>;</span><br><span class=\"line\">        children = createTextVnode(children + <span class=\"string\">''</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        flag,</span><br><span class=\"line\">        tag,</span><br><span class=\"line\">        data,</span><br><span class=\"line\">        children,</span><br><span class=\"line\">        childrenFlag</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"新建文本节点的虚拟dom\"><a href=\"#新建文本节点的虚拟dom\" class=\"headerlink\" title=\"新建文本节点的虚拟dom\"></a>新建文本节点的虚拟dom</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 新建文本类型虚拟dom</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createTextVnode</span>(<span class=\"params\">text</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    flag: vnodeType.TEXT,</span><br><span class=\"line\">    tag: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    data: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    children: text,</span><br><span class=\"line\">    childrenFlag: childType.EMPTY</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"虚拟dom的调用\"><a href=\"#虚拟dom的调用\" class=\"headerlink\" title=\"虚拟dom的调用\"></a>虚拟dom的调用</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vnode = createElement(<span class=\"string\">'div'</span>, &#123;<span class=\"attr\">id</span>: <span class=\"string\">'test'</span>&#125;, [</span><br><span class=\"line\">      createElement(<span class=\"number\">123</span>)</span><br><span class=\"line\">      createElement(<span class=\"string\">'p'</span>, &#123;<span class=\"attr\">key</span>: <span class=\"string\">'a'</span>, <span class=\"attr\">style</span>: &#123;<span class=\"attr\">color</span>: <span class=\"string\">'blue'</span>&#125;&#125;, <span class=\"string\">'节点1'</span>),</span><br><span class=\"line\">      createElement(<span class=\"string\">'p'</span>, &#123;<span class=\"attr\">key</span>: <span class=\"string\">'b'</span>, <span class=\"string\">'@click'</span>: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;alert(xx)&#125;&#125;, <span class=\"string\">'节点2'</span>),</span><br><span class=\"line\">      createElement(<span class=\"string\">'p'</span>, &#123;<span class=\"attr\">key</span>: <span class=\"string\">'c'</span>, <span class=\"string\">'class'</span>: <span class=\"string\">'item-header'</span>&#125;, <span class=\"string\">'节点3'</span>),</span><br><span class=\"line\">      createElement(<span class=\"string\">'p'</span>, &#123;<span class=\"attr\">key</span>: <span class=\"string\">'d'</span>&#125;, <span class=\"string\">'节点4'</span>)</span><br><span class=\"line\">    ])</span><br></pre></td></tr></table></figure>\n<h2 id=\"虚拟dom的渲染\"><a href=\"#虚拟dom的渲染\" class=\"headerlink\" title=\"虚拟dom的渲染\"></a>虚拟dom的渲染</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">render(vnode, <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'app'</span>))</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 渲染</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span>(<span class=\"params\">vnode, container</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (container.vnode) &#123;</span><br><span class=\"line\">       patch(container.vnode, vnode, container)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  \t   mount(vnode, container)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    container.vnode = vnode;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 首次挂载元素</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mount</span>(<span class=\"params\">vnode, container</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> &#123;flag&#125; = vnode</span><br><span class=\"line\">  <span class=\"comment\">// 标签节点</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (flag === <span class=\"string\">'html'</span>) &#123;</span><br><span class=\"line\">    mountElement(vnode, container)</span><br><span class=\"line\">  <span class=\"comment\">// 文本节点</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (flag === <span class=\"string\">'text'</span>) &#123;</span><br><span class=\"line\">    mountText(vnode, container)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"标签节点的属性挂载\"><a href=\"#标签节点的属性挂载\" class=\"headerlink\" title=\"标签节点的属性挂载\"></a>标签节点的属性挂载</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (data) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> key <span class=\"keyword\">in</span> data) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 节点，名字，老值，新值</span></span><br><span class=\"line\">        patchData(dom, key, <span class=\"literal\">null</span>, data[key])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"标签节点的子元素挂载\"><a href=\"#标签节点的子元素挂载\" class=\"headerlink\" title=\"标签节点的子元素挂载\"></a>标签节点的子元素挂载</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (childrenFlag !== childType.EMPTY) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (childrenFlag === childType.SINGLE) &#123;</span><br><span class=\"line\">        mount(children, dom)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (childrenFlag === childType.MULTIPLE) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; children.length; i++) &#123;</span><br><span class=\"line\">            mount(children[i], dom)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"虚拟dom核心：diff\"><a href=\"#虚拟dom核心：diff\" class=\"headerlink\" title=\"虚拟dom核心：diff\"></a>虚拟dom核心：diff</h2><p>这是另一位同学分享的<a href=\"http://10.199.140.56/book/part1/react/diff.html\" target=\"_blank\" rel=\"noopener\">虚拟dom的diff算法浅析</a></p>\n<ul>\n<li>节点分标签节点和文本节点，所以需要flag来判断</li>\n<li>childrenFlag判断不同的子元素</li>\n<li>判断后进行不同形式的渲染</li>\n<li>难点：diff两个数组，例子：[axxbxxc] -&gt;  [cxxaxxb] ，虚拟dom从axxbxxc变为cxxaxxb，c一开始不需要移动位置，只管插入dom中，ab俩是按字母顺序所以b就不需要移动位置，但a到c后面了不是按字母顺序，所以需要移动位置。</li>\n<li>[abcd] -&gt; [acd]，react或vue的key对应list数组里每个元素，如果删掉一个b，还用index下标作为key的话，c会取代原来b的位置，这时候如果是选中c,效果就会变成d被选中，所以尽量不要用index作为key。</li>\n</ul>\n<p><a href=\"https://github.com/nameit/simple-vdom\" target=\"_blank\" rel=\"noopener\">简易虚拟dom源码</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"虚拟dom的样子\"><a href=\"#虚拟dom的样子\" class=\"headerlink\" title=\"虚拟dom的样子\"></a>虚拟dom的样子</h2><p>1、原生dom</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"outer\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"inner\"</span>&gt;</span>内部<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>2、虚拟dom</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vnode = &#123;</span><br><span class=\"line\">    tag: <span class=\"string\">'div'</span>,</span><br><span class=\"line\">    data: &#123;</span><br><span class=\"line\">        class: 'outer',</span><br><span class=\"line\">        id: <span class=\"string\">'app'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    children: [&#123;</span><br><span class=\"line\">        tag: <span class=\"string\">'div'</span>,</span><br><span class=\"line\">        data: &#123;</span><br><span class=\"line\">            class: 'inner'</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        children: <span class=\"string\">'内部'</span></span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"什么是虚拟dom\"><a href=\"#什么是虚拟dom\" class=\"headerlink\" title=\"什么是虚拟dom\"></a>什么是虚拟dom</h2><p>为了避免过多操作原生dom，用js模拟dom树结构的一个对象。</p>\n<h2 id=\"js操作原生dom为什么开销大\"><a href=\"#js操作原生dom为什么开销大\" class=\"headerlink\" title=\"js操作原生dom为什么开销大\"></a>js操作原生dom为什么开销大</h2><blockquote>\n<p>因为浏览器渲染dom树的引擎和 js引擎是分开的，如果通过js操作dom这些跨引擎的通讯增加了成本，以及 dom 操作引起的浏览器的回流和重绘，使得性能开销巨大，原本在 pc 端是没有性能问题的，因为 pc 的计算能力强，但是随着移动端的发展，越来越多的网页在智能手机上运行，而手机的性能参差不齐，会有性能问题。</p>\n</blockquote>\n<ul>\n<li><p>随便新建一个div，它的属性就有如下这么多：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"align, title, lang, translate, dir, hidden, accessKey, draggable, spellcheck, autocapitalize, contentEditable, isContentEditable, inputMode, offsetParent, offsetTop, offsetLeft, offsetWidth, offsetHeight, style, innerText, outerText, oncopy, oncut, onpaste, onabort, onblur, oncancel, oncanplay, oncanplaythrough, onchange, onclick, onclose, oncontextmenu, oncuechange, ondblclick, ondrag, ondragend, ondragenter, ondragleave, ondragover, ondragstart, ondrop, ondurationchange, onemptied, onended, onerror, onfocus, oninput, oninvalid, onkeydown, onkeypress, onkeyup, onload, onloadeddata, onloadedmetadata, onloadstart, onmousedown, onmouseenter, onmouseleave, onmousemove, onmouseout, onmouseover, onmouseup, onmousewheel, onpause, onplay, onplaying, onprogress, onratechange, onreset, onresize, onscroll, onseeked, onseeking, onselect, onstalled, onsubmit, onsuspend, ontimeupdate, ontoggle, onvolumechange, onwaiting, onwheel, onauxclick, ongotpointercapture, onlostpointercapture, onpointerdown, onpointermove, onpointerup, onpointercancel, onpointerover, onpointerout, onpointerenter, onpointerleave, onselectstart, onselectionchange, dataset, nonce, tabIndex, click, focus, blur, enterKeyHint, onformdata, onpointerrawupdate, attachInternals, namespaceURI, prefix, localName, tagName, id, className, classList, slot, part, attributes, shadowRoot, assignedSlot, innerHTML, outerHTML, scrollTop, scrollLeft, scrollWidth, scrollHeight, clientTop, clientLeft, clientWidth, clientHeight, attributeStyleMap, onbeforecopy, onbeforecut, onbeforepaste, onsearch, previousElementSibling, nextElementSibling, children, firstElementChild, lastElementChild, childElementCount, onfullscreenchange, onfullscreenerror, onwebkitfullscreenchange, onwebkitfullscreenerror, setPointerCapture, releasePointerCapture, hasPointerCapture, hasAttributes, getAttributeNames, getAttribute, getAttributeNS, setAttribute, setAttributeNS, removeAttribute, removeAttributeNS, hasAttribute, hasAttributeNS, toggleAttribute, getAttributeNode, getAttributeNodeNS, setAttributeNode, setAttributeNodeNS, removeAttributeNode, closest, matches, webkitMatchesSelector, attachShadow, getElementsByTagName, getElementsByTagNameNS, getElementsByClassName, insertAdjacentElement, insertAdjacentText, insertAdjacentHTML, requestPointerLock, getClientRects, getBoundingClientRect, scrollIntoView, scroll, scrollTo, scrollBy, scrollIntoViewIfNeeded, animate, computedStyleMap, before, after, replaceWith, remove, prepend, append, querySelector, querySelectorAll, requestFullscreen, webkitRequestFullScreen, webkitRequestFullscreen, createShadowRoot, getDestinationInsertionPoints, elementTiming, ELEMENT_NODE, ATTRIBUTE_NODE, TEXT_NODE, CDATA_SECTION_NODE, ENTITY_REFERENCE_NODE, ENTITY_NODE, PROCESSING_INSTRUCTION_NODE, COMMENT_NODE, DOCUMENT_NODE, DOCUMENT_TYPE_NODE, DOCUMENT_FRAGMENT_NODE, NOTATION_NODE, DOCUMENT_POSITION_DISCONNECTED, DOCUMENT_POSITION_PRECEDING, DOCUMENT_POSITION_FOLLOWING, DOCUMENT_POSITION_CONTAINS, DOCUMENT_POSITION_CONTAINED_BY, DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC, nodeType, nodeName, baseURI, isConnected, ownerDocument, parentNode, parentElement, childNodes, firstChild, lastChild, previousSibling, nextSibling, nodeValue, textContent, hasChildNodes, getRootNode, normalize, cloneNode, isEqualNode, isSameNode, compareDocumentPosition, contains, lookupPrefix, lookupNamespaceURI, isDefaultNamespace, insertBefore, appendChild, replaceChild, removeChild, addEventListener, removeEventListener, dispatchEvent, \"</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><a href=\"https://segmentfault.com/a/1190000017329980\" target=\"_blank\" rel=\"noopener\">重绘和回流</a>（重排）</p>\n<p> <img src=\"https://image-static.segmentfault.com/408/885/4088852130-5afbe6c95934b_articlex\" alt=\"webkit渲染过程\"> </p>\n</li>\n</ul>\n<p>  如果重排就会改变上面那么多属性的值</p>\n<h2 id=\"虚拟dom的新建\"><a href=\"#虚拟dom的新建\" class=\"headerlink\" title=\"虚拟dom的新建\"></a>虚拟dom的新建</h2><h3 id=\"新建标签节点的虚拟dom\"><a href=\"#新建标签节点的虚拟dom\" class=\"headerlink\" title=\"新建标签节点的虚拟dom\"></a>新建标签节点的虚拟dom</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">createVnodeElement(tag, data, children = <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">let</span> flag;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> tag === <span class=\"string\">'string'</span>) &#123;</span><br><span class=\"line\">        flag = <span class=\"string\">'html'</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> tag === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">        flag = <span class=\"string\">'component'</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        flag = <span class=\"string\">'text'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> childrenFlag;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(children === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        childrenFlag = <span class=\"string\">'empty'</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(children)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> length = children.length;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (length === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            childrenFlag = <span class=\"string\">'empty'</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            childrenFlag = <span class=\"string\">'multiple'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        childrenFlag = <span class=\"string\">'single'</span>;</span><br><span class=\"line\">        children = createTextVnode(children + <span class=\"string\">''</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        flag,</span><br><span class=\"line\">        tag,</span><br><span class=\"line\">        data,</span><br><span class=\"line\">        children,</span><br><span class=\"line\">        childrenFlag</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"新建文本节点的虚拟dom\"><a href=\"#新建文本节点的虚拟dom\" class=\"headerlink\" title=\"新建文本节点的虚拟dom\"></a>新建文本节点的虚拟dom</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 新建文本类型虚拟dom</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createTextVnode</span>(<span class=\"params\">text</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    flag: vnodeType.TEXT,</span><br><span class=\"line\">    tag: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    data: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    children: text,</span><br><span class=\"line\">    childrenFlag: childType.EMPTY</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"虚拟dom的调用\"><a href=\"#虚拟dom的调用\" class=\"headerlink\" title=\"虚拟dom的调用\"></a>虚拟dom的调用</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vnode = createElement(<span class=\"string\">'div'</span>, &#123;<span class=\"attr\">id</span>: <span class=\"string\">'test'</span>&#125;, [</span><br><span class=\"line\">      createElement(<span class=\"number\">123</span>)</span><br><span class=\"line\">      createElement(<span class=\"string\">'p'</span>, &#123;<span class=\"attr\">key</span>: <span class=\"string\">'a'</span>, <span class=\"attr\">style</span>: &#123;<span class=\"attr\">color</span>: <span class=\"string\">'blue'</span>&#125;&#125;, <span class=\"string\">'节点1'</span>),</span><br><span class=\"line\">      createElement(<span class=\"string\">'p'</span>, &#123;<span class=\"attr\">key</span>: <span class=\"string\">'b'</span>, <span class=\"string\">'@click'</span>: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;alert(xx)&#125;&#125;, <span class=\"string\">'节点2'</span>),</span><br><span class=\"line\">      createElement(<span class=\"string\">'p'</span>, &#123;<span class=\"attr\">key</span>: <span class=\"string\">'c'</span>, <span class=\"string\">'class'</span>: <span class=\"string\">'item-header'</span>&#125;, <span class=\"string\">'节点3'</span>),</span><br><span class=\"line\">      createElement(<span class=\"string\">'p'</span>, &#123;<span class=\"attr\">key</span>: <span class=\"string\">'d'</span>&#125;, <span class=\"string\">'节点4'</span>)</span><br><span class=\"line\">    ])</span><br></pre></td></tr></table></figure>\n<h2 id=\"虚拟dom的渲染\"><a href=\"#虚拟dom的渲染\" class=\"headerlink\" title=\"虚拟dom的渲染\"></a>虚拟dom的渲染</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">render(vnode, <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'app'</span>))</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 渲染</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span>(<span class=\"params\">vnode, container</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (container.vnode) &#123;</span><br><span class=\"line\">       patch(container.vnode, vnode, container)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  \t   mount(vnode, container)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    container.vnode = vnode;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 首次挂载元素</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mount</span>(<span class=\"params\">vnode, container</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> &#123;flag&#125; = vnode</span><br><span class=\"line\">  <span class=\"comment\">// 标签节点</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (flag === <span class=\"string\">'html'</span>) &#123;</span><br><span class=\"line\">    mountElement(vnode, container)</span><br><span class=\"line\">  <span class=\"comment\">// 文本节点</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (flag === <span class=\"string\">'text'</span>) &#123;</span><br><span class=\"line\">    mountText(vnode, container)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"标签节点的属性挂载\"><a href=\"#标签节点的属性挂载\" class=\"headerlink\" title=\"标签节点的属性挂载\"></a>标签节点的属性挂载</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (data) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> key <span class=\"keyword\">in</span> data) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 节点，名字，老值，新值</span></span><br><span class=\"line\">        patchData(dom, key, <span class=\"literal\">null</span>, data[key])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"标签节点的子元素挂载\"><a href=\"#标签节点的子元素挂载\" class=\"headerlink\" title=\"标签节点的子元素挂载\"></a>标签节点的子元素挂载</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (childrenFlag !== childType.EMPTY) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (childrenFlag === childType.SINGLE) &#123;</span><br><span class=\"line\">        mount(children, dom)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (childrenFlag === childType.MULTIPLE) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; children.length; i++) &#123;</span><br><span class=\"line\">            mount(children[i], dom)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"虚拟dom核心：diff\"><a href=\"#虚拟dom核心：diff\" class=\"headerlink\" title=\"虚拟dom核心：diff\"></a>虚拟dom核心：diff</h2><p>这是另一位同学分享的<a href=\"http://10.199.140.56/book/part1/react/diff.html\" target=\"_blank\" rel=\"noopener\">虚拟dom的diff算法浅析</a></p>\n<ul>\n<li>节点分标签节点和文本节点，所以需要flag来判断</li>\n<li>childrenFlag判断不同的子元素</li>\n<li>判断后进行不同形式的渲染</li>\n<li>难点：diff两个数组，例子：[axxbxxc] -&gt;  [cxxaxxb] ，虚拟dom从axxbxxc变为cxxaxxb，c一开始不需要移动位置，只管插入dom中，ab俩是按字母顺序所以b就不需要移动位置，但a到c后面了不是按字母顺序，所以需要移动位置。</li>\n<li>[abcd] -&gt; [acd]，react或vue的key对应list数组里每个元素，如果删掉一个b，还用index下标作为key的话，c会取代原来b的位置，这时候如果是选中c,效果就会变成d被选中，所以尽量不要用index作为key。</li>\n</ul>\n<p><a href=\"https://github.com/nameit/simple-vdom\" target=\"_blank\" rel=\"noopener\">简易虚拟dom源码</a></p>\n"},{"title":"promise","_content":"\n\n# 一 前言\n\n一直对promise一知半解，当阅读到[其他文章](https://segmentfault.com/a/1190000007032448#articleHeader16)时对它有个明确的认识。\n\n# 二 什么是promise\n\n以下是MDN对Promise的定义\n\n>The Promise object is used for asynchronous computations. A Promise represents a single asynchronous operation that hasn't completed yet, but is expected in the future.\n译文：Promise对象用于异步操作，它表示一个尚未完成且预计在未来完成的异步操作。\n\n那么什么是异步操作？在学习promise之前需要把这个概念搞明白，下面将抽离一章专门介绍。\n\n## 同步与异步\n\n我们知道，JavaScript的执行环境是「单线程」。 \n所谓单线程，是指JS引擎中负责解释和执行JavaScript代码的线程只有一个，也就是一次只能完成一项任务，这个任务执行完后才能执行下一个，它会「阻塞」其他任务。这个任务可称为主线程。 \n但实际上还有其他线程，如事件触发线程、ajax请求线程等。\n\n这也就引发了同步和异步的问题。\n\n### 同步\n\n同步模式，即上述所说的单线程模式，**一次**只能执行**一个**任务，函数调用后需等到函数执行结束，返回执行的结果，才能进行下一个任务。如果这个任务执行的时间较长，就会导致「**线程阻塞**」。\n\n```\n/* 例2.1 */\nvar x = true;\nwhile(x);\nconsole.log(\"don't carry out\");    //不会执行\n```\n\n上面的例子即同步模式，其中的while是一个死循环，它会阻塞进程，因此第三句console不会执行。 \n同步模式比较简单，也较容易编写。但问题也显而易见，如果请求的时间较长，而阻塞了后面代码的执行，体验是很不好的。因此对于一些耗时的操作，异步模式则是更好的选择。\n\n### 异步\n\n下面就来看看异步模式。 \n异步模式，即与同步模式相反，可以一起执行**多个任务**，函数调用后不会立即返回执行的结果，如果任务A需要等待，可先执行任务B，等到任务A结果返回后再继续回调。 \n最常见的异步模式就数定时器了，我们来看看以下的例子。\n\n```\n/* 例2.2 */\nsetTimeout(function() {\n    console.log('taskA, asynchronous');\n}, 0);\nconsole.log('taskB, synchronize');\n//while(true);\n\n-------ouput-------\ntaskB, synchronize\ntaskA, asynchronous\n```\n\n我们可以看到，定时器延时的时间明明为0，但taskA还是晚于taskB执行。这是为什么呢？由于定时器是异步的，**异步任务会在当前脚本的所有同步任务执行完才会执行**。如果同步代码中含有死循环，即将上例的注释去掉，那么这个异步任务就不会执行，因为同步任务阻塞了进程。\n\n### 回调函数\n\n提起异步，就不得不谈谈回调函数了。上例中，setTimeout里的function便是回调函数。可以简单理解为：（执行完）回（来）调（用）的函数。\n以下是WikiPedia对于callback的定义。\n\n>In computer programming, a callback is a piece of executable code that is passed as an argument to other code, which is expected to call back (execute) the argument at some convenient time.\n\n可以看出，回调函数是一段可执行的代码段，它以「参数」的形式传递给其他代码，在其合适的时间执行这段（回调函数）的代码。\n\nWikiPedia同时提到\n\n>The invocation may be immediate as in a synchronous callback, or it might happen at a later time as in an asynchronous callback.\n\n也就是说，回调函数不仅可以用于异步调用，一般同步的场景也可以用回调。在同步调用下，回调函数一般是最后执行的。而异步调用下，可能一段时间后执行或不执行（未达到执行的条件）。\n\n```\n/* 例2.3 */\n/******************同步回调******************/\nvar fun1 = function(callback) {\n    //do something\n    console.log(\"before callback\");\n    (callback && typeof(callback) === 'function') && callback();\n    console.log(\"after callback\");\n}\nvar fun2 = function(param) {\n    //do something\n    var start = new Date();\n    while((new Date() - start) < 3000) { //delay 3s\n    }\n    console.log(\"I'm callback\");\n}\nfun1(fun2);\n\n-------output--------\nbefore callback\n//after 3s\nI’m callback\nafter callback\n```\n由于是同步回调，会阻塞后面的代码，如果fun2是个死循环，后面的代码就不执行了。\n\n上一小节中setTimeout就是常见的异步回调，另外常见的异步回调即ajax请求。\n\n```\n/* 例2.4 */\n/******************异步回调******************/\nfunction request(url, param, successFun, errorFun) {\n    $.ajax({\n        type: 'GET',\n        url: url,\n        param: param,\n        async: true,    //默认为true,即异步请求；false为同步请求\n        success: successFun,\n        error: errorFun\n    });\n}\nrequest('test.html', '', function(data) {\n    //请求成功后的回调函数，通常是对请求回来的数据进行处理\n    console.log('请求成功啦, 这是返回的数据:', data);\n},function(error) {\n    console.log('sorry, 请求失败了, 这是失败信息:', error);\n});\n```\n\n## 为什么使用Promise\n\n说完了以上基本概念，我们就可以继续学习Promise了。\n上面提到，Promise对象是用于异步操作的。既然我们可以使用异步回调来进行异步操作，为什么还要引入一个Promise新概念，还要花时间学习它呢？不要着急，下面就来谈谈Promise的过人之处。\n我们先看看下面的demo，利用Promise改写例2.4的异步回调。\n\n```\n/* 例2.5 */\nfunction sendRequest(url, param) {\n    return new Promise(function (resolve, reject) {\n        request(url, param, resolve, reject);\n    });\n}\n\nsendRequest('test.html', '').then(function(data) {\n    //异步操作成功后的回调\n    console.log('请求成功啦, 这是返回的数据:', data);\n}, function(error) {\n    //异步操作失败后的回调\n    console.log('sorry, 请求失败了, 这是失败信息:', error);\n});\n```\n这么一看，并没有什么区别，还比上面的异步回调复杂，得先新建Promise再定义其回调。其实，Promise的真正强大之处在于它的多重链式调用，可以避免层层嵌套回调。如果我们在第一次ajax请求后，还要用它返回的结果再次请求呢？\n\n```\n/* 例2.6 */\nrequest('test1.html', '', function(data1) {\n    console.log('第一次请求成功, 这是返回的数据:', data1);\n    request('test2.html', data1, function (data2) {\n        console.log('第二次请求成功, 这是返回的数据:', data2);\n        request('test3.html', data2, function (data3) {\n            console.log('第三次请求成功, 这是返回的数据:', data3);\n            //request... 继续请求\n        }, function(error3) {\n            console.log('第三次请求失败, 这是失败信息:', error3);\n        });\n    }, function(error2) {\n        console.log('第二次请求失败, 这是失败信息:', error2);\n    });\n}, function(error1) {\n    console.log('第一次请求失败, 这是失败信息:', error1);\n});\n```\n\n以上出现了多层回调嵌套，有种晕头转向的感觉。这也就是我们常说的厄运回调金字塔（Pyramid of Doom），编程体验十分不好。而使用Promise，我们就可以利用then进行「链式回调」，将异步操作以同步操作的流程表示出来。\n\n```\n/* 例2.7 */\nsendRequest('test1.html', '').then(function(data1) {\n    console.log('第一次请求成功, 这是返回的数据:', data1);\n}).then(function(data2) {\n    console.log('第二次请求成功, 这是返回的数据:', data2);\n}).then(function(data3) {\n    console.log('第三次请求成功, 这是返回的数据:', data3);\n}).catch(function(error) {\n    //用catch捕捉前面的错误\n    console.log('sorry, 请求失败了, 这是失败信息:', error);\n});\n```\n是不是明显清晰很多？孰优孰略也无需多说了吧~下面就让我们真正进入Promise的学习。\n\n# 三 Promise的基本用法\n\n## 基本用法\n\n上一小节我们认识了promise长什么样，但对它用到的resolve、reject、then、catch想必还不理解。下面我们一步步学习。\n\nPromise对象代表一个未完成、但预计将来会完成的操作。\n它有以下三种状态：\n\n- pending：初始值，不是fulfilled，也不是rejected\n- fulfilled：代表操作成功\n- rejected：代表操作失败\n\nPromise有两种状态改变的方式，既可以从pending转变为fulfilled，也可以从pending转变为rejected。一旦状态改变，就「凝固」了，会一直保持这个状态，不会再发生变化。当状态发生变化，promise.then绑定的函数就会被调用。\n注意：Promise一旦新建就会「立即执行」，无法取消。这也是它的缺点之一。\n下面就通过例子进一步讲解。\n\n```\n/* 例3.1 */\n//构建Promise\nvar promise = new Promise(function (resolve, reject) {\n    if (/* 异步操作成功 */) {\n        resolve(data);\n    } else {\n        /* 异步操作失败 */\n        reject(error);\n    }\n});\n```\n\n类似构建对象，我们使用new来构建一个Promise。Promise接受一个「函数」作为参数，该函数的两个参数分别是resolve和reject。这两个函数就是就是「回调函数」，由JavaScript引擎提供。\n\nresolve函数的作用：在异步操作成功时调用，并将异步操作的结果，作为参数传递出去； \nreject函数的作用：在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。\n\nPromise实例生成以后，可以用then方法指定resolved状态和reject状态的回调函数。\n\n```\n/* 接例3.1 */\npromise.then(onFulfilled, onRejected);\n\npromise.then(function(data) {\n  // do something when success\n}, function(error) {\n  // do something when failure\n});\n```\n\nthen方法会返回一个Promise。它有两个参数，分别为Promise从pending变为fulfilled和rejected时的回调函数（第二个参数非必选）。这两个函数都**接受Promise对象传出的值作为参数**。\n简单来说，then就是定义resolve和reject函数的，其resolve参数相当于：\n\n```\nfunction resolveFun(data) {\n    //data为promise传出的值\n}\n```\n\n而新建Promise中的'resolve(data)'，则相当于执行resolveFun函数。\nPromise新建后就会立即执行。而then方法中指定的回调函数，将在当前脚本所有同步任务执行完才会执行。如下例：\n\n```\n/* 例3.2 */\nvar promise = new Promise(function(resolve, reject) {\n  console.log('before resolved');\n  resolve();\n  console.log('after resolved');\n});\n\npromise.then(function() {\n  console.log('resolved');\n});\n\nconsole.log('outer');\n\n-------output-------\nbefore resolved\nafter resolved\nouter\nresolved\n```\n\n由于resolve指定的是异步操作成功后的回调函数，它需要等所有同步代码执行后才会执行，因此最后打印'resolved'，这个和例2.2是一样的道理。\n\n## 基本API\n\n### .then()\n\n\n> 语法：Promise.prototype.then(onFulfilled, onRejected)\n\n\n对promise添加onFulfilled和onRejected回调，并返回的是一个新的Promise实例（不是原来那个Promise实例），且返回值将作为参数传入这个新Promise的resolve函数。\n\n因此，我们可以使用链式写法，如上文的例2.7。由于前一个回调函数，返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。\n\n### .catch()\n\n> 语法：Promise.prototype.catch(onRejected)\n\n该方法是.then(undefined, onRejected)的别名，用于指定发生错误时的回调函数。\n\n```\n/* 例3.3 */\npromise.then(function(data) {\n    console.log('success');\n}).catch(function(error) {\n    console.log('error', error);\n});\n\n/*******等同于*******/\npromise.then(function(data) {\n    console.log('success');\n}).then(undefined, function(error) {\n    console.log('error', error);\n});\n```\n\n```\n/* 例3.4 */\nvar promise = new Promise(function (resolve, reject) {\n    throw new Error('test');\n});\n/*******等同于*******/\nvar promise = new Promise(function (resolve, reject) {\n    reject(new Error('test'));\n});\n\n//用catch捕获\npromise.catch(function (error) {\n    console.log(error);\n});\n-------output-------\nError: test\n```\n\n从上例可以看出，reject方法的作用，等同于抛错。\n\npromise对象的错误，会一直向后传递，直到被捕获。即错误总会被下一个catch所捕获。then方法指定的回调函数，若抛出错误，也会被下一个catch捕获。catch中也能抛错，则需要后面的catch来捕获。\n\n```\n/* 例3.5 */\nsendRequest('test.html').then(function(data1) {\n    //do something\n}).then(function (data2) {\n    //do something\n}).catch(function (error) {\n    //处理前面三个Promise产生的错误\n});\n```\n\n上文提到过，promise状态一旦改变就会凝固，不会再改变。因此promise一旦fulfilled了，再抛错，也不会变为rejected，就不会被catch了。\n\n```\n/* 例3.6 */\nvar promise = new Promise(function(resolve, reject) {\n  resolve();\n  throw 'error';\n});\n\npromise.catch(function(e) {\n   console.log(e);      //This is never called\n});\n```\n\n如果没有使用catch方法指定处理错误的回调函数，Promise对象抛出的错误不会传递到外层代码，即不会有任何反应（Chrome会抛错），这是Promise的另一个缺点。\n\n```\n/* 例3.7 */\nvar promise = new Promise(function (resolve, reject) {\n    resolve(x);\n});\npromise.then(function (data) {\n    console.log(data);\n});\n```\n![chrome不报错](https://segmentfault.com/img/bVDEBJ?w=1466&h=286 \"chrome不报错\")\n![safari报错](https://segmentfault.com/img/bVDEZp?w=530&h=151 \"safari报错\")\n![safari报错](https://segmentfault.com/img/bVDE0o?w=388&h=145 \"safari报错\")\n只有Chrome会抛错，且promise状态变为rejected，Firefox和Safari中错误不会被捕获，也不会传递到外层代码，最后没有任何输出，promise状态也变为rejected。\n\n### .all()\n\n> 语法：Promise.all(iterable)\n\n该方法用于将多个Promise实例，包装成一个新的Promise实例。\n\n> var p = Promise.all([p1, p2, p3]);\n\nPromise.all方法接受一个数组（或具有Iterator接口）作参数，数组中的对象（p1、p2、p3）均为promise实例（如果不是一个promise，该项会被用Promise.resolve转换为一个promise)。它的状态由这三个promise实例决定。\n\n- 当p1, p2, p3状态都变为fulfilled，p的状态才会变为fulfilled，并将三个promise返回的结果，按参数的顺序（而不是 resolved的顺序）存入数组，传给p的回调函数，如例3.8。\n- 当p1, p2, p3其中之一状态变为rejected，p的状态也会变为rejected，并把第一个被reject的promise的返回值，传给p的回调函数，如例3.9。\n\n```\n/* 例3.8 */\nvar p1 = new Promise(function (resolve, reject) {\n    setTimeout(resolve, 3000, \"first\");\n});\nvar p2 = new Promise(function (resolve, reject) {\n    resolve('second');\n});\nvar p3 = new Promise((resolve, reject) => {\n  setTimeout(resolve, 1000, \"third\");\n}); \n\nPromise.all([p1, p2, p3]).then(function(values) { \n  console.log(values); \n});\n\n-------output-------\n//约 3s 后\n[\"first\", \"second\", \"third\"] \n```\n\n```\n/* 例3.9 */\nvar p1 = new Promise((resolve, reject) => { \n  setTimeout(resolve, 1000, \"one\"); \n}); \nvar p2 = new Promise((resolve, reject) => { \n  setTimeout(reject, 2000, \"two\"); \n});\nvar p3 = new Promise((resolve, reject) => {\n  reject(\"three\");\n});\n\nPromise.all([p1, p2, p3]).then(function (value) {\n    console.log('resolve', value);\n}, function (error) {\n    console.log('reject', error);    // => reject three\n});\n\n-------output-------\nreject three\n```\n\n这多个 promise 是同时开始、并行执行的，而不是顺序执行。从下面例子可以看出。如果一个个执行，那至少需要 1+32+64+128\n\n```\n/* 例3.10 */\nfunction timerPromisefy(delay) {\n    return new Promise(function (resolve) {\n        setTimeout(function () {\n            resolve(delay);\n        }, delay);\n    });\n}\nvar startDate = Date.now();\n\nPromise.all([\n    timerPromisefy(1),\n    timerPromisefy(32),\n    timerPromisefy(64),\n    timerPromisefy(128)\n]).then(function (values) {\n    console.log(Date.now() - startDate + 'ms');\n    console.log(values);\n});\n-------output-------\n133ms       //不一定，但大于128ms\n[1,32,64,128]\n```\n\n### .race()\n\n> 语法：Promise.race(iterable)\n\n该方法同样是将多个Promise实例，包装成一个新的Promise实例。\n\n> var p = Promise.race([p1, p2, p3]);\n\nPromise.race方法同样接受一个数组（或具有Iterator接口）作参数。当p1, p2, p3中有一个实例的状态发生改变（变为fulfilled或rejected），p的状态就跟着改变。并把第一个改变状态的promise的返回值，传给p的回调函数。\n\n```\n/* 例3.11 */\nvar p1 = new Promise(function(resolve, reject) { \n    setTimeout(reject, 500, \"one\"); \n});\nvar p2 = new Promise(function(resolve, reject) { \n    setTimeout(resolve, 100, \"two\"); \n});\n\nPromise.race([p1, p2]).then(function(value) {\n    console.log('resolve', value); \n}, function(error) {\n    //not called\n    console.log('reject', error); \n});\n-------output-------\nresolve two\n\nvar p3 = new Promise(function(resolve, reject) { \n    setTimeout(resolve, 500, \"three\");\n});\nvar p4 = new Promise(function(resolve, reject) { \n    setTimeout(reject, 100, \"four\"); \n});\n\nPromise.race([p3, p4]).then(function(value) {\n    //not called\n    console.log('resolve', value);              \n}, function(error) {\n    console.log('reject', error); \n});\n-------output-------\nreject four\n```\n\n在第一个promise对象变为resolve后，并不会取消其他promise对象的执行，如下例\n\n\n```\n/* 例3.12 */\nvar fastPromise = new Promise(function (resolve) {\n    setTimeout(function () {\n        console.log('fastPromise');\n        resolve('resolve fastPromise');\n    }, 100);\n});\nvar slowPromise = new Promise(function (resolve) {\n    setTimeout(function () {\n        console.log('slowPromise');\n        resolve('resolve slowPromise');\n    }, 1000);\n});\n// 第一个promise变为resolve后程序停止\nPromise.race([fastPromise, slowPromise]).then(function (value) {\n    console.log(value);    // => resolve fastPromise\n});\n-------output-------\nfastPromise\nresolve fastPromise\nslowPromise     //仍会执行\n```\n\n### .resolve()\n\n语法：\n```\nPromise.resolve(value);\nPromise.resolve(promise);\nPromise.resolve(thenable);\n```\n\n它可以看做new Promise()的快捷方式。\n\n```\nPromise.resolve('Success');\n\n/*******等同于*******/\nnew Promise(function (resolve) {\n    resolve('Success');\n});\n```\n\n这段代码会让这个Promise对象立即进入resolved状态，并将结果success传递给then指定的onFulfilled回调函数。由于Promise.resolve()也是返回Promise对象，因此可以用.then()处理其返回值。\n\n```\n/* 例3.13 */\nPromise.resolve('success').then(function (value) {\n    console.log(value);\n});\n-------output-------\nSuccess\n```\n\n```\n/* 例3.14 */\n//Resolving an array\nPromise.resolve([1,2,3]).then(function(value) {\n  console.log(value[0]);    // => 1\n});\n\n//Resolving a Promise\nvar p1 = Promise.resolve('this is p1');\nvar p2 = Promise.resolve(p1);\np2.then(function (value) {\n    console.log(value);     // => this is p1\n});\n```\n\nPromise.resolve()的另一个作用就是将thenable对象（即带有then方法的对象）转换为promise对象。\n\n```\n/* 例3.15 */\nvar p1 = Promise.resolve({ \n    then: function (resolve, reject) { \n        resolve(\"this is an thenable object!\");\n    }\n});\nconsole.log(p1 instanceof Promise);     // => true\n\np1.then(function(value) {\n    console.log(value);     // => this is an thenable object!\n  }, function(e) {\n    //not called\n});\n```\n\n再看下面两个例子，无论是在什么时候抛异常，只要promise状态变成resolved或rejected，状态不会再改变，这和新建promise是一样的。\n\n```\n/* 例3.16 */\n//在回调函数前抛异常\nvar p1 = { \n    then: function(resolve) {\n      throw new Error(\"error\");\n      resolve(\"Resolved\");\n    }\n};\n\nvar p2 = Promise.resolve(p1);\np2.then(function(value) {\n    //not called\n}, function(error) {\n    console.log(error);       // => Error: error\n});\n\n//在回调函数后抛异常\nvar p3 = { \n    then: function(resolve) {\n        resolve(\"Resolved\");\n        throw new Error(\"error\");\n    }\n};\n\nvar p4 = Promise.resolve(p3);\np4.then(function(value) {\n    console.log(value);     // => Resolved\n}, function(error) {\n    //not called\n});\n```\n\n### .reject()\n\n> 语法：Promise.reject(reason)\n\n这个方法和上述的Promise.resolve()类似，它也是new Promise()的快捷方式。\n\n```\nPromise.reject(new Error('error'));\n\n/*******等同于*******/\nnew Promise(function (resolve, reject) {\n    reject(new Error('error'));\n});\n```\n\n这段代码会让这个Promise对象立即进入rejected状态，并将错误对象传递给then指定的onRejected回调函数。\n\n\n# Promise常见问题\n\n经过上一章的学习，相信大家已经学会使用Promise。\n总结一下创建promise的流程：\n\n1. 使用new Promise(fn)或者它的快捷方式Promise.resolve()、Promise.reject()，返回一个promise对象\n2. 在fn中指定异步的处理\n处理结果正常，调用resolve\n处理结果错误，调用reject\n\n如果使用ES6的箭头函数，将会使写法更加简单清晰。\n\n这一章节，将会用例子的形式，以说明promise使用过程中的注意点及容易犯的错误。\n\n**情景1**：reject 和 catch 的区别\n- promise.then(onFulfilled, onRejected)\n在onFulfilled中发生异常的话，在onRejected中是捕获不到这个异常的。\n- promise.then(onFulfilled).catch(onRejected)\n.then中产生的异常能在.catch中捕获\n\n一般情况，还是建议使用第二种，因为能捕获之前的所有异常。当然了，第二种的.catch()也可以使用.then()表示，它们本质上是没有区别的，.catch === .then(null, onRejected)\n\n**情景2**：如果在then中抛错，而没有对错误进行处理（即catch），那么会一直保持reject状态，直到catch了错误\n\n```\n/* 例4.1 */\nfunction taskA() {\n    console.log(x);\n    console.log(\"Task A\");\n}\nfunction taskB() {\n    console.log(\"Task B\");\n}\nfunction onRejected(error) {\n    console.log(\"Catch Error: A or B\", error);\n}\nfunction finalTask() {\n    console.log(\"Final Task\");\n}\nvar promise = Promise.resolve();\npromise\n    .then(taskA)\n    .then(taskB)\n    .catch(onRejected)\n    .then(finalTask);\n    \n-------output-------\nCatch Error: A or B,ReferenceError: x is not defined\nFinal Task\n```\n\n```\n/* 例4.2 */\nfunction taskA() {\n    console.log(x);\n    console.log(\"Task A\");\n}\nfunction taskB() {\n    console.log(\"Task B\");\n}\nfunction onRejectedA(error) {\n    console.log(\"Catch Error: A\", error);\n}\nfunction onRejectedB(error) {\n    console.log(\"Catch Error: B\", error);\n}\nfunction finalTask() {\n    console.log(\"Final Task\");\n}\nvar promise = Promise.resolve();\npromise\n    .then(taskA)\n    .catch(onRejectedA)\n    .then(taskB)\n    .catch(onRejectedB)\n    .then(finalTask);\n    \n-------output-------\nCatch Error: A ReferenceError: x is not defined\nTask B\nFinal Task\n```\n\n将例4.2与4.1对比，在taskA后多了对A的处理，因此，A抛错时，会按照A会按照 taskA → onRejectedA → taskB → finalTask这个流程来处理，此时taskB是正常执行的。\n\n**情景3**：每次调用then都会返回一个新创建的promise对象，而then内部只是返回的数据\n```\n/* 例4.3 */\n//方法1：对同一个promise对象同时调用 then 方法\nvar p1 = new Promise(function (resolve) {\n    resolve(100);\n});\np1.then(function (value) {\n    return value * 2;\n});\np1.then(function (value) {\n    return value * 2;\n});\np1.then(function (value) {\n    console.log(\"finally: \" + value);\n});\n-------output-------\nfinally: 100\n\n//方法2：对 then 进行 promise chain 方式进行调用\nvar p2 = new Promise(function (resolve) {\n    resolve(100);\n});\np2.then(function (value) {\n    return value * 2;\n}).then(function (value) {\n    return value * 2;\n}).then(function (value) {\n    console.log(\"finally: \" + value);\n});\n-------output-------\nfinally: 400\n```\n\n第一种方法中，then的调用几乎是同时开始执行的，且传给每个then的value都是100，这种方法应当避免。方法二才是正确的链式调用。\n因此容易出现下面的错误写法：\n\n```\n/* 例4.4 */\nfunction badAsyncCall(data) {\n    var promise = Promise.resolve(data);\n    promise.then(function(value) {\n        //do something\n        return value + 1;\n    });\n    return promise;\n}\nbadAsyncCall(10).then(function(value) {\n   console.log(value);          //想要得到11，实际输出10\n});\n-------output-------\n10\n```\n\n正确的写法应该是：\n\n```\n/* 改写例4.4 */\nfunction goodAsyncCall(data) {\n    var promise = Promise.resolve(data);\n    return promise.then(function(value) {\n        //do something\n        return value + 1;\n    });\n}\ngoodAsyncCall(10).then(function(value) {\n   console.log(value);\n});\n-------output-------\n11\n```\n\n**情景4**：在异步回调中抛错，不会被catch到\n```\n// Errors thrown inside asynchronous functions will act like uncaught errors\nvar promise = new Promise(function(resolve, reject) {\n  setTimeout(function() {\n    throw 'Uncaught Exception!';\n  }, 1000);\n});\n\npromise.catch(function(e) {\n  console.log(e);       //This is never called\n});\n```\n\n**情景5**： promise状态变为resove或reject，就凝固了，不会再改变\n```\nconsole.log(1);\nnew Promise(function (resolve, reject){\n    reject();\n    setTimeout(function (){\n        resolve();            //not called\n    }, 0);\n}).then(function(){\n    console.log(2);\n}, function(){\n    console.log(3);\n});\nconsole.log(4);\n\n-------output-------\n1\n4\n3\n```\n\n# 结语\n通过阅读这篇文章，让我对promise有个大概的认识。文章出处：[https://segmentfault.com/a/1190000007032448#articleHeader16](https://segmentfault.com/a/1190000007032448#articleHeader16)","source":"_posts/promise.md","raw":"title: promise\ntags: [promise,js]\ncategories: 前端\n---\n\n\n# 一 前言\n\n一直对promise一知半解，当阅读到[其他文章](https://segmentfault.com/a/1190000007032448#articleHeader16)时对它有个明确的认识。\n\n# 二 什么是promise\n\n以下是MDN对Promise的定义\n\n>The Promise object is used for asynchronous computations. A Promise represents a single asynchronous operation that hasn't completed yet, but is expected in the future.\n译文：Promise对象用于异步操作，它表示一个尚未完成且预计在未来完成的异步操作。\n\n那么什么是异步操作？在学习promise之前需要把这个概念搞明白，下面将抽离一章专门介绍。\n\n## 同步与异步\n\n我们知道，JavaScript的执行环境是「单线程」。 \n所谓单线程，是指JS引擎中负责解释和执行JavaScript代码的线程只有一个，也就是一次只能完成一项任务，这个任务执行完后才能执行下一个，它会「阻塞」其他任务。这个任务可称为主线程。 \n但实际上还有其他线程，如事件触发线程、ajax请求线程等。\n\n这也就引发了同步和异步的问题。\n\n### 同步\n\n同步模式，即上述所说的单线程模式，**一次**只能执行**一个**任务，函数调用后需等到函数执行结束，返回执行的结果，才能进行下一个任务。如果这个任务执行的时间较长，就会导致「**线程阻塞**」。\n\n```\n/* 例2.1 */\nvar x = true;\nwhile(x);\nconsole.log(\"don't carry out\");    //不会执行\n```\n\n上面的例子即同步模式，其中的while是一个死循环，它会阻塞进程，因此第三句console不会执行。 \n同步模式比较简单，也较容易编写。但问题也显而易见，如果请求的时间较长，而阻塞了后面代码的执行，体验是很不好的。因此对于一些耗时的操作，异步模式则是更好的选择。\n\n### 异步\n\n下面就来看看异步模式。 \n异步模式，即与同步模式相反，可以一起执行**多个任务**，函数调用后不会立即返回执行的结果，如果任务A需要等待，可先执行任务B，等到任务A结果返回后再继续回调。 \n最常见的异步模式就数定时器了，我们来看看以下的例子。\n\n```\n/* 例2.2 */\nsetTimeout(function() {\n    console.log('taskA, asynchronous');\n}, 0);\nconsole.log('taskB, synchronize');\n//while(true);\n\n-------ouput-------\ntaskB, synchronize\ntaskA, asynchronous\n```\n\n我们可以看到，定时器延时的时间明明为0，但taskA还是晚于taskB执行。这是为什么呢？由于定时器是异步的，**异步任务会在当前脚本的所有同步任务执行完才会执行**。如果同步代码中含有死循环，即将上例的注释去掉，那么这个异步任务就不会执行，因为同步任务阻塞了进程。\n\n### 回调函数\n\n提起异步，就不得不谈谈回调函数了。上例中，setTimeout里的function便是回调函数。可以简单理解为：（执行完）回（来）调（用）的函数。\n以下是WikiPedia对于callback的定义。\n\n>In computer programming, a callback is a piece of executable code that is passed as an argument to other code, which is expected to call back (execute) the argument at some convenient time.\n\n可以看出，回调函数是一段可执行的代码段，它以「参数」的形式传递给其他代码，在其合适的时间执行这段（回调函数）的代码。\n\nWikiPedia同时提到\n\n>The invocation may be immediate as in a synchronous callback, or it might happen at a later time as in an asynchronous callback.\n\n也就是说，回调函数不仅可以用于异步调用，一般同步的场景也可以用回调。在同步调用下，回调函数一般是最后执行的。而异步调用下，可能一段时间后执行或不执行（未达到执行的条件）。\n\n```\n/* 例2.3 */\n/******************同步回调******************/\nvar fun1 = function(callback) {\n    //do something\n    console.log(\"before callback\");\n    (callback && typeof(callback) === 'function') && callback();\n    console.log(\"after callback\");\n}\nvar fun2 = function(param) {\n    //do something\n    var start = new Date();\n    while((new Date() - start) < 3000) { //delay 3s\n    }\n    console.log(\"I'm callback\");\n}\nfun1(fun2);\n\n-------output--------\nbefore callback\n//after 3s\nI’m callback\nafter callback\n```\n由于是同步回调，会阻塞后面的代码，如果fun2是个死循环，后面的代码就不执行了。\n\n上一小节中setTimeout就是常见的异步回调，另外常见的异步回调即ajax请求。\n\n```\n/* 例2.4 */\n/******************异步回调******************/\nfunction request(url, param, successFun, errorFun) {\n    $.ajax({\n        type: 'GET',\n        url: url,\n        param: param,\n        async: true,    //默认为true,即异步请求；false为同步请求\n        success: successFun,\n        error: errorFun\n    });\n}\nrequest('test.html', '', function(data) {\n    //请求成功后的回调函数，通常是对请求回来的数据进行处理\n    console.log('请求成功啦, 这是返回的数据:', data);\n},function(error) {\n    console.log('sorry, 请求失败了, 这是失败信息:', error);\n});\n```\n\n## 为什么使用Promise\n\n说完了以上基本概念，我们就可以继续学习Promise了。\n上面提到，Promise对象是用于异步操作的。既然我们可以使用异步回调来进行异步操作，为什么还要引入一个Promise新概念，还要花时间学习它呢？不要着急，下面就来谈谈Promise的过人之处。\n我们先看看下面的demo，利用Promise改写例2.4的异步回调。\n\n```\n/* 例2.5 */\nfunction sendRequest(url, param) {\n    return new Promise(function (resolve, reject) {\n        request(url, param, resolve, reject);\n    });\n}\n\nsendRequest('test.html', '').then(function(data) {\n    //异步操作成功后的回调\n    console.log('请求成功啦, 这是返回的数据:', data);\n}, function(error) {\n    //异步操作失败后的回调\n    console.log('sorry, 请求失败了, 这是失败信息:', error);\n});\n```\n这么一看，并没有什么区别，还比上面的异步回调复杂，得先新建Promise再定义其回调。其实，Promise的真正强大之处在于它的多重链式调用，可以避免层层嵌套回调。如果我们在第一次ajax请求后，还要用它返回的结果再次请求呢？\n\n```\n/* 例2.6 */\nrequest('test1.html', '', function(data1) {\n    console.log('第一次请求成功, 这是返回的数据:', data1);\n    request('test2.html', data1, function (data2) {\n        console.log('第二次请求成功, 这是返回的数据:', data2);\n        request('test3.html', data2, function (data3) {\n            console.log('第三次请求成功, 这是返回的数据:', data3);\n            //request... 继续请求\n        }, function(error3) {\n            console.log('第三次请求失败, 这是失败信息:', error3);\n        });\n    }, function(error2) {\n        console.log('第二次请求失败, 这是失败信息:', error2);\n    });\n}, function(error1) {\n    console.log('第一次请求失败, 这是失败信息:', error1);\n});\n```\n\n以上出现了多层回调嵌套，有种晕头转向的感觉。这也就是我们常说的厄运回调金字塔（Pyramid of Doom），编程体验十分不好。而使用Promise，我们就可以利用then进行「链式回调」，将异步操作以同步操作的流程表示出来。\n\n```\n/* 例2.7 */\nsendRequest('test1.html', '').then(function(data1) {\n    console.log('第一次请求成功, 这是返回的数据:', data1);\n}).then(function(data2) {\n    console.log('第二次请求成功, 这是返回的数据:', data2);\n}).then(function(data3) {\n    console.log('第三次请求成功, 这是返回的数据:', data3);\n}).catch(function(error) {\n    //用catch捕捉前面的错误\n    console.log('sorry, 请求失败了, 这是失败信息:', error);\n});\n```\n是不是明显清晰很多？孰优孰略也无需多说了吧~下面就让我们真正进入Promise的学习。\n\n# 三 Promise的基本用法\n\n## 基本用法\n\n上一小节我们认识了promise长什么样，但对它用到的resolve、reject、then、catch想必还不理解。下面我们一步步学习。\n\nPromise对象代表一个未完成、但预计将来会完成的操作。\n它有以下三种状态：\n\n- pending：初始值，不是fulfilled，也不是rejected\n- fulfilled：代表操作成功\n- rejected：代表操作失败\n\nPromise有两种状态改变的方式，既可以从pending转变为fulfilled，也可以从pending转变为rejected。一旦状态改变，就「凝固」了，会一直保持这个状态，不会再发生变化。当状态发生变化，promise.then绑定的函数就会被调用。\n注意：Promise一旦新建就会「立即执行」，无法取消。这也是它的缺点之一。\n下面就通过例子进一步讲解。\n\n```\n/* 例3.1 */\n//构建Promise\nvar promise = new Promise(function (resolve, reject) {\n    if (/* 异步操作成功 */) {\n        resolve(data);\n    } else {\n        /* 异步操作失败 */\n        reject(error);\n    }\n});\n```\n\n类似构建对象，我们使用new来构建一个Promise。Promise接受一个「函数」作为参数，该函数的两个参数分别是resolve和reject。这两个函数就是就是「回调函数」，由JavaScript引擎提供。\n\nresolve函数的作用：在异步操作成功时调用，并将异步操作的结果，作为参数传递出去； \nreject函数的作用：在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。\n\nPromise实例生成以后，可以用then方法指定resolved状态和reject状态的回调函数。\n\n```\n/* 接例3.1 */\npromise.then(onFulfilled, onRejected);\n\npromise.then(function(data) {\n  // do something when success\n}, function(error) {\n  // do something when failure\n});\n```\n\nthen方法会返回一个Promise。它有两个参数，分别为Promise从pending变为fulfilled和rejected时的回调函数（第二个参数非必选）。这两个函数都**接受Promise对象传出的值作为参数**。\n简单来说，then就是定义resolve和reject函数的，其resolve参数相当于：\n\n```\nfunction resolveFun(data) {\n    //data为promise传出的值\n}\n```\n\n而新建Promise中的'resolve(data)'，则相当于执行resolveFun函数。\nPromise新建后就会立即执行。而then方法中指定的回调函数，将在当前脚本所有同步任务执行完才会执行。如下例：\n\n```\n/* 例3.2 */\nvar promise = new Promise(function(resolve, reject) {\n  console.log('before resolved');\n  resolve();\n  console.log('after resolved');\n});\n\npromise.then(function() {\n  console.log('resolved');\n});\n\nconsole.log('outer');\n\n-------output-------\nbefore resolved\nafter resolved\nouter\nresolved\n```\n\n由于resolve指定的是异步操作成功后的回调函数，它需要等所有同步代码执行后才会执行，因此最后打印'resolved'，这个和例2.2是一样的道理。\n\n## 基本API\n\n### .then()\n\n\n> 语法：Promise.prototype.then(onFulfilled, onRejected)\n\n\n对promise添加onFulfilled和onRejected回调，并返回的是一个新的Promise实例（不是原来那个Promise实例），且返回值将作为参数传入这个新Promise的resolve函数。\n\n因此，我们可以使用链式写法，如上文的例2.7。由于前一个回调函数，返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。\n\n### .catch()\n\n> 语法：Promise.prototype.catch(onRejected)\n\n该方法是.then(undefined, onRejected)的别名，用于指定发生错误时的回调函数。\n\n```\n/* 例3.3 */\npromise.then(function(data) {\n    console.log('success');\n}).catch(function(error) {\n    console.log('error', error);\n});\n\n/*******等同于*******/\npromise.then(function(data) {\n    console.log('success');\n}).then(undefined, function(error) {\n    console.log('error', error);\n});\n```\n\n```\n/* 例3.4 */\nvar promise = new Promise(function (resolve, reject) {\n    throw new Error('test');\n});\n/*******等同于*******/\nvar promise = new Promise(function (resolve, reject) {\n    reject(new Error('test'));\n});\n\n//用catch捕获\npromise.catch(function (error) {\n    console.log(error);\n});\n-------output-------\nError: test\n```\n\n从上例可以看出，reject方法的作用，等同于抛错。\n\npromise对象的错误，会一直向后传递，直到被捕获。即错误总会被下一个catch所捕获。then方法指定的回调函数，若抛出错误，也会被下一个catch捕获。catch中也能抛错，则需要后面的catch来捕获。\n\n```\n/* 例3.5 */\nsendRequest('test.html').then(function(data1) {\n    //do something\n}).then(function (data2) {\n    //do something\n}).catch(function (error) {\n    //处理前面三个Promise产生的错误\n});\n```\n\n上文提到过，promise状态一旦改变就会凝固，不会再改变。因此promise一旦fulfilled了，再抛错，也不会变为rejected，就不会被catch了。\n\n```\n/* 例3.6 */\nvar promise = new Promise(function(resolve, reject) {\n  resolve();\n  throw 'error';\n});\n\npromise.catch(function(e) {\n   console.log(e);      //This is never called\n});\n```\n\n如果没有使用catch方法指定处理错误的回调函数，Promise对象抛出的错误不会传递到外层代码，即不会有任何反应（Chrome会抛错），这是Promise的另一个缺点。\n\n```\n/* 例3.7 */\nvar promise = new Promise(function (resolve, reject) {\n    resolve(x);\n});\npromise.then(function (data) {\n    console.log(data);\n});\n```\n![chrome不报错](https://segmentfault.com/img/bVDEBJ?w=1466&h=286 \"chrome不报错\")\n![safari报错](https://segmentfault.com/img/bVDEZp?w=530&h=151 \"safari报错\")\n![safari报错](https://segmentfault.com/img/bVDE0o?w=388&h=145 \"safari报错\")\n只有Chrome会抛错，且promise状态变为rejected，Firefox和Safari中错误不会被捕获，也不会传递到外层代码，最后没有任何输出，promise状态也变为rejected。\n\n### .all()\n\n> 语法：Promise.all(iterable)\n\n该方法用于将多个Promise实例，包装成一个新的Promise实例。\n\n> var p = Promise.all([p1, p2, p3]);\n\nPromise.all方法接受一个数组（或具有Iterator接口）作参数，数组中的对象（p1、p2、p3）均为promise实例（如果不是一个promise，该项会被用Promise.resolve转换为一个promise)。它的状态由这三个promise实例决定。\n\n- 当p1, p2, p3状态都变为fulfilled，p的状态才会变为fulfilled，并将三个promise返回的结果，按参数的顺序（而不是 resolved的顺序）存入数组，传给p的回调函数，如例3.8。\n- 当p1, p2, p3其中之一状态变为rejected，p的状态也会变为rejected，并把第一个被reject的promise的返回值，传给p的回调函数，如例3.9。\n\n```\n/* 例3.8 */\nvar p1 = new Promise(function (resolve, reject) {\n    setTimeout(resolve, 3000, \"first\");\n});\nvar p2 = new Promise(function (resolve, reject) {\n    resolve('second');\n});\nvar p3 = new Promise((resolve, reject) => {\n  setTimeout(resolve, 1000, \"third\");\n}); \n\nPromise.all([p1, p2, p3]).then(function(values) { \n  console.log(values); \n});\n\n-------output-------\n//约 3s 后\n[\"first\", \"second\", \"third\"] \n```\n\n```\n/* 例3.9 */\nvar p1 = new Promise((resolve, reject) => { \n  setTimeout(resolve, 1000, \"one\"); \n}); \nvar p2 = new Promise((resolve, reject) => { \n  setTimeout(reject, 2000, \"two\"); \n});\nvar p3 = new Promise((resolve, reject) => {\n  reject(\"three\");\n});\n\nPromise.all([p1, p2, p3]).then(function (value) {\n    console.log('resolve', value);\n}, function (error) {\n    console.log('reject', error);    // => reject three\n});\n\n-------output-------\nreject three\n```\n\n这多个 promise 是同时开始、并行执行的，而不是顺序执行。从下面例子可以看出。如果一个个执行，那至少需要 1+32+64+128\n\n```\n/* 例3.10 */\nfunction timerPromisefy(delay) {\n    return new Promise(function (resolve) {\n        setTimeout(function () {\n            resolve(delay);\n        }, delay);\n    });\n}\nvar startDate = Date.now();\n\nPromise.all([\n    timerPromisefy(1),\n    timerPromisefy(32),\n    timerPromisefy(64),\n    timerPromisefy(128)\n]).then(function (values) {\n    console.log(Date.now() - startDate + 'ms');\n    console.log(values);\n});\n-------output-------\n133ms       //不一定，但大于128ms\n[1,32,64,128]\n```\n\n### .race()\n\n> 语法：Promise.race(iterable)\n\n该方法同样是将多个Promise实例，包装成一个新的Promise实例。\n\n> var p = Promise.race([p1, p2, p3]);\n\nPromise.race方法同样接受一个数组（或具有Iterator接口）作参数。当p1, p2, p3中有一个实例的状态发生改变（变为fulfilled或rejected），p的状态就跟着改变。并把第一个改变状态的promise的返回值，传给p的回调函数。\n\n```\n/* 例3.11 */\nvar p1 = new Promise(function(resolve, reject) { \n    setTimeout(reject, 500, \"one\"); \n});\nvar p2 = new Promise(function(resolve, reject) { \n    setTimeout(resolve, 100, \"two\"); \n});\n\nPromise.race([p1, p2]).then(function(value) {\n    console.log('resolve', value); \n}, function(error) {\n    //not called\n    console.log('reject', error); \n});\n-------output-------\nresolve two\n\nvar p3 = new Promise(function(resolve, reject) { \n    setTimeout(resolve, 500, \"three\");\n});\nvar p4 = new Promise(function(resolve, reject) { \n    setTimeout(reject, 100, \"four\"); \n});\n\nPromise.race([p3, p4]).then(function(value) {\n    //not called\n    console.log('resolve', value);              \n}, function(error) {\n    console.log('reject', error); \n});\n-------output-------\nreject four\n```\n\n在第一个promise对象变为resolve后，并不会取消其他promise对象的执行，如下例\n\n\n```\n/* 例3.12 */\nvar fastPromise = new Promise(function (resolve) {\n    setTimeout(function () {\n        console.log('fastPromise');\n        resolve('resolve fastPromise');\n    }, 100);\n});\nvar slowPromise = new Promise(function (resolve) {\n    setTimeout(function () {\n        console.log('slowPromise');\n        resolve('resolve slowPromise');\n    }, 1000);\n});\n// 第一个promise变为resolve后程序停止\nPromise.race([fastPromise, slowPromise]).then(function (value) {\n    console.log(value);    // => resolve fastPromise\n});\n-------output-------\nfastPromise\nresolve fastPromise\nslowPromise     //仍会执行\n```\n\n### .resolve()\n\n语法：\n```\nPromise.resolve(value);\nPromise.resolve(promise);\nPromise.resolve(thenable);\n```\n\n它可以看做new Promise()的快捷方式。\n\n```\nPromise.resolve('Success');\n\n/*******等同于*******/\nnew Promise(function (resolve) {\n    resolve('Success');\n});\n```\n\n这段代码会让这个Promise对象立即进入resolved状态，并将结果success传递给then指定的onFulfilled回调函数。由于Promise.resolve()也是返回Promise对象，因此可以用.then()处理其返回值。\n\n```\n/* 例3.13 */\nPromise.resolve('success').then(function (value) {\n    console.log(value);\n});\n-------output-------\nSuccess\n```\n\n```\n/* 例3.14 */\n//Resolving an array\nPromise.resolve([1,2,3]).then(function(value) {\n  console.log(value[0]);    // => 1\n});\n\n//Resolving a Promise\nvar p1 = Promise.resolve('this is p1');\nvar p2 = Promise.resolve(p1);\np2.then(function (value) {\n    console.log(value);     // => this is p1\n});\n```\n\nPromise.resolve()的另一个作用就是将thenable对象（即带有then方法的对象）转换为promise对象。\n\n```\n/* 例3.15 */\nvar p1 = Promise.resolve({ \n    then: function (resolve, reject) { \n        resolve(\"this is an thenable object!\");\n    }\n});\nconsole.log(p1 instanceof Promise);     // => true\n\np1.then(function(value) {\n    console.log(value);     // => this is an thenable object!\n  }, function(e) {\n    //not called\n});\n```\n\n再看下面两个例子，无论是在什么时候抛异常，只要promise状态变成resolved或rejected，状态不会再改变，这和新建promise是一样的。\n\n```\n/* 例3.16 */\n//在回调函数前抛异常\nvar p1 = { \n    then: function(resolve) {\n      throw new Error(\"error\");\n      resolve(\"Resolved\");\n    }\n};\n\nvar p2 = Promise.resolve(p1);\np2.then(function(value) {\n    //not called\n}, function(error) {\n    console.log(error);       // => Error: error\n});\n\n//在回调函数后抛异常\nvar p3 = { \n    then: function(resolve) {\n        resolve(\"Resolved\");\n        throw new Error(\"error\");\n    }\n};\n\nvar p4 = Promise.resolve(p3);\np4.then(function(value) {\n    console.log(value);     // => Resolved\n}, function(error) {\n    //not called\n});\n```\n\n### .reject()\n\n> 语法：Promise.reject(reason)\n\n这个方法和上述的Promise.resolve()类似，它也是new Promise()的快捷方式。\n\n```\nPromise.reject(new Error('error'));\n\n/*******等同于*******/\nnew Promise(function (resolve, reject) {\n    reject(new Error('error'));\n});\n```\n\n这段代码会让这个Promise对象立即进入rejected状态，并将错误对象传递给then指定的onRejected回调函数。\n\n\n# Promise常见问题\n\n经过上一章的学习，相信大家已经学会使用Promise。\n总结一下创建promise的流程：\n\n1. 使用new Promise(fn)或者它的快捷方式Promise.resolve()、Promise.reject()，返回一个promise对象\n2. 在fn中指定异步的处理\n处理结果正常，调用resolve\n处理结果错误，调用reject\n\n如果使用ES6的箭头函数，将会使写法更加简单清晰。\n\n这一章节，将会用例子的形式，以说明promise使用过程中的注意点及容易犯的错误。\n\n**情景1**：reject 和 catch 的区别\n- promise.then(onFulfilled, onRejected)\n在onFulfilled中发生异常的话，在onRejected中是捕获不到这个异常的。\n- promise.then(onFulfilled).catch(onRejected)\n.then中产生的异常能在.catch中捕获\n\n一般情况，还是建议使用第二种，因为能捕获之前的所有异常。当然了，第二种的.catch()也可以使用.then()表示，它们本质上是没有区别的，.catch === .then(null, onRejected)\n\n**情景2**：如果在then中抛错，而没有对错误进行处理（即catch），那么会一直保持reject状态，直到catch了错误\n\n```\n/* 例4.1 */\nfunction taskA() {\n    console.log(x);\n    console.log(\"Task A\");\n}\nfunction taskB() {\n    console.log(\"Task B\");\n}\nfunction onRejected(error) {\n    console.log(\"Catch Error: A or B\", error);\n}\nfunction finalTask() {\n    console.log(\"Final Task\");\n}\nvar promise = Promise.resolve();\npromise\n    .then(taskA)\n    .then(taskB)\n    .catch(onRejected)\n    .then(finalTask);\n    \n-------output-------\nCatch Error: A or B,ReferenceError: x is not defined\nFinal Task\n```\n\n```\n/* 例4.2 */\nfunction taskA() {\n    console.log(x);\n    console.log(\"Task A\");\n}\nfunction taskB() {\n    console.log(\"Task B\");\n}\nfunction onRejectedA(error) {\n    console.log(\"Catch Error: A\", error);\n}\nfunction onRejectedB(error) {\n    console.log(\"Catch Error: B\", error);\n}\nfunction finalTask() {\n    console.log(\"Final Task\");\n}\nvar promise = Promise.resolve();\npromise\n    .then(taskA)\n    .catch(onRejectedA)\n    .then(taskB)\n    .catch(onRejectedB)\n    .then(finalTask);\n    \n-------output-------\nCatch Error: A ReferenceError: x is not defined\nTask B\nFinal Task\n```\n\n将例4.2与4.1对比，在taskA后多了对A的处理，因此，A抛错时，会按照A会按照 taskA → onRejectedA → taskB → finalTask这个流程来处理，此时taskB是正常执行的。\n\n**情景3**：每次调用then都会返回一个新创建的promise对象，而then内部只是返回的数据\n```\n/* 例4.3 */\n//方法1：对同一个promise对象同时调用 then 方法\nvar p1 = new Promise(function (resolve) {\n    resolve(100);\n});\np1.then(function (value) {\n    return value * 2;\n});\np1.then(function (value) {\n    return value * 2;\n});\np1.then(function (value) {\n    console.log(\"finally: \" + value);\n});\n-------output-------\nfinally: 100\n\n//方法2：对 then 进行 promise chain 方式进行调用\nvar p2 = new Promise(function (resolve) {\n    resolve(100);\n});\np2.then(function (value) {\n    return value * 2;\n}).then(function (value) {\n    return value * 2;\n}).then(function (value) {\n    console.log(\"finally: \" + value);\n});\n-------output-------\nfinally: 400\n```\n\n第一种方法中，then的调用几乎是同时开始执行的，且传给每个then的value都是100，这种方法应当避免。方法二才是正确的链式调用。\n因此容易出现下面的错误写法：\n\n```\n/* 例4.4 */\nfunction badAsyncCall(data) {\n    var promise = Promise.resolve(data);\n    promise.then(function(value) {\n        //do something\n        return value + 1;\n    });\n    return promise;\n}\nbadAsyncCall(10).then(function(value) {\n   console.log(value);          //想要得到11，实际输出10\n});\n-------output-------\n10\n```\n\n正确的写法应该是：\n\n```\n/* 改写例4.4 */\nfunction goodAsyncCall(data) {\n    var promise = Promise.resolve(data);\n    return promise.then(function(value) {\n        //do something\n        return value + 1;\n    });\n}\ngoodAsyncCall(10).then(function(value) {\n   console.log(value);\n});\n-------output-------\n11\n```\n\n**情景4**：在异步回调中抛错，不会被catch到\n```\n// Errors thrown inside asynchronous functions will act like uncaught errors\nvar promise = new Promise(function(resolve, reject) {\n  setTimeout(function() {\n    throw 'Uncaught Exception!';\n  }, 1000);\n});\n\npromise.catch(function(e) {\n  console.log(e);       //This is never called\n});\n```\n\n**情景5**： promise状态变为resove或reject，就凝固了，不会再改变\n```\nconsole.log(1);\nnew Promise(function (resolve, reject){\n    reject();\n    setTimeout(function (){\n        resolve();            //not called\n    }, 0);\n}).then(function(){\n    console.log(2);\n}, function(){\n    console.log(3);\n});\nconsole.log(4);\n\n-------output-------\n1\n4\n3\n```\n\n# 结语\n通过阅读这篇文章，让我对promise有个大概的认识。文章出处：[https://segmentfault.com/a/1190000007032448#articleHeader16](https://segmentfault.com/a/1190000007032448#articleHeader16)","slug":"promise","published":1,"date":"2020-09-04T02:56:58.995Z","updated":"2020-09-04T02:56:58.995Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckep5vtgr0013l4i97onr7fzu","content":"<h1 id=\"一-前言\"><a href=\"#一-前言\" class=\"headerlink\" title=\"一 前言\"></a>一 前言</h1><p>一直对promise一知半解，当阅读到<a href=\"https://segmentfault.com/a/1190000007032448#articleHeader16\" target=\"_blank\" rel=\"noopener\">其他文章</a>时对它有个明确的认识。</p>\n<h1 id=\"二-什么是promise\"><a href=\"#二-什么是promise\" class=\"headerlink\" title=\"二 什么是promise\"></a>二 什么是promise</h1><p>以下是MDN对Promise的定义</p>\n<blockquote>\n<p>The Promise object is used for asynchronous computations. A Promise represents a single asynchronous operation that hasn’t completed yet, but is expected in the future.<br>译文：Promise对象用于异步操作，它表示一个尚未完成且预计在未来完成的异步操作。</p>\n</blockquote>\n<p>那么什么是异步操作？在学习promise之前需要把这个概念搞明白，下面将抽离一章专门介绍。</p>\n<h2 id=\"同步与异步\"><a href=\"#同步与异步\" class=\"headerlink\" title=\"同步与异步\"></a>同步与异步</h2><p>我们知道，JavaScript的执行环境是「单线程」。<br>所谓单线程，是指JS引擎中负责解释和执行JavaScript代码的线程只有一个，也就是一次只能完成一项任务，这个任务执行完后才能执行下一个，它会「阻塞」其他任务。这个任务可称为主线程。<br>但实际上还有其他线程，如事件触发线程、ajax请求线程等。</p>\n<p>这也就引发了同步和异步的问题。</p>\n<h3 id=\"同步\"><a href=\"#同步\" class=\"headerlink\" title=\"同步\"></a>同步</h3><p>同步模式，即上述所说的单线程模式，<strong>一次</strong>只能执行<strong>一个</strong>任务，函数调用后需等到函数执行结束，返回执行的结果，才能进行下一个任务。如果这个任务执行的时间较长，就会导致「<strong>线程阻塞</strong>」。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 例2.1 */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(x);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"don't carry out\"</span>);    <span class=\"comment\">//不会执行</span></span><br></pre></td></tr></table></figure>\n<p>上面的例子即同步模式，其中的while是一个死循环，它会阻塞进程，因此第三句console不会执行。<br>同步模式比较简单，也较容易编写。但问题也显而易见，如果请求的时间较长，而阻塞了后面代码的执行，体验是很不好的。因此对于一些耗时的操作，异步模式则是更好的选择。</p>\n<h3 id=\"异步\"><a href=\"#异步\" class=\"headerlink\" title=\"异步\"></a>异步</h3><p>下面就来看看异步模式。<br>异步模式，即与同步模式相反，可以一起执行<strong>多个任务</strong>，函数调用后不会立即返回执行的结果，如果任务A需要等待，可先执行任务B，等到任务A结果返回后再继续回调。<br>最常见的异步模式就数定时器了，我们来看看以下的例子。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 例<span class=\"number\">2.2</span> */</span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(<span class=\"string\">'taskA, asynchronous'</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"string\">'taskB, synchronize'</span>);</span><br><span class=\"line\">//<span class=\"keyword\">while</span>(<span class=\"literal\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-------ouput-------</span></span><br><span class=\"line\">taskB, synchronize</span><br><span class=\"line\">taskA, asynchronous</span><br></pre></td></tr></table></figure>\n<p>我们可以看到，定时器延时的时间明明为0，但taskA还是晚于taskB执行。这是为什么呢？由于定时器是异步的，<strong>异步任务会在当前脚本的所有同步任务执行完才会执行</strong>。如果同步代码中含有死循环，即将上例的注释去掉，那么这个异步任务就不会执行，因为同步任务阻塞了进程。</p>\n<h3 id=\"回调函数\"><a href=\"#回调函数\" class=\"headerlink\" title=\"回调函数\"></a>回调函数</h3><p>提起异步，就不得不谈谈回调函数了。上例中，setTimeout里的function便是回调函数。可以简单理解为：（执行完）回（来）调（用）的函数。<br>以下是WikiPedia对于callback的定义。</p>\n<blockquote>\n<p>In computer programming, a callback is a piece of executable code that is passed as an argument to other code, which is expected to call back (execute) the argument at some convenient time.</p>\n</blockquote>\n<p>可以看出，回调函数是一段可执行的代码段，它以「参数」的形式传递给其他代码，在其合适的时间执行这段（回调函数）的代码。</p>\n<p>WikiPedia同时提到</p>\n<blockquote>\n<p>The invocation may be immediate as in a synchronous callback, or it might happen at a later time as in an asynchronous callback.</p>\n</blockquote>\n<p>也就是说，回调函数不仅可以用于异步调用，一般同步的场景也可以用回调。在同步调用下，回调函数一般是最后执行的。而异步调用下，可能一段时间后执行或不执行（未达到执行的条件）。</p>\n<figure class=\"highlight qml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 例2.3 */</span></span><br><span class=\"line\"><span class=\"comment\">/******************同步回调******************/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fun1 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//do something</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"before callback\"</span>);</span><br><span class=\"line\">    (callback &amp;&amp; <span class=\"keyword\">typeof</span>(callback) === <span class=\"string\">'function'</span>) &amp;&amp; callback();</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"after callback\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> fun2 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">param</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//do something</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> start = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">    <span class=\"keyword\">while</span>((<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>() - start) &lt; <span class=\"number\">3000</span>) &#123; <span class=\"comment\">//delay 3s</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"I'm callback\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fun1(fun2);</span><br><span class=\"line\"></span><br><span class=\"line\">-------output--------</span><br><span class=\"line\">before callback</span><br><span class=\"line\"><span class=\"comment\">//after 3s</span></span><br><span class=\"line\">I’m callback</span><br><span class=\"line\">after callback</span><br></pre></td></tr></table></figure>\n<p>由于是同步回调，会阻塞后面的代码，如果fun2是个死循环，后面的代码就不执行了。</p>\n<p>上一小节中setTimeout就是常见的异步回调，另外常见的异步回调即ajax请求。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 例<span class=\"number\">2.4</span> */</span><br><span class=\"line\">/******************异步回调******************/</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">request</span><span class=\"params\">(url, param, successFun, errorFun)</span></span> &#123;</span><br><span class=\"line\">    $.ajax(&#123;</span><br><span class=\"line\">        <span class=\"built_in\">type</span>: <span class=\"string\">'GET'</span>,</span><br><span class=\"line\">        url: url,</span><br><span class=\"line\">        param: param,</span><br><span class=\"line\">        async: <span class=\"literal\">true</span>,    //默认为<span class=\"literal\">true</span>,即异步请求；<span class=\"literal\">false</span>为同步请求</span><br><span class=\"line\">        success: successFun,</span><br><span class=\"line\">        <span class=\"built_in\">error</span>: errorFun</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">request(<span class=\"string\">'test.html'</span>, <span class=\"string\">''</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(data)</span></span> &#123;</span><br><span class=\"line\">    //请求成功后的回调函数，通常是对请求回来的数据进行处理</span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(<span class=\"string\">'请求成功啦, 这是返回的数据:'</span>, data);</span><br><span class=\"line\">&#125;,<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(error)</span></span> &#123;</span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(<span class=\"string\">'sorry, 请求失败了, 这是失败信息:'</span>, <span class=\"built_in\">error</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"为什么使用Promise\"><a href=\"#为什么使用Promise\" class=\"headerlink\" title=\"为什么使用Promise\"></a>为什么使用Promise</h2><p>说完了以上基本概念，我们就可以继续学习Promise了。<br>上面提到，Promise对象是用于异步操作的。既然我们可以使用异步回调来进行异步操作，为什么还要引入一个Promise新概念，还要花时间学习它呢？不要着急，下面就来谈谈Promise的过人之处。<br>我们先看看下面的demo，利用Promise改写例2.4的异步回调。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 例2.5 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sendRequest</span>(<span class=\"params\">url, param</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">        request(url, param, resolve, reject);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">sendRequest(<span class=\"string\">'test.html'</span>, <span class=\"string\">''</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//异步操作成功后的回调</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'请求成功啦, 这是返回的数据:'</span>, data);</span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//异步操作失败后的回调</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'sorry, 请求失败了, 这是失败信息:'</span>, error);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这么一看，并没有什么区别，还比上面的异步回调复杂，得先新建Promise再定义其回调。其实，Promise的真正强大之处在于它的多重链式调用，可以避免层层嵌套回调。如果我们在第一次ajax请求后，还要用它返回的结果再次请求呢？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 例2.6 */</span></span><br><span class=\"line\">request(<span class=\"string\">'test1.html'</span>, <span class=\"string\">''</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data1</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'第一次请求成功, 这是返回的数据:'</span>, data1);</span><br><span class=\"line\">    request(<span class=\"string\">'test2.html'</span>, data1, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data2</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'第二次请求成功, 这是返回的数据:'</span>, data2);</span><br><span class=\"line\">        request(<span class=\"string\">'test3.html'</span>, data2, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data3</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'第三次请求成功, 这是返回的数据:'</span>, data3);</span><br><span class=\"line\">            <span class=\"comment\">//request... 继续请求</span></span><br><span class=\"line\">        &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error3</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'第三次请求失败, 这是失败信息:'</span>, error3);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error2</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'第二次请求失败, 这是失败信息:'</span>, error2);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error1</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'第一次请求失败, 这是失败信息:'</span>, error1);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>以上出现了多层回调嵌套，有种晕头转向的感觉。这也就是我们常说的厄运回调金字塔（Pyramid of Doom），编程体验十分不好。而使用Promise，我们就可以利用then进行「链式回调」，将异步操作以同步操作的流程表示出来。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 例2.7 */</span></span><br><span class=\"line\">sendRequest(<span class=\"string\">'test1.html'</span>, <span class=\"string\">''</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data1</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'第一次请求成功, 这是返回的数据:'</span>, data1);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data2</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'第二次请求成功, 这是返回的数据:'</span>, data2);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data3</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'第三次请求成功, 这是返回的数据:'</span>, data3);</span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//用catch捕捉前面的错误</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'sorry, 请求失败了, 这是失败信息:'</span>, error);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>是不是明显清晰很多？孰优孰略也无需多说了吧~下面就让我们真正进入Promise的学习。</p>\n<h1 id=\"三-Promise的基本用法\"><a href=\"#三-Promise的基本用法\" class=\"headerlink\" title=\"三 Promise的基本用法\"></a>三 Promise的基本用法</h1><h2 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h2><p>上一小节我们认识了promise长什么样，但对它用到的resolve、reject、then、catch想必还不理解。下面我们一步步学习。</p>\n<p>Promise对象代表一个未完成、但预计将来会完成的操作。<br>它有以下三种状态：</p>\n<ul>\n<li>pending：初始值，不是fulfilled，也不是rejected</li>\n<li>fulfilled：代表操作成功</li>\n<li>rejected：代表操作失败</li>\n</ul>\n<p>Promise有两种状态改变的方式，既可以从pending转变为fulfilled，也可以从pending转变为rejected。一旦状态改变，就「凝固」了，会一直保持这个状态，不会再发生变化。当状态发生变化，promise.then绑定的函数就会被调用。<br>注意：Promise一旦新建就会「立即执行」，无法取消。这也是它的缺点之一。<br>下面就通过例子进一步讲解。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 例3.1 */</span></span><br><span class=\"line\"><span class=\"comment\">//构建Promise</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"comment\">/* 异步操作成功 */</span>) &#123;</span><br><span class=\"line\">        resolve(data);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* 异步操作失败 */</span></span><br><span class=\"line\">        reject(error);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>类似构建对象，我们使用new来构建一个Promise。Promise接受一个「函数」作为参数，该函数的两个参数分别是resolve和reject。这两个函数就是就是「回调函数」，由JavaScript引擎提供。</p>\n<p>resolve函数的作用：在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；<br>reject函数的作用：在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>\n<p>Promise实例生成以后，可以用then方法指定resolved状态和reject状态的回调函数。</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 接例3.1 */</span></span><br><span class=\"line\">promise.then(onFulfilled, onRejected);</span><br><span class=\"line\"></span><br><span class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(data)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// do something when success</span></span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(error)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// do something when failure</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>then方法会返回一个Promise。它有两个参数，分别为Promise从pending变为fulfilled和rejected时的回调函数（第二个参数非必选）。这两个函数都<strong>接受Promise对象传出的值作为参数</strong>。<br>简单来说，then就是定义resolve和reject函数的，其resolve参数相当于：</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolveFun</span><span class=\"params\">(data)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//data为promise传出的值</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而新建Promise中的’resolve(data)’，则相当于执行resolveFun函数。<br>Promise新建后就会立即执行。而then方法中指定的回调函数，将在当前脚本所有同步任务执行完才会执行。如下例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 例3.2 */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'before resolved'</span>);</span><br><span class=\"line\">  resolve();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'after resolved'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'resolved'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'outer'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">-------output-------</span><br><span class=\"line\">before resolved</span><br><span class=\"line\">after resolved</span><br><span class=\"line\">outer</span><br><span class=\"line\">resolved</span><br></pre></td></tr></table></figure>\n<p>由于resolve指定的是异步操作成功后的回调函数，它需要等所有同步代码执行后才会执行，因此最后打印’resolved’，这个和例2.2是一样的道理。</p>\n<h2 id=\"基本API\"><a href=\"#基本API\" class=\"headerlink\" title=\"基本API\"></a>基本API</h2><h3 id=\"then\"><a href=\"#then\" class=\"headerlink\" title=\".then()\"></a>.then()</h3><blockquote>\n<p>语法：Promise.prototype.then(onFulfilled, onRejected)</p>\n</blockquote>\n<p>对promise添加onFulfilled和onRejected回调，并返回的是一个新的Promise实例（不是原来那个Promise实例），且返回值将作为参数传入这个新Promise的resolve函数。</p>\n<p>因此，我们可以使用链式写法，如上文的例2.7。由于前一个回调函数，返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。</p>\n<h3 id=\"catch\"><a href=\"#catch\" class=\"headerlink\" title=\".catch()\"></a>.catch()</h3><blockquote>\n<p>语法：Promise.prototype.catch(onRejected)</p>\n</blockquote>\n<p>该方法是.then(undefined, onRejected)的别名，用于指定发生错误时的回调函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 例3.3 */</span></span><br><span class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'success'</span>);</span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'error'</span>, error);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*******等同于*******/</span></span><br><span class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'success'</span>);</span><br><span class=\"line\">&#125;).then(<span class=\"literal\">undefined</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'error'</span>, error);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 例3.4 */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'test'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">/*******等同于*******/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'test'</span>));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//用catch捕获</span></span><br><span class=\"line\">promise.catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(error);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">-------output-------</span><br><span class=\"line\"><span class=\"built_in\">Error</span>: test</span><br></pre></td></tr></table></figure>\n<p>从上例可以看出，reject方法的作用，等同于抛错。</p>\n<p>promise对象的错误，会一直向后传递，直到被捕获。即错误总会被下一个catch所捕获。then方法指定的回调函数，若抛出错误，也会被下一个catch捕获。catch中也能抛错，则需要后面的catch来捕获。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 例3.5 */</span></span><br><span class=\"line\">sendRequest(<span class=\"string\">'test.html'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(data1)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//do something</span></span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(data2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//do something</span></span><br><span class=\"line\">&#125;).<span class=\"keyword\">catch</span>(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(error)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//处理前面三个Promise产生的错误</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上文提到过，promise状态一旦改变就会凝固，不会再改变。因此promise一旦fulfilled了，再抛错，也不会变为rejected，就不会被catch了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 例3.6 */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">  resolve();</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"string\">'error'</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">promise.catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(e);      <span class=\"comment\">//This is never called</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>如果没有使用catch方法指定处理错误的回调函数，Promise对象抛出的错误不会传递到外层代码，即不会有任何反应（Chrome会抛错），这是Promise的另一个缺点。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 例3.7 */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    resolve(x);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://segmentfault.com/img/bVDEBJ?w=1466&amp;h=286\" alt=\"chrome不报错\" title=\"chrome不报错\"><br><img src=\"https://segmentfault.com/img/bVDEZp?w=530&amp;h=151\" alt=\"safari报错\" title=\"safari报错\"><br><img src=\"https://segmentfault.com/img/bVDE0o?w=388&amp;h=145\" alt=\"safari报错\" title=\"safari报错\"><br>只有Chrome会抛错，且promise状态变为rejected，Firefox和Safari中错误不会被捕获，也不会传递到外层代码，最后没有任何输出，promise状态也变为rejected。</p>\n<h3 id=\"all\"><a href=\"#all\" class=\"headerlink\" title=\".all()\"></a>.all()</h3><blockquote>\n<p>语法：Promise.all(iterable)</p>\n</blockquote>\n<p>该方法用于将多个Promise实例，包装成一个新的Promise实例。</p>\n<blockquote>\n<p>var p = Promise.all([p1, p2, p3]);</p>\n</blockquote>\n<p>Promise.all方法接受一个数组（或具有Iterator接口）作参数，数组中的对象（p1、p2、p3）均为promise实例（如果不是一个promise，该项会被用Promise.resolve转换为一个promise)。它的状态由这三个promise实例决定。</p>\n<ul>\n<li>当p1, p2, p3状态都变为fulfilled，p的状态才会变为fulfilled，并将三个promise返回的结果，按参数的顺序（而不是 resolved的顺序）存入数组，传给p的回调函数，如例3.8。</li>\n<li>当p1, p2, p3其中之一状态变为rejected，p的状态也会变为rejected，并把第一个被reject的promise的返回值，传给p的回调函数，如例3.9。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 例3.8 */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(resolve, <span class=\"number\">3000</span>, <span class=\"string\">\"first\"</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">var</span> p2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    resolve(<span class=\"string\">'second'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">var</span> p3 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  setTimeout(resolve, <span class=\"number\">1000</span>, <span class=\"string\">\"third\"</span>);</span><br><span class=\"line\">&#125;); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.all([p1, p2, p3]).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">values</span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(values); </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">-------output-------</span><br><span class=\"line\"><span class=\"comment\">//约 3s 后</span></span><br><span class=\"line\">[<span class=\"string\">\"first\"</span>, <span class=\"string\">\"second\"</span>, <span class=\"string\">\"third\"</span>]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 例3.9 */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123; </span><br><span class=\"line\">  setTimeout(resolve, <span class=\"number\">1000</span>, <span class=\"string\">\"one\"</span>); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\"><span class=\"keyword\">var</span> p2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123; </span><br><span class=\"line\">  setTimeout(reject, <span class=\"number\">2000</span>, <span class=\"string\">\"two\"</span>); </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">var</span> p3 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  reject(<span class=\"string\">\"three\"</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.all([p1, p2, p3]).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'resolve'</span>, value);</span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'reject'</span>, error);    <span class=\"comment\">// =&gt; reject three</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">-------output-------</span><br><span class=\"line\">reject three</span><br></pre></td></tr></table></figure>\n<p>这多个 promise 是同时开始、并行执行的，而不是顺序执行。从下面例子可以看出。如果一个个执行，那至少需要 1+32+64+128</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 例3.10 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timerPromisefy</span>(<span class=\"params\">delay</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            resolve(delay);</span><br><span class=\"line\">        &#125;, delay);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> startDate = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.all([</span><br><span class=\"line\">    timerPromisefy(<span class=\"number\">1</span>),</span><br><span class=\"line\">    timerPromisefy(<span class=\"number\">32</span>),</span><br><span class=\"line\">    timerPromisefy(<span class=\"number\">64</span>),</span><br><span class=\"line\">    timerPromisefy(<span class=\"number\">128</span>)</span><br><span class=\"line\">]).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">values</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Date</span>.now() - startDate + <span class=\"string\">'ms'</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(values);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">-------output-------</span><br><span class=\"line\"><span class=\"number\">133</span>ms       <span class=\"comment\">//不一定，但大于128ms</span></span><br><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">32</span>,<span class=\"number\">64</span>,<span class=\"number\">128</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"race\"><a href=\"#race\" class=\"headerlink\" title=\".race()\"></a>.race()</h3><blockquote>\n<p>语法：Promise.race(iterable)</p>\n</blockquote>\n<p>该方法同样是将多个Promise实例，包装成一个新的Promise实例。</p>\n<blockquote>\n<p>var p = Promise.race([p1, p2, p3]);</p>\n</blockquote>\n<p>Promise.race方法同样接受一个数组（或具有Iterator接口）作参数。当p1, p2, p3中有一个实例的状态发生改变（变为fulfilled或rejected），p的状态就跟着改变。并把第一个改变状态的promise的返回值，传给p的回调函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 例3.11 */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123; </span><br><span class=\"line\">    setTimeout(reject, <span class=\"number\">500</span>, <span class=\"string\">\"one\"</span>); </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">var</span> p2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123; </span><br><span class=\"line\">    setTimeout(resolve, <span class=\"number\">100</span>, <span class=\"string\">\"two\"</span>); </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.race([p1, p2]).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'resolve'</span>, value); </span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//not called</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'reject'</span>, error); </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">-------output-------</span><br><span class=\"line\">resolve two</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p3 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123; </span><br><span class=\"line\">    setTimeout(resolve, <span class=\"number\">500</span>, <span class=\"string\">\"three\"</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">var</span> p4 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123; </span><br><span class=\"line\">    setTimeout(reject, <span class=\"number\">100</span>, <span class=\"string\">\"four\"</span>); </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.race([p3, p4]).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//not called</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'resolve'</span>, value);              </span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'reject'</span>, error); </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">-------output-------</span><br><span class=\"line\">reject four</span><br></pre></td></tr></table></figure>\n<p>在第一个promise对象变为resolve后，并不会取消其他promise对象的执行，如下例</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 例3.12 */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fastPromise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'fastPromise'</span>);</span><br><span class=\"line\">        resolve(<span class=\"string\">'resolve fastPromise'</span>);</span><br><span class=\"line\">    &#125;, <span class=\"number\">100</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">var</span> slowPromise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'slowPromise'</span>);</span><br><span class=\"line\">        resolve(<span class=\"string\">'resolve slowPromise'</span>);</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 第一个promise变为resolve后程序停止</span></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.race([fastPromise, slowPromise]).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(value);    <span class=\"comment\">// =&gt; resolve fastPromise</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">-------output-------</span><br><span class=\"line\">fastPromise</span><br><span class=\"line\">resolve fastPromise</span><br><span class=\"line\">slowPromise     <span class=\"comment\">//仍会执行</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"resolve\"><a href=\"#resolve\" class=\"headerlink\" title=\".resolve()\"></a>.resolve()</h3><p>语法：<br><figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Promise.resolve(value)<span class=\"comment\">;</span></span><br><span class=\"line\">Promise.resolve(promise)<span class=\"comment\">;</span></span><br><span class=\"line\">Promise.resolve(thenable)<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure></p>\n<p>它可以看做new Promise()的快捷方式。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'Success'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*******等同于*******/</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">    resolve(<span class=\"string\">'Success'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这段代码会让这个Promise对象立即进入resolved状态，并将结果success传递给then指定的onFulfilled回调函数。由于Promise.resolve()也是返回Promise对象，因此可以用.then()处理其返回值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 例3.13 */</span></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'success'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(value);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">-------output-------</span><br><span class=\"line\">Success</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 例3.14 */</span></span><br><span class=\"line\"><span class=\"comment\">//Resolving an array</span></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(value[<span class=\"number\">0</span>]);    <span class=\"comment\">// =&gt; 1</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Resolving a Promise</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> p1 = <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'this is p1'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> p2 = <span class=\"built_in\">Promise</span>.resolve(p1);</span><br><span class=\"line\">p2.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(value);     <span class=\"comment\">// =&gt; this is p1</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>Promise.resolve()的另一个作用就是将thenable对象（即带有then方法的对象）转换为promise对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 例3.15 */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> p1 = <span class=\"built_in\">Promise</span>.resolve(&#123; </span><br><span class=\"line\">    then: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123; </span><br><span class=\"line\">        resolve(<span class=\"string\">\"this is an thenable object!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(p1 <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Promise</span>);     <span class=\"comment\">// =&gt; true</span></span><br><span class=\"line\"></span><br><span class=\"line\">p1.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(value);     <span class=\"comment\">// =&gt; this is an thenable object!</span></span><br><span class=\"line\">  &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//not called</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>再看下面两个例子，无论是在什么时候抛异常，只要promise状态变成resolved或rejected，状态不会再改变，这和新建promise是一样的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 例3.16 */</span></span><br><span class=\"line\"><span class=\"comment\">//在回调函数前抛异常</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> p1 = &#123; </span><br><span class=\"line\">    then: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"error\"</span>);</span><br><span class=\"line\">      resolve(<span class=\"string\">\"Resolved\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p2 = <span class=\"built_in\">Promise</span>.resolve(p1);</span><br><span class=\"line\">p2.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//not called</span></span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(error);       <span class=\"comment\">// =&gt; Error: error</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//在回调函数后抛异常</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> p3 = &#123; </span><br><span class=\"line\">    then: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">        resolve(<span class=\"string\">\"Resolved\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"error\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p4 = <span class=\"built_in\">Promise</span>.resolve(p3);</span><br><span class=\"line\">p4.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(value);     <span class=\"comment\">// =&gt; Resolved</span></span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//not called</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"reject\"><a href=\"#reject\" class=\"headerlink\" title=\".reject()\"></a>.reject()</h3><blockquote>\n<p>语法：Promise.reject(reason)</p>\n</blockquote>\n<p>这个方法和上述的Promise.resolve()类似，它也是new Promise()的快捷方式。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'error'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*******等同于*******/</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'error'</span>));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这段代码会让这个Promise对象立即进入rejected状态，并将错误对象传递给then指定的onRejected回调函数。</p>\n<h1 id=\"Promise常见问题\"><a href=\"#Promise常见问题\" class=\"headerlink\" title=\"Promise常见问题\"></a>Promise常见问题</h1><p>经过上一章的学习，相信大家已经学会使用Promise。<br>总结一下创建promise的流程：</p>\n<ol>\n<li>使用new Promise(fn)或者它的快捷方式Promise.resolve()、Promise.reject()，返回一个promise对象</li>\n<li>在fn中指定异步的处理<br>处理结果正常，调用resolve<br>处理结果错误，调用reject</li>\n</ol>\n<p>如果使用ES6的箭头函数，将会使写法更加简单清晰。</p>\n<p>这一章节，将会用例子的形式，以说明promise使用过程中的注意点及容易犯的错误。</p>\n<p><strong>情景1</strong>：reject 和 catch 的区别</p>\n<ul>\n<li>promise.then(onFulfilled, onRejected)<br>在onFulfilled中发生异常的话，在onRejected中是捕获不到这个异常的。</li>\n<li>promise.then(onFulfilled).catch(onRejected)<br>.then中产生的异常能在.catch中捕获</li>\n</ul>\n<p>一般情况，还是建议使用第二种，因为能捕获之前的所有异常。当然了，第二种的.catch()也可以使用.then()表示，它们本质上是没有区别的，.catch === .then(null, onRejected)</p>\n<p><strong>情景2</strong>：如果在then中抛错，而没有对错误进行处理（即catch），那么会一直保持reject状态，直到catch了错误</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 例4.1 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">taskA</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(x);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Task A\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">taskB</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Task B\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onRejected</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Catch Error: A or B\"</span>, error);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">finalTask</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Final Task\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> promise = <span class=\"built_in\">Promise</span>.resolve();</span><br><span class=\"line\">promise</span><br><span class=\"line\">    .then(taskA)</span><br><span class=\"line\">    .then(taskB)</span><br><span class=\"line\">    .catch(onRejected)</span><br><span class=\"line\">    .then(finalTask);</span><br><span class=\"line\">    </span><br><span class=\"line\">-------output-------</span><br><span class=\"line\">Catch <span class=\"built_in\">Error</span>: A or B,<span class=\"attr\">ReferenceError</span>: x is not defined</span><br><span class=\"line\">Final Task</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 例4.2 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">taskA</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(x);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Task A\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">taskB</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Task B\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onRejectedA</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Catch Error: A\"</span>, error);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onRejectedB</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Catch Error: B\"</span>, error);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">finalTask</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Final Task\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> promise = <span class=\"built_in\">Promise</span>.resolve();</span><br><span class=\"line\">promise</span><br><span class=\"line\">    .then(taskA)</span><br><span class=\"line\">    .catch(onRejectedA)</span><br><span class=\"line\">    .then(taskB)</span><br><span class=\"line\">    .catch(onRejectedB)</span><br><span class=\"line\">    .then(finalTask);</span><br><span class=\"line\">    </span><br><span class=\"line\">-------output-------</span><br><span class=\"line\">Catch <span class=\"built_in\">Error</span>: A <span class=\"built_in\">ReferenceError</span>: x is not defined</span><br><span class=\"line\">Task B</span><br><span class=\"line\">Final Task</span><br></pre></td></tr></table></figure>\n<p>将例4.2与4.1对比，在taskA后多了对A的处理，因此，A抛错时，会按照A会按照 taskA → onRejectedA → taskB → finalTask这个流程来处理，此时taskB是正常执行的。</p>\n<p><strong>情景3</strong>：每次调用then都会返回一个新创建的promise对象，而then内部只是返回的数据<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 例4.3 */</span></span><br><span class=\"line\"><span class=\"comment\">//方法1：对同一个promise对象同时调用 then 方法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">    resolve(<span class=\"number\">100</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">p1.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value * <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">p1.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value * <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">p1.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"finally: \"</span> + value);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">-------output-------</span><br><span class=\"line\"><span class=\"keyword\">finally</span>: <span class=\"number\">100</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//方法2：对 then 进行 promise chain 方式进行调用</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> p2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">    resolve(<span class=\"number\">100</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">p2.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value * <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value * <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"finally: \"</span> + value);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">-------output-------</span><br><span class=\"line\"><span class=\"keyword\">finally</span>: <span class=\"number\">400</span></span><br></pre></td></tr></table></figure></p>\n<p>第一种方法中，then的调用几乎是同时开始执行的，且传给每个then的value都是100，这种方法应当避免。方法二才是正确的链式调用。<br>因此容易出现下面的错误写法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 例4.4 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">badAsyncCall</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> promise = <span class=\"built_in\">Promise</span>.resolve(data);</span><br><span class=\"line\">    promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//do something</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> value + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> promise;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">badAsyncCall(<span class=\"number\">10</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(value);          <span class=\"comment\">//想要得到11，实际输出10</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">-------output-------</span><br><span class=\"line\"><span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n<p>正确的写法应该是：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 改写例4.4 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">goodAsyncCall</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> promise = <span class=\"built_in\">Promise</span>.resolve(data);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//do something</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> value + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">goodAsyncCall(<span class=\"number\">10</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(value);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">-------output-------</span><br><span class=\"line\"><span class=\"number\">11</span></span><br></pre></td></tr></table></figure>\n<p><strong>情景4</strong>：在异步回调中抛错，不会被catch到<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Errors thrown inside asynchronous functions will act like uncaught errors</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"string\">'Uncaught Exception!'</span>;</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">promise.catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(e);       <span class=\"comment\">//This is never called</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p><strong>情景5</strong>： promise状态变为resove或reject，就凝固了，不会再改变<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>)</span>&#123;</span><br><span class=\"line\">    reject();</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        resolve();            <span class=\"comment\">//not called</span></span><br><span class=\"line\">    &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">4</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">-------output-------</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>通过阅读这篇文章，让我对promise有个大概的认识。文章出处：<a href=\"https://segmentfault.com/a/1190000007032448#articleHeader16\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000007032448#articleHeader16</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一-前言\"><a href=\"#一-前言\" class=\"headerlink\" title=\"一 前言\"></a>一 前言</h1><p>一直对promise一知半解，当阅读到<a href=\"https://segmentfault.com/a/1190000007032448#articleHeader16\" target=\"_blank\" rel=\"noopener\">其他文章</a>时对它有个明确的认识。</p>\n<h1 id=\"二-什么是promise\"><a href=\"#二-什么是promise\" class=\"headerlink\" title=\"二 什么是promise\"></a>二 什么是promise</h1><p>以下是MDN对Promise的定义</p>\n<blockquote>\n<p>The Promise object is used for asynchronous computations. A Promise represents a single asynchronous operation that hasn’t completed yet, but is expected in the future.<br>译文：Promise对象用于异步操作，它表示一个尚未完成且预计在未来完成的异步操作。</p>\n</blockquote>\n<p>那么什么是异步操作？在学习promise之前需要把这个概念搞明白，下面将抽离一章专门介绍。</p>\n<h2 id=\"同步与异步\"><a href=\"#同步与异步\" class=\"headerlink\" title=\"同步与异步\"></a>同步与异步</h2><p>我们知道，JavaScript的执行环境是「单线程」。<br>所谓单线程，是指JS引擎中负责解释和执行JavaScript代码的线程只有一个，也就是一次只能完成一项任务，这个任务执行完后才能执行下一个，它会「阻塞」其他任务。这个任务可称为主线程。<br>但实际上还有其他线程，如事件触发线程、ajax请求线程等。</p>\n<p>这也就引发了同步和异步的问题。</p>\n<h3 id=\"同步\"><a href=\"#同步\" class=\"headerlink\" title=\"同步\"></a>同步</h3><p>同步模式，即上述所说的单线程模式，<strong>一次</strong>只能执行<strong>一个</strong>任务，函数调用后需等到函数执行结束，返回执行的结果，才能进行下一个任务。如果这个任务执行的时间较长，就会导致「<strong>线程阻塞</strong>」。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 例2.1 */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(x);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"don't carry out\"</span>);    <span class=\"comment\">//不会执行</span></span><br></pre></td></tr></table></figure>\n<p>上面的例子即同步模式，其中的while是一个死循环，它会阻塞进程，因此第三句console不会执行。<br>同步模式比较简单，也较容易编写。但问题也显而易见，如果请求的时间较长，而阻塞了后面代码的执行，体验是很不好的。因此对于一些耗时的操作，异步模式则是更好的选择。</p>\n<h3 id=\"异步\"><a href=\"#异步\" class=\"headerlink\" title=\"异步\"></a>异步</h3><p>下面就来看看异步模式。<br>异步模式，即与同步模式相反，可以一起执行<strong>多个任务</strong>，函数调用后不会立即返回执行的结果，如果任务A需要等待，可先执行任务B，等到任务A结果返回后再继续回调。<br>最常见的异步模式就数定时器了，我们来看看以下的例子。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 例<span class=\"number\">2.2</span> */</span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(<span class=\"string\">'taskA, asynchronous'</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"string\">'taskB, synchronize'</span>);</span><br><span class=\"line\">//<span class=\"keyword\">while</span>(<span class=\"literal\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-------ouput-------</span></span><br><span class=\"line\">taskB, synchronize</span><br><span class=\"line\">taskA, asynchronous</span><br></pre></td></tr></table></figure>\n<p>我们可以看到，定时器延时的时间明明为0，但taskA还是晚于taskB执行。这是为什么呢？由于定时器是异步的，<strong>异步任务会在当前脚本的所有同步任务执行完才会执行</strong>。如果同步代码中含有死循环，即将上例的注释去掉，那么这个异步任务就不会执行，因为同步任务阻塞了进程。</p>\n<h3 id=\"回调函数\"><a href=\"#回调函数\" class=\"headerlink\" title=\"回调函数\"></a>回调函数</h3><p>提起异步，就不得不谈谈回调函数了。上例中，setTimeout里的function便是回调函数。可以简单理解为：（执行完）回（来）调（用）的函数。<br>以下是WikiPedia对于callback的定义。</p>\n<blockquote>\n<p>In computer programming, a callback is a piece of executable code that is passed as an argument to other code, which is expected to call back (execute) the argument at some convenient time.</p>\n</blockquote>\n<p>可以看出，回调函数是一段可执行的代码段，它以「参数」的形式传递给其他代码，在其合适的时间执行这段（回调函数）的代码。</p>\n<p>WikiPedia同时提到</p>\n<blockquote>\n<p>The invocation may be immediate as in a synchronous callback, or it might happen at a later time as in an asynchronous callback.</p>\n</blockquote>\n<p>也就是说，回调函数不仅可以用于异步调用，一般同步的场景也可以用回调。在同步调用下，回调函数一般是最后执行的。而异步调用下，可能一段时间后执行或不执行（未达到执行的条件）。</p>\n<figure class=\"highlight qml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 例2.3 */</span></span><br><span class=\"line\"><span class=\"comment\">/******************同步回调******************/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fun1 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//do something</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"before callback\"</span>);</span><br><span class=\"line\">    (callback &amp;&amp; <span class=\"keyword\">typeof</span>(callback) === <span class=\"string\">'function'</span>) &amp;&amp; callback();</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"after callback\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> fun2 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">param</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//do something</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> start = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">    <span class=\"keyword\">while</span>((<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>() - start) &lt; <span class=\"number\">3000</span>) &#123; <span class=\"comment\">//delay 3s</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"I'm callback\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fun1(fun2);</span><br><span class=\"line\"></span><br><span class=\"line\">-------output--------</span><br><span class=\"line\">before callback</span><br><span class=\"line\"><span class=\"comment\">//after 3s</span></span><br><span class=\"line\">I’m callback</span><br><span class=\"line\">after callback</span><br></pre></td></tr></table></figure>\n<p>由于是同步回调，会阻塞后面的代码，如果fun2是个死循环，后面的代码就不执行了。</p>\n<p>上一小节中setTimeout就是常见的异步回调，另外常见的异步回调即ajax请求。</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 例<span class=\"number\">2.4</span> */</span><br><span class=\"line\">/******************异步回调******************/</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">request</span><span class=\"params\">(url, param, successFun, errorFun)</span></span> &#123;</span><br><span class=\"line\">    $.ajax(&#123;</span><br><span class=\"line\">        <span class=\"built_in\">type</span>: <span class=\"string\">'GET'</span>,</span><br><span class=\"line\">        url: url,</span><br><span class=\"line\">        param: param,</span><br><span class=\"line\">        async: <span class=\"literal\">true</span>,    //默认为<span class=\"literal\">true</span>,即异步请求；<span class=\"literal\">false</span>为同步请求</span><br><span class=\"line\">        success: successFun,</span><br><span class=\"line\">        <span class=\"built_in\">error</span>: errorFun</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">request(<span class=\"string\">'test.html'</span>, <span class=\"string\">''</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(data)</span></span> &#123;</span><br><span class=\"line\">    //请求成功后的回调函数，通常是对请求回来的数据进行处理</span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(<span class=\"string\">'请求成功啦, 这是返回的数据:'</span>, data);</span><br><span class=\"line\">&#125;,<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(error)</span></span> &#123;</span><br><span class=\"line\">    console.<span class=\"built_in\">log</span>(<span class=\"string\">'sorry, 请求失败了, 这是失败信息:'</span>, <span class=\"built_in\">error</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"为什么使用Promise\"><a href=\"#为什么使用Promise\" class=\"headerlink\" title=\"为什么使用Promise\"></a>为什么使用Promise</h2><p>说完了以上基本概念，我们就可以继续学习Promise了。<br>上面提到，Promise对象是用于异步操作的。既然我们可以使用异步回调来进行异步操作，为什么还要引入一个Promise新概念，还要花时间学习它呢？不要着急，下面就来谈谈Promise的过人之处。<br>我们先看看下面的demo，利用Promise改写例2.4的异步回调。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 例2.5 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sendRequest</span>(<span class=\"params\">url, param</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">        request(url, param, resolve, reject);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">sendRequest(<span class=\"string\">'test.html'</span>, <span class=\"string\">''</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//异步操作成功后的回调</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'请求成功啦, 这是返回的数据:'</span>, data);</span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//异步操作失败后的回调</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'sorry, 请求失败了, 这是失败信息:'</span>, error);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这么一看，并没有什么区别，还比上面的异步回调复杂，得先新建Promise再定义其回调。其实，Promise的真正强大之处在于它的多重链式调用，可以避免层层嵌套回调。如果我们在第一次ajax请求后，还要用它返回的结果再次请求呢？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 例2.6 */</span></span><br><span class=\"line\">request(<span class=\"string\">'test1.html'</span>, <span class=\"string\">''</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data1</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'第一次请求成功, 这是返回的数据:'</span>, data1);</span><br><span class=\"line\">    request(<span class=\"string\">'test2.html'</span>, data1, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data2</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'第二次请求成功, 这是返回的数据:'</span>, data2);</span><br><span class=\"line\">        request(<span class=\"string\">'test3.html'</span>, data2, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data3</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'第三次请求成功, 这是返回的数据:'</span>, data3);</span><br><span class=\"line\">            <span class=\"comment\">//request... 继续请求</span></span><br><span class=\"line\">        &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error3</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'第三次请求失败, 这是失败信息:'</span>, error3);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error2</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'第二次请求失败, 这是失败信息:'</span>, error2);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error1</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'第一次请求失败, 这是失败信息:'</span>, error1);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>以上出现了多层回调嵌套，有种晕头转向的感觉。这也就是我们常说的厄运回调金字塔（Pyramid of Doom），编程体验十分不好。而使用Promise，我们就可以利用then进行「链式回调」，将异步操作以同步操作的流程表示出来。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 例2.7 */</span></span><br><span class=\"line\">sendRequest(<span class=\"string\">'test1.html'</span>, <span class=\"string\">''</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data1</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'第一次请求成功, 这是返回的数据:'</span>, data1);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data2</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'第二次请求成功, 这是返回的数据:'</span>, data2);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data3</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'第三次请求成功, 这是返回的数据:'</span>, data3);</span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//用catch捕捉前面的错误</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'sorry, 请求失败了, 这是失败信息:'</span>, error);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>是不是明显清晰很多？孰优孰略也无需多说了吧~下面就让我们真正进入Promise的学习。</p>\n<h1 id=\"三-Promise的基本用法\"><a href=\"#三-Promise的基本用法\" class=\"headerlink\" title=\"三 Promise的基本用法\"></a>三 Promise的基本用法</h1><h2 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h2><p>上一小节我们认识了promise长什么样，但对它用到的resolve、reject、then、catch想必还不理解。下面我们一步步学习。</p>\n<p>Promise对象代表一个未完成、但预计将来会完成的操作。<br>它有以下三种状态：</p>\n<ul>\n<li>pending：初始值，不是fulfilled，也不是rejected</li>\n<li>fulfilled：代表操作成功</li>\n<li>rejected：代表操作失败</li>\n</ul>\n<p>Promise有两种状态改变的方式，既可以从pending转变为fulfilled，也可以从pending转变为rejected。一旦状态改变，就「凝固」了，会一直保持这个状态，不会再发生变化。当状态发生变化，promise.then绑定的函数就会被调用。<br>注意：Promise一旦新建就会「立即执行」，无法取消。这也是它的缺点之一。<br>下面就通过例子进一步讲解。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 例3.1 */</span></span><br><span class=\"line\"><span class=\"comment\">//构建Promise</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"comment\">/* 异步操作成功 */</span>) &#123;</span><br><span class=\"line\">        resolve(data);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* 异步操作失败 */</span></span><br><span class=\"line\">        reject(error);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>类似构建对象，我们使用new来构建一个Promise。Promise接受一个「函数」作为参数，该函数的两个参数分别是resolve和reject。这两个函数就是就是「回调函数」，由JavaScript引擎提供。</p>\n<p>resolve函数的作用：在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；<br>reject函数的作用：在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>\n<p>Promise实例生成以后，可以用then方法指定resolved状态和reject状态的回调函数。</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 接例3.1 */</span></span><br><span class=\"line\">promise.then(onFulfilled, onRejected);</span><br><span class=\"line\"></span><br><span class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(data)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// do something when success</span></span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(error)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// do something when failure</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>then方法会返回一个Promise。它有两个参数，分别为Promise从pending变为fulfilled和rejected时的回调函数（第二个参数非必选）。这两个函数都<strong>接受Promise对象传出的值作为参数</strong>。<br>简单来说，then就是定义resolve和reject函数的，其resolve参数相当于：</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolveFun</span><span class=\"params\">(data)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//data为promise传出的值</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而新建Promise中的’resolve(data)’，则相当于执行resolveFun函数。<br>Promise新建后就会立即执行。而then方法中指定的回调函数，将在当前脚本所有同步任务执行完才会执行。如下例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 例3.2 */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'before resolved'</span>);</span><br><span class=\"line\">  resolve();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'after resolved'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'resolved'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'outer'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">-------output-------</span><br><span class=\"line\">before resolved</span><br><span class=\"line\">after resolved</span><br><span class=\"line\">outer</span><br><span class=\"line\">resolved</span><br></pre></td></tr></table></figure>\n<p>由于resolve指定的是异步操作成功后的回调函数，它需要等所有同步代码执行后才会执行，因此最后打印’resolved’，这个和例2.2是一样的道理。</p>\n<h2 id=\"基本API\"><a href=\"#基本API\" class=\"headerlink\" title=\"基本API\"></a>基本API</h2><h3 id=\"then\"><a href=\"#then\" class=\"headerlink\" title=\".then()\"></a>.then()</h3><blockquote>\n<p>语法：Promise.prototype.then(onFulfilled, onRejected)</p>\n</blockquote>\n<p>对promise添加onFulfilled和onRejected回调，并返回的是一个新的Promise实例（不是原来那个Promise实例），且返回值将作为参数传入这个新Promise的resolve函数。</p>\n<p>因此，我们可以使用链式写法，如上文的例2.7。由于前一个回调函数，返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。</p>\n<h3 id=\"catch\"><a href=\"#catch\" class=\"headerlink\" title=\".catch()\"></a>.catch()</h3><blockquote>\n<p>语法：Promise.prototype.catch(onRejected)</p>\n</blockquote>\n<p>该方法是.then(undefined, onRejected)的别名，用于指定发生错误时的回调函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 例3.3 */</span></span><br><span class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'success'</span>);</span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'error'</span>, error);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*******等同于*******/</span></span><br><span class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'success'</span>);</span><br><span class=\"line\">&#125;).then(<span class=\"literal\">undefined</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'error'</span>, error);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 例3.4 */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'test'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">/*******等同于*******/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'test'</span>));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//用catch捕获</span></span><br><span class=\"line\">promise.catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(error);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">-------output-------</span><br><span class=\"line\"><span class=\"built_in\">Error</span>: test</span><br></pre></td></tr></table></figure>\n<p>从上例可以看出，reject方法的作用，等同于抛错。</p>\n<p>promise对象的错误，会一直向后传递，直到被捕获。即错误总会被下一个catch所捕获。then方法指定的回调函数，若抛出错误，也会被下一个catch捕获。catch中也能抛错，则需要后面的catch来捕获。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 例3.5 */</span></span><br><span class=\"line\">sendRequest(<span class=\"string\">'test.html'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(data1)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//do something</span></span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(data2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//do something</span></span><br><span class=\"line\">&#125;).<span class=\"keyword\">catch</span>(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(error)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//处理前面三个Promise产生的错误</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上文提到过，promise状态一旦改变就会凝固，不会再改变。因此promise一旦fulfilled了，再抛错，也不会变为rejected，就不会被catch了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 例3.6 */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">  resolve();</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"string\">'error'</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">promise.catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(e);      <span class=\"comment\">//This is never called</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>如果没有使用catch方法指定处理错误的回调函数，Promise对象抛出的错误不会传递到外层代码，即不会有任何反应（Chrome会抛错），这是Promise的另一个缺点。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 例3.7 */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    resolve(x);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://segmentfault.com/img/bVDEBJ?w=1466&amp;h=286\" alt=\"chrome不报错\" title=\"chrome不报错\"><br><img src=\"https://segmentfault.com/img/bVDEZp?w=530&amp;h=151\" alt=\"safari报错\" title=\"safari报错\"><br><img src=\"https://segmentfault.com/img/bVDE0o?w=388&amp;h=145\" alt=\"safari报错\" title=\"safari报错\"><br>只有Chrome会抛错，且promise状态变为rejected，Firefox和Safari中错误不会被捕获，也不会传递到外层代码，最后没有任何输出，promise状态也变为rejected。</p>\n<h3 id=\"all\"><a href=\"#all\" class=\"headerlink\" title=\".all()\"></a>.all()</h3><blockquote>\n<p>语法：Promise.all(iterable)</p>\n</blockquote>\n<p>该方法用于将多个Promise实例，包装成一个新的Promise实例。</p>\n<blockquote>\n<p>var p = Promise.all([p1, p2, p3]);</p>\n</blockquote>\n<p>Promise.all方法接受一个数组（或具有Iterator接口）作参数，数组中的对象（p1、p2、p3）均为promise实例（如果不是一个promise，该项会被用Promise.resolve转换为一个promise)。它的状态由这三个promise实例决定。</p>\n<ul>\n<li>当p1, p2, p3状态都变为fulfilled，p的状态才会变为fulfilled，并将三个promise返回的结果，按参数的顺序（而不是 resolved的顺序）存入数组，传给p的回调函数，如例3.8。</li>\n<li>当p1, p2, p3其中之一状态变为rejected，p的状态也会变为rejected，并把第一个被reject的promise的返回值，传给p的回调函数，如例3.9。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 例3.8 */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(resolve, <span class=\"number\">3000</span>, <span class=\"string\">\"first\"</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">var</span> p2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    resolve(<span class=\"string\">'second'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">var</span> p3 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  setTimeout(resolve, <span class=\"number\">1000</span>, <span class=\"string\">\"third\"</span>);</span><br><span class=\"line\">&#125;); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.all([p1, p2, p3]).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">values</span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(values); </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">-------output-------</span><br><span class=\"line\"><span class=\"comment\">//约 3s 后</span></span><br><span class=\"line\">[<span class=\"string\">\"first\"</span>, <span class=\"string\">\"second\"</span>, <span class=\"string\">\"third\"</span>]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 例3.9 */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123; </span><br><span class=\"line\">  setTimeout(resolve, <span class=\"number\">1000</span>, <span class=\"string\">\"one\"</span>); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\"><span class=\"keyword\">var</span> p2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123; </span><br><span class=\"line\">  setTimeout(reject, <span class=\"number\">2000</span>, <span class=\"string\">\"two\"</span>); </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">var</span> p3 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  reject(<span class=\"string\">\"three\"</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.all([p1, p2, p3]).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'resolve'</span>, value);</span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'reject'</span>, error);    <span class=\"comment\">// =&gt; reject three</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">-------output-------</span><br><span class=\"line\">reject three</span><br></pre></td></tr></table></figure>\n<p>这多个 promise 是同时开始、并行执行的，而不是顺序执行。从下面例子可以看出。如果一个个执行，那至少需要 1+32+64+128</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 例3.10 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timerPromisefy</span>(<span class=\"params\">delay</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            resolve(delay);</span><br><span class=\"line\">        &#125;, delay);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> startDate = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.all([</span><br><span class=\"line\">    timerPromisefy(<span class=\"number\">1</span>),</span><br><span class=\"line\">    timerPromisefy(<span class=\"number\">32</span>),</span><br><span class=\"line\">    timerPromisefy(<span class=\"number\">64</span>),</span><br><span class=\"line\">    timerPromisefy(<span class=\"number\">128</span>)</span><br><span class=\"line\">]).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">values</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Date</span>.now() - startDate + <span class=\"string\">'ms'</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(values);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">-------output-------</span><br><span class=\"line\"><span class=\"number\">133</span>ms       <span class=\"comment\">//不一定，但大于128ms</span></span><br><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">32</span>,<span class=\"number\">64</span>,<span class=\"number\">128</span>]</span><br></pre></td></tr></table></figure>\n<h3 id=\"race\"><a href=\"#race\" class=\"headerlink\" title=\".race()\"></a>.race()</h3><blockquote>\n<p>语法：Promise.race(iterable)</p>\n</blockquote>\n<p>该方法同样是将多个Promise实例，包装成一个新的Promise实例。</p>\n<blockquote>\n<p>var p = Promise.race([p1, p2, p3]);</p>\n</blockquote>\n<p>Promise.race方法同样接受一个数组（或具有Iterator接口）作参数。当p1, p2, p3中有一个实例的状态发生改变（变为fulfilled或rejected），p的状态就跟着改变。并把第一个改变状态的promise的返回值，传给p的回调函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 例3.11 */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123; </span><br><span class=\"line\">    setTimeout(reject, <span class=\"number\">500</span>, <span class=\"string\">\"one\"</span>); </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">var</span> p2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123; </span><br><span class=\"line\">    setTimeout(resolve, <span class=\"number\">100</span>, <span class=\"string\">\"two\"</span>); </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.race([p1, p2]).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'resolve'</span>, value); </span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//not called</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'reject'</span>, error); </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">-------output-------</span><br><span class=\"line\">resolve two</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p3 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123; </span><br><span class=\"line\">    setTimeout(resolve, <span class=\"number\">500</span>, <span class=\"string\">\"three\"</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">var</span> p4 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123; </span><br><span class=\"line\">    setTimeout(reject, <span class=\"number\">100</span>, <span class=\"string\">\"four\"</span>); </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.race([p3, p4]).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//not called</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'resolve'</span>, value);              </span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'reject'</span>, error); </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">-------output-------</span><br><span class=\"line\">reject four</span><br></pre></td></tr></table></figure>\n<p>在第一个promise对象变为resolve后，并不会取消其他promise对象的执行，如下例</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 例3.12 */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fastPromise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'fastPromise'</span>);</span><br><span class=\"line\">        resolve(<span class=\"string\">'resolve fastPromise'</span>);</span><br><span class=\"line\">    &#125;, <span class=\"number\">100</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">var</span> slowPromise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'slowPromise'</span>);</span><br><span class=\"line\">        resolve(<span class=\"string\">'resolve slowPromise'</span>);</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 第一个promise变为resolve后程序停止</span></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.race([fastPromise, slowPromise]).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(value);    <span class=\"comment\">// =&gt; resolve fastPromise</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">-------output-------</span><br><span class=\"line\">fastPromise</span><br><span class=\"line\">resolve fastPromise</span><br><span class=\"line\">slowPromise     <span class=\"comment\">//仍会执行</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"resolve\"><a href=\"#resolve\" class=\"headerlink\" title=\".resolve()\"></a>.resolve()</h3><p>语法：<br><figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Promise.resolve(value)<span class=\"comment\">;</span></span><br><span class=\"line\">Promise.resolve(promise)<span class=\"comment\">;</span></span><br><span class=\"line\">Promise.resolve(thenable)<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure></p>\n<p>它可以看做new Promise()的快捷方式。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'Success'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*******等同于*******/</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">    resolve(<span class=\"string\">'Success'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这段代码会让这个Promise对象立即进入resolved状态，并将结果success传递给then指定的onFulfilled回调函数。由于Promise.resolve()也是返回Promise对象，因此可以用.then()处理其返回值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 例3.13 */</span></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'success'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(value);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">-------output-------</span><br><span class=\"line\">Success</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 例3.14 */</span></span><br><span class=\"line\"><span class=\"comment\">//Resolving an array</span></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(value[<span class=\"number\">0</span>]);    <span class=\"comment\">// =&gt; 1</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Resolving a Promise</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> p1 = <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">'this is p1'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> p2 = <span class=\"built_in\">Promise</span>.resolve(p1);</span><br><span class=\"line\">p2.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(value);     <span class=\"comment\">// =&gt; this is p1</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>Promise.resolve()的另一个作用就是将thenable对象（即带有then方法的对象）转换为promise对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 例3.15 */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> p1 = <span class=\"built_in\">Promise</span>.resolve(&#123; </span><br><span class=\"line\">    then: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123; </span><br><span class=\"line\">        resolve(<span class=\"string\">\"this is an thenable object!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(p1 <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Promise</span>);     <span class=\"comment\">// =&gt; true</span></span><br><span class=\"line\"></span><br><span class=\"line\">p1.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(value);     <span class=\"comment\">// =&gt; this is an thenable object!</span></span><br><span class=\"line\">  &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//not called</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>再看下面两个例子，无论是在什么时候抛异常，只要promise状态变成resolved或rejected，状态不会再改变，这和新建promise是一样的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 例3.16 */</span></span><br><span class=\"line\"><span class=\"comment\">//在回调函数前抛异常</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> p1 = &#123; </span><br><span class=\"line\">    then: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"error\"</span>);</span><br><span class=\"line\">      resolve(<span class=\"string\">\"Resolved\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p2 = <span class=\"built_in\">Promise</span>.resolve(p1);</span><br><span class=\"line\">p2.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//not called</span></span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(error);       <span class=\"comment\">// =&gt; Error: error</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//在回调函数后抛异常</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> p3 = &#123; </span><br><span class=\"line\">    then: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">        resolve(<span class=\"string\">\"Resolved\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"error\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p4 = <span class=\"built_in\">Promise</span>.resolve(p3);</span><br><span class=\"line\">p4.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(value);     <span class=\"comment\">// =&gt; Resolved</span></span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//not called</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"reject\"><a href=\"#reject\" class=\"headerlink\" title=\".reject()\"></a>.reject()</h3><blockquote>\n<p>语法：Promise.reject(reason)</p>\n</blockquote>\n<p>这个方法和上述的Promise.resolve()类似，它也是new Promise()的快捷方式。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'error'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*******等同于*******/</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'error'</span>));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这段代码会让这个Promise对象立即进入rejected状态，并将错误对象传递给then指定的onRejected回调函数。</p>\n<h1 id=\"Promise常见问题\"><a href=\"#Promise常见问题\" class=\"headerlink\" title=\"Promise常见问题\"></a>Promise常见问题</h1><p>经过上一章的学习，相信大家已经学会使用Promise。<br>总结一下创建promise的流程：</p>\n<ol>\n<li>使用new Promise(fn)或者它的快捷方式Promise.resolve()、Promise.reject()，返回一个promise对象</li>\n<li>在fn中指定异步的处理<br>处理结果正常，调用resolve<br>处理结果错误，调用reject</li>\n</ol>\n<p>如果使用ES6的箭头函数，将会使写法更加简单清晰。</p>\n<p>这一章节，将会用例子的形式，以说明promise使用过程中的注意点及容易犯的错误。</p>\n<p><strong>情景1</strong>：reject 和 catch 的区别</p>\n<ul>\n<li>promise.then(onFulfilled, onRejected)<br>在onFulfilled中发生异常的话，在onRejected中是捕获不到这个异常的。</li>\n<li>promise.then(onFulfilled).catch(onRejected)<br>.then中产生的异常能在.catch中捕获</li>\n</ul>\n<p>一般情况，还是建议使用第二种，因为能捕获之前的所有异常。当然了，第二种的.catch()也可以使用.then()表示，它们本质上是没有区别的，.catch === .then(null, onRejected)</p>\n<p><strong>情景2</strong>：如果在then中抛错，而没有对错误进行处理（即catch），那么会一直保持reject状态，直到catch了错误</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 例4.1 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">taskA</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(x);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Task A\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">taskB</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Task B\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onRejected</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Catch Error: A or B\"</span>, error);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">finalTask</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Final Task\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> promise = <span class=\"built_in\">Promise</span>.resolve();</span><br><span class=\"line\">promise</span><br><span class=\"line\">    .then(taskA)</span><br><span class=\"line\">    .then(taskB)</span><br><span class=\"line\">    .catch(onRejected)</span><br><span class=\"line\">    .then(finalTask);</span><br><span class=\"line\">    </span><br><span class=\"line\">-------output-------</span><br><span class=\"line\">Catch <span class=\"built_in\">Error</span>: A or B,<span class=\"attr\">ReferenceError</span>: x is not defined</span><br><span class=\"line\">Final Task</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 例4.2 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">taskA</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(x);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Task A\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">taskB</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Task B\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onRejectedA</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Catch Error: A\"</span>, error);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onRejectedB</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Catch Error: B\"</span>, error);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">finalTask</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Final Task\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> promise = <span class=\"built_in\">Promise</span>.resolve();</span><br><span class=\"line\">promise</span><br><span class=\"line\">    .then(taskA)</span><br><span class=\"line\">    .catch(onRejectedA)</span><br><span class=\"line\">    .then(taskB)</span><br><span class=\"line\">    .catch(onRejectedB)</span><br><span class=\"line\">    .then(finalTask);</span><br><span class=\"line\">    </span><br><span class=\"line\">-------output-------</span><br><span class=\"line\">Catch <span class=\"built_in\">Error</span>: A <span class=\"built_in\">ReferenceError</span>: x is not defined</span><br><span class=\"line\">Task B</span><br><span class=\"line\">Final Task</span><br></pre></td></tr></table></figure>\n<p>将例4.2与4.1对比，在taskA后多了对A的处理，因此，A抛错时，会按照A会按照 taskA → onRejectedA → taskB → finalTask这个流程来处理，此时taskB是正常执行的。</p>\n<p><strong>情景3</strong>：每次调用then都会返回一个新创建的promise对象，而then内部只是返回的数据<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 例4.3 */</span></span><br><span class=\"line\"><span class=\"comment\">//方法1：对同一个promise对象同时调用 then 方法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">    resolve(<span class=\"number\">100</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">p1.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value * <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">p1.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value * <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">p1.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"finally: \"</span> + value);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">-------output-------</span><br><span class=\"line\"><span class=\"keyword\">finally</span>: <span class=\"number\">100</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//方法2：对 then 进行 promise chain 方式进行调用</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> p2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">    resolve(<span class=\"number\">100</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">p2.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value * <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value * <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"finally: \"</span> + value);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">-------output-------</span><br><span class=\"line\"><span class=\"keyword\">finally</span>: <span class=\"number\">400</span></span><br></pre></td></tr></table></figure></p>\n<p>第一种方法中，then的调用几乎是同时开始执行的，且传给每个then的value都是100，这种方法应当避免。方法二才是正确的链式调用。<br>因此容易出现下面的错误写法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 例4.4 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">badAsyncCall</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> promise = <span class=\"built_in\">Promise</span>.resolve(data);</span><br><span class=\"line\">    promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//do something</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> value + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> promise;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">badAsyncCall(<span class=\"number\">10</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(value);          <span class=\"comment\">//想要得到11，实际输出10</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">-------output-------</span><br><span class=\"line\"><span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n<p>正确的写法应该是：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 改写例4.4 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">goodAsyncCall</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> promise = <span class=\"built_in\">Promise</span>.resolve(data);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//do something</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> value + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">goodAsyncCall(<span class=\"number\">10</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(value);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">-------output-------</span><br><span class=\"line\"><span class=\"number\">11</span></span><br></pre></td></tr></table></figure>\n<p><strong>情景4</strong>：在异步回调中抛错，不会被catch到<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Errors thrown inside asynchronous functions will act like uncaught errors</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"string\">'Uncaught Exception!'</span>;</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">promise.catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(e);       <span class=\"comment\">//This is never called</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p><strong>情景5</strong>： promise状态变为resove或reject，就凝固了，不会再改变<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>)</span>&#123;</span><br><span class=\"line\">    reject();</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        resolve();            <span class=\"comment\">//not called</span></span><br><span class=\"line\">    &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">4</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">-------output-------</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>通过阅读这篇文章，让我对promise有个大概的认识。文章出处：<a href=\"https://segmentfault.com/a/1190000007032448#articleHeader16\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000007032448#articleHeader16</a></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckep5vtck0005l4i9zwld8f72","category_id":"ckep5vtcd0002l4i9b7cxd5qb","_id":"ckep5vtcq000dl4i9ygha6y8j"},{"post_id":"ckep5vtc40000l4i90jfcuq44","category_id":"ckep5vtcd0002l4i9b7cxd5qb","_id":"ckep5vtcs000gl4i9p6zl6lyy"},{"post_id":"ckep5vtcf0004l4i99epf94qs","category_id":"ckep5vtcd0002l4i9b7cxd5qb","_id":"ckep5vtcu000jl4i9ewn82k4j"},{"post_id":"ckep5vtfl000yl4i9ivbmrn5v","category_id":"ckep5vtcd0002l4i9b7cxd5qb","_id":"ckep5vtfp0011l4i9qv87w70y"},{"post_id":"ckep5vtgr0013l4i97onr7fzu","category_id":"ckep5vtcd0002l4i9b7cxd5qb","_id":"ckep5vtgt0015l4i9fmfb4epv"}],"PostTag":[{"post_id":"ckep5vtck0005l4i9zwld8f72","tag_id":"ckep5vtcf0003l4i9oznpit53","_id":"ckep5vtco0009l4i92gls7m5q"},{"post_id":"ckep5vtc40000l4i90jfcuq44","tag_id":"ckep5vtcf0003l4i9oznpit53","_id":"ckep5vtcp000bl4i9pq6sbjiu"},{"post_id":"ckep5vtcb0001l4i9u1dnsdc1","tag_id":"ckep5vtcm0008l4i9s8em9q4v","_id":"ckep5vtcs000hl4i9ce4mi823"},{"post_id":"ckep5vtcf0004l4i99epf94qs","tag_id":"ckep5vtcq000el4i9h64jqgu6","_id":"ckep5vtcu000ll4i93113goe9"},{"post_id":"ckep5vtct000il4i98izlh8dm","tag_id":"ckep5vtcm0008l4i9s8em9q4v","_id":"ckep5vtcu000ml4i9rbxcrg30"},{"post_id":"ckep5vtcl0006l4i9w2t8nuvw","tag_id":"ckep5vtcu000kl4i9270osug5","_id":"ckep5vtcv000ol4i9s1ouknsk"},{"post_id":"ckep5vtcl0006l4i9w2t8nuvw","tag_id":"ckep5vtcf0003l4i9oznpit53","_id":"ckep5vtcv000pl4i9yep9d8cc"},{"post_id":"ckep5vtco000al4i962wro7fq","tag_id":"ckep5vtcv000nl4i9r1es0ah6","_id":"ckep5vtcw000sl4i9mhryq7u0"},{"post_id":"ckep5vtco000al4i962wro7fq","tag_id":"ckep5vtcv000ql4i95gnnyc77","_id":"ckep5vtcw000tl4i9vwuxx6p4"},{"post_id":"ckep5vtcp000cl4i9um342snf","tag_id":"ckep5vtcw000rl4i9rsv7pkts","_id":"ckep5vtcx000vl4i9el53v011"},{"post_id":"ckep5vtcr000fl4i93dmeawdw","tag_id":"ckep5vtcw000ul4i9bovswka9","_id":"ckep5vtcx000wl4i98oxa6nvv"},{"post_id":"ckep5vtcr000fl4i93dmeawdw","tag_id":"ckep5vtcf0003l4i9oznpit53","_id":"ckep5vtcx000xl4i92cckrbao"},{"post_id":"ckep5vtfl000yl4i9ivbmrn5v","tag_id":"ckep5vtfp0010l4i9aropcsb4","_id":"ckep5vtfq0012l4i9xdvb4q74"},{"post_id":"ckep5vtgr0013l4i97onr7fzu","tag_id":"ckep5vtgt0014l4i959dg98dm","_id":"ckep5vtgu0017l4i9rq780g01"},{"post_id":"ckep5vtgr0013l4i97onr7fzu","tag_id":"ckep5vtgu0016l4i94auqizkq","_id":"ckep5vtgu0018l4i91ux1cok4"}],"Tag":[{"name":"git","_id":"ckep5vtcf0003l4i9oznpit53"},{"name":"nodejs","_id":"ckep5vtcm0008l4i9s8em9q4v"},{"name":"http","_id":"ckep5vtcq000el4i9h64jqgu6"},{"name":"bash","_id":"ckep5vtcu000kl4i9270osug5"},{"name":"canvas","_id":"ckep5vtcv000nl4i9r1es0ah6"},{"name":"百分比","_id":"ckep5vtcv000ql4i95gnnyc77"},{"name":"前端环境","_id":"ckep5vtcw000rl4i9rsv7pkts"},{"name":"sublime","_id":"ckep5vtcw000ul4i9bovswka9"},{"name":"vdom","_id":"ckep5vtfp0010l4i9aropcsb4"},{"name":"promise","_id":"ckep5vtgt0014l4i959dg98dm"},{"name":"js","_id":"ckep5vtgu0016l4i94auqizkq"}]}}